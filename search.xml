<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/02/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器事件环EventLoop</title>
    <url>/2021/08/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E7%8E%AFEventLoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器事件环EventLoop"><a href="#浏览器事件环EventLoop" class="headerlink" title="浏览器事件环EventLoop"></a>浏览器事件环EventLoop</h1><h2 id="1-进程和“线程”"><a href="#1-进程和“线程”" class="headerlink" title="1.进程和“线程”"></a>1.进程和“线程”</h2><p> 进程：计算机分配任务的 和调度的任务最小单位， 浏览器是一个多进程模型， 每个页卡都是一个独立的进程 （更稳定）</p>
<p> 后端代码都是采用多进程</p>
<p>线程 ： 常见的线程有哪些 (JS是单线程的？主线程是单线程的)</p>
<ol>
<li><p>GUI渲染 页面渲染，绘图、绘制 3d动画</p>
</li>
<li><p>js渲染引擎： 执行js代码 当js执行时 渲染线程会挂起 -》 渲染时不能执行js</p>
</li>
<li><p>事件触发线程 EventLoop</p>
</li>
<li><p>webApi 也会创建线程 事件、定时器、ajax请求都会创造一个线程</p>
</li>
</ol>
<h2 id="2-宏任务和微任务"><a href="#2-宏任务和微任务" class="headerlink" title="2.宏任务和微任务"></a>2.宏任务和微任务</h2><ol>
<li>宏任务<ul>
<li> &lt;执行脚本 script&gt;</li>
<li>setTimeout </li>
<li>setInterval </li>
<li>setImmediate </li>
<li>事件</li>
<li>ajax </li>
<li> MessageChannel (I/O)</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>微任务</p>
<ul>
<li><p>promise</p>
</li>
<li><p>MutationObserer（监视DOM树的变化）</p>
</li>
<li><p>node中的process.nextTick</p>
</li>
</ul>
</li>
<li><p>渲染有关</p>
<ul>
<li>requestAnimationFrame (（大约）16.6ms 会渲染一次页面，也有可能不渲染) 渲染之前执行的</li>
<li> requestIDleCallback 空闲时间执行 </li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>总结</p>
<ol>
<li><p>先执行script脚本，将宏任务和微任务进行分类，如果调用的是浏览器api ，浏览器会开一个线程，等时间到了，会自动的放入到宏任务队列中,微任务是直接放到微任务队列中的</p>
</li>
<li><p>js执行完毕后，会清空所有的微任务，如果微任务在产生微任务，会放到当前微任务队列的尾部</p>
</li>
<li><p>微任务对列清空后，如果页面需要渲染，则会执行渲染流程</p>
</li>
<li><p>事件触发线程EventLoop会不停的扫描宏任务队列，如果宏任务队列中有对应的回调，会取出来执行一个，继续执行上述过程</p>
</li>
<li><p>宏任务每次调用一个，微任务是请空所有微任务队列</p>
</li>
<li><p>每次执行宏任务 都会创造一个新的队列，宏任务队列只有一个</p>
<p>​    </p>
</li>
</ol>
</li>
</ol>
<p>画图功底有限…</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628232140260-1628232140253.png"></p>
<h2 id="3-代码实操"><a href="#3-代码实操" class="headerlink" title="3.代码实操"></a>3.代码实操</h2><h3 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.style.background = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.style.background = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果是：1,3,2，黄变绿闪烁。原因是：微任务执行完才走渲染，red虽然是同步任务，添加到渲染线程里面了，但是微任务执行完yellow后，覆盖了，所以不会出现红色，但是宏任务green执行后，又将颜色改为了绿色，这段时间差就会出现闪烁。</p>
<h3 id="案例2："><a href="#案例2：" class="headerlink" title="案例2："></a>案例2：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task1&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task2&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码，点击按钮后，会依次打印：click1，micro task1，click2，micro task2</p>
<p>原因是js脚本运行后，会将两个点击事件放入浏览器api中，当点击了按钮，就将两个事件按先后顺序压入宏任务队列，然后执行click1，先执行同步任务console.log，在创建微任务队列执行promise，微任务执行完后，没有要渲染的页面，。就拿出第二个宏任务click2，执行同步任务，再创建微任务队列，执行promise。</p>
<h3 id="案例3："><a href="#案例3：" class="headerlink" title="案例3："></a>案例3：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task1&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task2&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.click()</span><br></pre></td></tr></table></figure>

<p>上述代码，打印顺序是：click1,click2,micro task1,micro task1</p>
<p>原因是：手动调用click事件，就不会产生宏任务，所以先执行同步任务console.log，在一次执行promise</p>
<h3 id="案例4："><a href="#案例4：" class="headerlink" title="案例4："></a>案例4：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码答应顺序依次是：Promise1，setTimeout1，Promise2，setTimeout2</p>
<p>手动模拟一下运行时候的场景(省略了浏览器api过程)</p>
<ol>
<li><p>第一轮先将栈里的任务分别放入</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏任务队列[setTimeout1]，微任务队列[Promise1]</p>
</li>
<li><p>清空微任务，此时执行promise1打印Promise1，将产生的宏任务压入宏任务队列，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏[setTimeout1,setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout1执行，打印setTimeout1，创建微任务队列，将promise2压入队列，此时宏任务setTimeout1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[promise2]</p>
</li>
<li><p>宏任务执行完毕需要清空微任务队列，拿出promise2执行，打印promise2，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout2执行，打印setTimeout2，此时宏任务微任务队列都是空，本轮渲染结束</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[]，微[]</p>
</li>
</ol>
<h3 id="案例5："><a href="#案例5：" class="headerlink" title="案例5："></a>案例5：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果是：16238745</p>
<p>原因是：</p>
<ol>
<li><p>解释async…await</p>
<ol>
<li><p>async 执行后返回的是一个promise</p>
</li>
<li><p>await console.log(3); =&gt; return Promise.resolve(console.log(3)).then(()=&gt;console.log(4))</p>
<p>相当于让await后面的代码立即执行，将await下面的代码用then的形式添加到微任务队列</p>
</li>
</ol>
</li>
<li><p>首先肯定打印1，继续往下走async函数声明了未调用先不用管，setTime进入宏任务队列，promise进入微任务队列，then不用管，async函数调用，将返回函数作为promise2压入微任务队列，console暂时执行不到</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise1，promise2]</p>
</li>
<li><p>先执行promise1，打印6，resolve将7传入then中，把7then压入微任务队列，promise1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise2,7then]</p>
</li>
<li><p>执行promise2，打印2，打印3，将4then压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[7then,4then]</p>
</li>
<li><p>此时async函数执行完毕。console.log(8)执行打印8</p>
</li>
<li><p>继续执行微任务7then，打印7</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[4then]</p>
</li>
<li><p>继续执行微任务4then，打印4</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[]</p>
</li>
<li><p>此时微任务队列清空，开始执行宏任务，打印5</p>
</li>
<li><p>此时宏任务，微任务全部清空，程序结束</p>
</li>
</ol>
<h3 id="案例6："><a href="#案例6：" class="headerlink" title="案例6："></a>案例6：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述打印结果为0,1,2,3,4,5</p>
<p>原因是</p>
<ol>
<li><p>解释return一个promise，不会立刻处理，而是会将这个promise放入异步代码中</p>
</li>
<li><p>将then0和then1放入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then0，then1]</p>
</li>
<li><p>执行then0,打印02，返回一个Promise.resolve，会执行自己的then方法</p>
</li>
<li><p>执行then1打印，将then2压入栈中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then2]</p>
</li>
<li><p>由于return一个promise的特性，then会延迟执行</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then2，then]</p>
</li>
<li><p>执行then2打印then2，将then3压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then3]</p>
</li>
<li><p>执行then，将4传入then中，将then4压入队列</p>
</li>
<li><p>执行then3，打印3，将then5压入队列中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then4，then5]</p>
</li>
<li><p>依次执行，打印4,5，程序结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>01-我的足迹</title>
    <url>/2021/08/03/01-%E6%88%91%E7%9A%84%E8%B6%B3%E8%BF%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我的足迹"><a href="#我的足迹" class="headerlink" title="我的足迹"></a>我的足迹</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1627962230903-1627962230899-009ab009c185d053eb57474d868fce4.jpg"></p>
<h2 id="旅行经历"><a href="#旅行经历" class="headerlink" title="旅行经历"></a>旅行经历</h2><p>2021/4/26 - 2021/5/5 去了云南</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Js数据类型</title>
    <url>/2021/08/03/01-Js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、为什么要区分不同的数据类型"><a href="#一、为什么要区分不同的数据类型" class="headerlink" title="一、为什么要区分不同的数据类型"></a>一、为什么要区分不同的数据类型</h1><p>在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。</p>
<h1 id="二、JS中一共有七种数据类型"><a href="#二、JS中一共有七种数据类型" class="headerlink" title="二、JS中一共有七种数据类型"></a>二、JS中一共有七种数据类型</h1><ul>
<li><strong>基本数据类型（值类型）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义、Symbol(ES6新增)。</li>
<li><strong>引用数据类型（引用类型）</strong>：Object 对象。</li>
</ul>
<p>注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那六种基本数据类型之外，其他的，都称之为 Object类型。</p>
<h3 id="1-查看数据类型的方式typeof"><a href="#1-查看数据类型的方式typeof" class="headerlink" title="1.查看数据类型的方式typeof()"></a>1.查看数据类型的方式typeof()</h3><ul>
<li>typeof()返回的是一个字符串类型</li>
<li>typeof()检测的特殊值<ul>
<li>基本数据类型null返回的是object —&gt;  js历史遗留的bug</li>
<li>复杂数据类型function返回的是functiong —&gt; 函数是js中的一等公民。有双重身份，即是obj又是function<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);<span class="comment">//number</span></span><br><span class="line"><span class="comment">//typeof 返回的是一个字符串类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">10</span>));<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;hello&#x27;</span>);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>);<span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);<span class="comment">//object</span></span><br><span class="line"><span class="comment">// typeof不仅可以检测单个值，加小括号可以检测表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="number">10</span> + <span class="string">&#x27;10&#x27;</span>));<span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof()"></a>2.instanceof()</h3></li>
</ul>
</li>
</ul>
<p><strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链<br>函数既是function又是object…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">String</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h1 id="三、String类型"><a href="#三、String类型" class="headerlink" title="三、String类型"></a>三、String类型</h1><h2 id="1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"><a href="#1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。" class="headerlink" title="1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"></a>1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。</h2><h2 id="2-String中的转义字符"><a href="#2-String中的转义字符" class="headerlink" title="2.String中的转义字符"></a>2.String中的转义字符</h2><p>和css中的特殊字符类似</p>
<ul>
<li><code>\&quot;</code> 表示 <code>&quot;</code></li>
<li><code>\&#39;</code> 表示 <code>&#39;</code></li>
<li><code>\\</code> 表示<code>\</code></li>
<li><code>\r</code> 表示回车</li>
<li><code>\n</code> 表示换行。n 的意思是 newline。</li>
<li><code>\t</code> 表示缩进。t 的意思是 tab。</li>
<li><code>\b</code> 表示空格。b 的意思是 blank。</li>
</ul>
<h2 id="3-获取字符串的长度"><a href="#3-获取字符串的长度" class="headerlink" title="3.获取字符串的长度"></a>3.获取字符串的长度</h2><p>String.length</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var str1 = &#x27;1；23&#x27;;</span><br><span class="line">  var str2 = &#x27;小艾 同学&#x27;;</span><br><span class="line">  var str3 = &#x27;ab,cd&#x27;;</span><br><span class="line"></span><br><span class="line">  // 注意：</span><br><span class="line">  // 中文、英文字母、数字都占一个字符</span><br><span class="line">  // 中英文标点符号都占一个字符</span><br><span class="line">  // 空格也占一个字符</span><br><span class="line">  console.log(str1.length);//4</span><br><span class="line">  console.log(str2.length);//5</span><br><span class="line">  console.log(str3.length);//5</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4.字符串拼接"></a>4.字符串拼接</h2><p>当<code>+</code>号的连接的是一个字符串，就会变成连接符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串 + 任意数据类型 = 拼接之后的新字符串;</span><br></pre></td></tr></table></figure>
<p>字符串和任何数据类型拼接，都会将拼接内容隐式转为字符串，并输出一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span> + <span class="literal">null</span>);<span class="comment">//10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span> + <span class="literal">true</span>);<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当加号的左侧或右侧为一个字符串类型时，就会作为连接符</span></span><br><span class="line">  <span class="comment">//将任何数据类型都转为字符串，在返回拼接后的新字符串</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span> + <span class="literal">null</span>);<span class="comment">//10null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span>);<span class="comment">//true10</span></span><br><span class="line"><span class="comment">//复杂数据类型也会隐式转换为字符串哦</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学&#x27;</span> + &#123;&#125;);<span class="comment">//小艾同学[object Object]</span></span><br></pre></td></tr></table></figure>
<p>变量与字符串拼接为了不让转为字符串，通常采用引引加加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串与变量拼接</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 要想在字符串中插入一个变量，就不能让该变量暴露在引号中</span></span><br><span class="line"><span class="comment">//可以用引引加加口诀， &#x27;+a+&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学a分&#x27;</span>);<span class="comment">//小艾同学a分</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学&#x27;</span> + a + <span class="string">&#x27;分&#x27;</span>);<span class="comment">//小艾同学100分</span></span><br></pre></td></tr></table></figure>
<p>凡是存在隐式转换的地方，都不应该广泛使用，所以字符串拼接是，尽量不用加号隐式转换，推荐使用<code>$&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`小<span class="subst">$&#123;a&#125;</span>艾同<span class="subst">$&#123;b&#125;</span>学`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-ES6字符串遍历"><a href="#5-ES6字符串遍历" class="headerlink" title="5.ES6字符串遍历"></a>5.ES6字符串遍历</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> str= <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> char <span class="keyword">of</span> str)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;字符：&quot;</span>+char);</span><br><span class="line"> <span class="comment">// 字符：1</span></span><br><span class="line"> <span class="comment">// 字符：2</span></span><br><span class="line"> <span class="comment">// 字符：3</span></span><br><span class="line"> <span class="comment">// 字符：4</span></span><br><span class="line"> <span class="comment">// 字符：5</span></span><br><span class="line"> <span class="comment">// 字符：6</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、Number类型"><a href="#四、Number类型" class="headerlink" title="四、Number类型"></a>四、Number类型</h1><h2 id="1-所有的数字都是Number类型"><a href="#1-所有的数字都是Number类型" class="headerlink" title="1.所有的数字都是Number类型"></a>1.所有的数字都是Number类型</h2><p>Js中不存在int,folat类型，正负数，整数，小数都是Number类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0x9</span>;<span class="comment">//前面加0x就是十六进制</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">07</span>;<span class="comment">//前面加0代表八进制</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">2e8</span>;<span class="comment">//e表示科学计数法次幂</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(num);<span class="comment">//9</span></span><br><span class="line">    <span class="built_in">console</span>.log(num1);<span class="comment">//7</span></span><br><span class="line">    <span class="built_in">console</span>.log(num2);<span class="comment">//1.7976931348623157e+308</span></span><br><span class="line">    <span class="comment">// Number最大范围</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);<span class="comment">//1.7976931348623157e+308</span></span><br><span class="line">    <span class="comment">// Number最小范围</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE);<span class="comment">//5e-324</span></span><br><span class="line">    <span class="comment">// 无穷大Infinity</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>);<span class="comment">//Infinity</span></span><br><span class="line">    <span class="comment">// 无穷小-Infinity</span></span><br><span class="line">    <span class="built_in">console</span>.log(-<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>);<span class="comment">//-Infinity</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>补充进制转换（以100为例）<br>几进制就是逢几进一→十进制逢十进一</p>
</blockquote>
<h4 id="各进制转十进制，就是-几进制的位数-1次幂…"><a href="#各进制转十进制，就是-几进制的位数-1次幂…" class="headerlink" title="各进制转十进制，就是*几进制的位数-1次幂…"></a>各进制转十进制，就是*几进制的位数-1次幂…</h4><ul>
<li>十进制转十进制</li>
</ul>
<p>100 = 1_10^2 + 0_10^1 + 0*10^0 = 100</p>
<ul>
<li>二进制转十进制</li>
</ul>
<p>100 = 1_2^2 + 0_2^1 + 0*2^0 = 4</p>
<ul>
<li>八进制转十进制(以0开头就是八进制)</li>
</ul>
<p>0100= 1_8^2 + 0_8^1 + 0*8^0 = 64</p>
<ul>
<li>十六进制转十进制(以0x开头就是十六进制)</li>
</ul>
<p>0x100 = 1_16^2 + 0_16^1 + 0*16^0 = 256</p>
<h4 id="十进制转各进制就是-该进制的余数倒过来…"><a href="#十进制转各进制就是-该进制的余数倒过来…" class="headerlink" title="十进制转各进制就是/该进制的余数倒过来…"></a>十进制转各进制就是/该进制的余数倒过来…</h4><ul>
<li>十进制转二进制</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661499-a409744a-df42-4062-9025-1bb38e04c68e.png#align=left&display=inline&height=667&margin=%5Bobject%20Object%5D&originHeight=667&originWidth=859&size=0&status=done&style=none&width=859"></p>
<ul>
<li>别的进制同理</li>
</ul>
<h2 id="2-Number类型的特殊值—NaN"><a href="#2-Number类型的特殊值—NaN" class="headerlink" title="2.Number类型的特殊值—NaN"></a>2.Number类型的特殊值—NaN</h2><p>Not a Numberde 的简写，是Number类型</p>
<p>特点：NaN不等于任何东西，包括他自己</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// NaN不等于任何</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">NaN</span> =-= <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line">  <span class="comment">// 返回NaN的情况</span></span><br><span class="line">  <span class="comment">// 1.字符串计算</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> - <span class="number">1</span>);<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.类型转换时开头有无法转换成数字的值</span></span><br><span class="line">  <span class="comment">// 不能转换的一定要在开头</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1a&#x27;</span>));<span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;a1&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>());<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;x&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;x&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-1-isNaN（）函数"><a href="#2-1-isNaN（）函数" class="headerlink" title="2.1 isNaN（）函数"></a>2.1 isNaN（）函数</h3><p>用来确定一个值是否为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isNaN()，判断传入的参数是否为NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有0/0会返回true，其他任何数值都是false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">1</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">1</span> / <span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">//false（ 10 是一个数值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能转为数字的别的类型也会返回false,无法转换的返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">//false（可以被转换成数值 10）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;a10&quot;</span>)); <span class="comment">//true（可以被转换成数值 10）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//true（不能转换成数值）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure>


<h2 id="3-0-1-0-2不等于0-3"><a href="#3-0-1-0-2不等于0-3" class="headerlink" title="3.0.1+0.2不等于0.3"></a>3.0.1+0.2不等于0.3</h2><p>失精<br>参考：<a href="https://juejin.im/post/5b90e00e6fb9a05cf9080dff">https://juejin.im/post/5b90e00e6fb9a05cf9080dff</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//0.30000000000000004</span></span><br></pre></td></tr></table></figure>


<h1 id="五、Boolean类型"><a href="#五、Boolean类型" class="headerlink" title="五、Boolean类型"></a>五、Boolean类型</h1><p>只有两个值：true和false<br>在输出Boolean类型时，不能加引号哦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>);<span class="comment">//false ---&gt; 布尔类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;false&#x27;</span>);<span class="comment">//false ---&gt; 字符串类型</span></span><br></pre></td></tr></table></figure>
<h1 id="六、Null"><a href="#六、Null" class="headerlink" title="六、Null"></a>六、Null</h1><p>null表示”空对象”，即该处不应该有值，用来表示空指针引用。<br>typeof Null 返回的是object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h1 id="七、undefined"><a href="#七、undefined" class="headerlink" title="七、undefined"></a>七、undefined</h1><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 变量声明了未赋值，返回的即使undefined</span><br><span class="line">  var a;</span><br><span class="line">  console.log(a);//undefined</span><br><span class="line">  </span><br><span class="line">  // 检测undefined类型</span><br><span class="line">  console.log(typeof undefined);//undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h1 id="八、比较Null和undefined"><a href="#八、比较Null和undefined" class="headerlink" title="八、比较Null和undefined"></a>八、比较Null和undefined</h1><p>简单理解，以糖葫芦为例，本来应该是一串糖葫芦，undefined相当于就剩一个竹签了，null就是连签都没有…<br>推荐文章<br><a href="https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// null与undefined</span><br><span class="line">console.log(null == undefined);//ture</span><br><span class="line">console.log(null === undefined);//false</span><br><span class="line"></span><br><span class="line">// 计算</span><br><span class="line">console.log(1 + null);//1</span><br><span class="line">console.log(1 + undefined);//NaN</span><br></pre></td></tr></table></figure>


<h1 id="九、基本数据类型和引用数据类型区别"><a href="#九、基本数据类型和引用数据类型区别" class="headerlink" title="九、基本数据类型和引用数据类型区别"></a>九、基本数据类型和引用数据类型区别</h1><h2 id="1-储存位置不同"><a href="#1-储存位置不同" class="headerlink" title="1.储存位置不同"></a>1.储存位置不同</h2><ul>
<li>基本数据类型存放在栈中，数据大小确定，内存空间大小可以分配，直接按值存放的，所以可以直接按值访问。</li>
<li>引用数据类型存放在堆内存中，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址)，这个指针指向堆内存。在栈内存中保存的是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</li>
</ul>
<blockquote>
<p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。<br>堆：先进先出<br>栈：先进后出<br>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661556-a22ecd2b-19b9-49fc-a03e-a3961bdc15a0.png#align=left&display=inline&height=954&margin=%5Bobject%20Object%5D&originHeight=954&originWidth=1713&size=0&status=done&style=none&width=1713"></p>
</blockquote>
<h2 id="2-复制操作"><a href="#2-复制操作" class="headerlink" title="2.复制操作"></a>2.复制操作</h2><ul>
<li>基本数据类型从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上，改变源数据不会影响到新的变量（互不干涉）</li>
<li>引用类型复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此改变其中的一个，将影响另一个；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = a;</span><br><span class="line">  b = 20;</span><br><span class="line"></span><br><span class="line">  var arr = [&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;];</span><br><span class="line">  var arr1 = arr;</span><br><span class="line">  arr1.push(&#x27;666&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 基本数据类型复制后，改变复制的变量，原值不受影响</span><br><span class="line">  console.log(a);//10</span><br><span class="line">  console.log(b );//20</span><br><span class="line"></span><br><span class="line">  // 引用类型复制后，改变复制的变量，原值也会跟着改变</span><br><span class="line">  console.log(arr);//[&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;,&#x27;666&#x27;]</span><br><span class="line">  console.log(arr1);//[&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;,&#x27;666&#x27;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661598-aba71641-d1c0-4a7a-9606-cd5f1169e7ad.png#align=left&display=inline&height=1214&margin=%5Bobject%20Object%5D&originHeight=1214&originWidth=2880&size=0&status=done&style=none&width=2880"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2021/08/04/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>举个简单例子：</p>
<p>你爸爸承诺下礼拜发工资了给你买个手机。你 [不知道] 你是否会得到手机直到下礼拜，此时进入等待态。你爸爸真的给你买一个手机(因为发工资有钱了)，也可以告诉你不买了(因为先给自己买了)。这是一个承诺。一个承诺有3个状态。分别是:</p>
<p>1.悬而未决：你 [不知道] 你是否会得到手机直到下礼拜（<strong style="color:#17a2b8;">等待态</strong>）。</p>
<p>2.解决：你老妈给你买了，因为发工资有钱了（<strong style="color:#17a2b8;">成功态</strong>）。</p>
<p>3.拒绝：你老妈拒绝给你买，因为钱不够（<strong style="color:#17a2b8;">失败态</strong>）。</p>
<p>总结：</p>
<ol>
<li>Promise 有三个状态 ：<ol>
<li> 默认状态叫等待态 pending</li>
<li>resolve表示成功态 fulfilled</li>
<li>reject表示变成失败态 rejected</li>
</ol>
</li>
<li>成功有成功的原因，失败也有失败的原因</li>
<li>只有pending的状态的时候才能改变状态<ul>
<li>不能从成功变为失败</li>
<li>不能从失败变为成功</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">const</span> money = <span class="number">9999</span></span><br><span class="line"><span class="keyword">const</span> bugPhone = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (money &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;有钱，买！&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;我先给我买手机了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// then方法中提供两个参数 1. 成功回调 2.失败的回调</span></span><br><span class="line">bugPhone.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>当既调用成功，又调用失败：只会变为第一次调用的状态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时只会执行resolve，因为状态一旦确定无法改变</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>失败状态的方法reject和throw new Error都可以变为失败态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在异步中，仍然可以正常使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;error&#x27;)</span></span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="comment">// return new Error(&#x27;失败&#x27;)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>支持<code>.then</code> 链式调用<ul>
<li>当<code>.then</code> 中返回的是一个Promise，可以继续<code>.then</code> 调用这个返回的promise，以下称原来的promise为promise，返回的promise为promise2<ul>
<li>当promise2结果是成功：链式调用<code>.then</code>直接进入<code>resolve</code></li>
<li>当promise2结果为失败或抛出异常：链式调用<code>.then</code>直接进入<code>reject</code></li>
</ul>
</li>
<li>当<code>.then</code> 中返回的的是一个非Promise，链式调用<code>.then</code>时，直接进入<code>resolve</code></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个promise，并是成功态</span></span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 进入成功</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个promise，并是失败态，或异常</span></span><br><span class="line">    <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err) <span class="comment">// 进入失败</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个非promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 直接进入成功</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>链式调用中不允许循环引用<ul>
<li>new一个Promise，<code>.then</code>时，将这个Promise返回，链式<code>.then</code>再次调用就会出现循环引用</li>
<li>原理是：返回的promise始终在等待态，再调用依然是等待态。通俗说就是自己等自己</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise6 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise6;<span class="comment">// prending resolve()/reject()</span></span><br><span class="line">&#125;)</span><br><span class="line">promise6.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err) <span class="comment">// err [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>链式调用可选参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise7 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  <span class="comment">// 当then里没有传任何值的时候，最后一个then用的依然是第一次传入的值</span></span><br><span class="line">&#125;).then().then().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="2-根据promiseaplus官网-的规则，手写自己的Promise"><a href="#2-根据promiseaplus官网-的规则，手写自己的Promise" class="headerlink" title="2.根据promiseaplus官网  的规则，手写自己的Promise"></a>2.根据<a href="https://promisesaplus.com/">promiseaplus官网 </a> 的规则，手写自己的Promise</h3><h4 id="1-一个基本的promise，满足异步promise，但无法进行链式调用"><a href="#1-一个基本的promise，满足异步promise，但无法进行链式调用" class="headerlink" title="1.一个基本的promise，满足异步promise，但无法进行链式调用"></a>1.一个基本的promise，满足异步promise，但无法进行链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span>; <span class="comment">// 默认等待态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span>; <span class="comment">// 成功态 </span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span>; <span class="comment">// 失败态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认状态改为PENDING</span></span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="comment">// 储存传入的成功值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 储存传入的失败</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="comment">// 成功方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 将状态改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED</span><br><span class="line">        <span class="comment">// 执行储存的成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败方法</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 将状态改为失败</span></span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED</span><br><span class="line">        <span class="comment">// 执行储存的失败回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 默认new Promise中的函数会立即执行</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        <span class="comment">// 成功时</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        <span class="comment">// 失败时</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 等待时</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将成功函数push到成功回调队列</span></span><br><span class="line">          onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将成功函数push到失败回调队列</span></span><br><span class="line">          onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>

<h4 id="2-支持链式调用"><a href="#2-支持链式调用" class="headerlink" title="2.支持链式调用"></a>2.支持链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span>; <span class="comment">// 默认等待态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span>; <span class="comment">// 成功态 </span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span>; <span class="comment">// 失败态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理promise逻辑的函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span></span><br><span class="line"><span class="comment"> * 2.x是一个非promise，统统调用resolve</span></span><br><span class="line"><span class="comment"> * 3.x是抛出异常，进入reject</span></span><br><span class="line"><span class="comment"> * 4.x和promise2不能一样，会出现循环引用</span></span><br><span class="line"><span class="comment"> * 5.resolve和reject都只能调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;返回的promise&#125;</span> </span>x </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;new的新&#125;</span> </span>promise2 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;成功方法&#125;</span> </span>resolve </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;失败方法&#125;</span> </span>reject </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, promise2, resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;循环引用&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断返回的x是否是一个promise(promsise需要有then方法)</span></span><br><span class="line">  <span class="comment">// 可能是一个名为promise的对象，或者是一个自定义的promise函数</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x == <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 记录状态是否改变</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取返回的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为返回的有可能还是一个promise</span></span><br><span class="line">        <span class="comment">// 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span></span><br><span class="line">        <span class="comment">// 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span></span><br><span class="line">        then.call(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 这里说明返回的promise是成功状态</span></span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 这里是失败，直接走失败</span></span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">//  让promise2 变成失败态</span></span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进这里，说明x是一个非promise，直接调用resolve</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认状态改为PENDING</span></span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="comment">// 储存传入的成功值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 储存传入的失败</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="comment">// 成功方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 将状态改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED</span><br><span class="line">        <span class="comment">// 执行储存的成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败方法</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 将状态改为失败</span></span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED</span><br><span class="line">        <span class="comment">// 执行储存的失败回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 默认new Promise中的函数会立即执行</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是then()如果传空值，就使用上一个的值</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled == <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected == <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line">    <span class="comment">// 由于promise状态无法修改，所以不能使用同一个promise</span></span><br><span class="line">    <span class="comment">// 实现链式调用不能return this</span></span><br><span class="line">    <span class="comment">// 每次调用then方法 都必须返回一个全新的promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="comment">// 成功时</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          <span class="comment">// 因为需要promise2做参数，所以需要异步调用</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span></span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">              <span class="comment">// 处理函数</span></span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="comment">// 如果出错，直接就走失败</span></span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 失败时</span></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 等待时</span></span><br><span class="line">          <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将成功函数push到成功回调队列</span></span><br><span class="line">                <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将成功函数push到失败回调队列</span></span><br><span class="line">                <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回新的promise，供链式调用</span></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>

<h4 id="3-运行官方测试"><a href="#3-运行官方测试" class="headerlink" title="3.运行官方测试"></a>3.运行官方测试</h4><ol>
<li><p><code>npm install promises-aplus-tests -g</code> 安装测试工具</p>
</li>
<li><p>在promise.js中写 </p>
</li>
<li><p>```js<br>// 官方提供的测试静态方法<br>Promise.deferred = function () {<br>  let dfd = {};<br>  dfd.promise = new Promise((resolve, reject) =&gt; {</p>
<pre><code>dfd.resolve = resolve;
dfd.reject = reject;
</code></pre>
<p>  })<br>  return dfd<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. `promises-aplus-tests promise.js` 根据promise的地址运行测试</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628130801594-1628130801589.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.Promise语法糖</span><br><span class="line"></span><br><span class="line">#### 原生Promise</span><br><span class="line"></span><br><span class="line">1. Promise.resolve和Promise.reject</span><br><span class="line">   + Promise.resolve会等待异步任务执行完毕再进入resolve</span><br><span class="line">   + Promise.reject会直接进入catch</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"></span><br><span class="line">Promise.resolve(&#x27;ok&#x27;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data); // ok</span><br><span class="line">&#125;)</span><br><span class="line">// Promise.reject会直接进入catch</span><br><span class="line">Promise.reject(&#x27;失败&#x27;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&#x27;err&#x27;, err); // 失败</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 异步时</span><br><span class="line">Promise.resolve(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;hello&#x27;, &#x27;success&#x27;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;)).then(data =&gt; &#123;</span><br><span class="line">  console.log(data); // hello</span><br><span class="line">&#125;)</span><br><span class="line">// Promise.reject会直接进入catch</span><br><span class="line">Promise.reject(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;hello&#x27;); </span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&#x27;err&#x27;, err); // err Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>Promise.all</p>
<ul>
<li>所有任务都成功，才会进入成功</li>
<li>只要有一个任务失败，就会进入失败</li>
<li>成功任务返回时，会按照书写顺序返回</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fs.readFile(<span class="string">&#x27;./promise-study/name.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), fs.readFile(<span class="string">&#x27;./promise-study/age.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), <span class="number">11</span>]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Promise.finally<ul>
<li>不管成功还是失败都会执行</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally 不管成功还是失败都会执行</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">&#x27;err&#x27;</span>).finally(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 没有参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>, f)</span><br><span class="line">  <span class="comment">// return 一个普通值没有意义</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;finally&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;ok&#x27;</span>).finally(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>, f)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>当返回的是一个promise<ul>
<li>外层promise为reject时<ul>
<li>里层promise为reject，就会使用里层promise的原因走reject</li>
<li>里层的promsie为resolve，就会以外层的reject原因走reject</li>
</ul>
</li>
<li>外层promsie为resolve时<ul>
<li>里层的promise为resolve，就会以外层resolve的原因走resolve</li>
<li>里层的promise为reject，就会以里层reject的原因走reject</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">&#x27;ok&#x27;</span>).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&#x27;finally reject&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="我的promise实现"><a href="#我的promise实现" class="headerlink" title="我的promise实现"></a>我的promise实现</h4><ol>
<li>Promise.resolve和Promise.reject</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const PENDING = &#x27;PENDING&#x27;; // 默认等待态</span><br><span class="line">const FULFILLED = &#x27;FULFILLED&#x27;; // 成功态 </span><br><span class="line">const REJECTED = &#x27;REJECTED&#x27;; // 失败态</span><br><span class="line"></span><br><span class="line">// 处理promise逻辑的函数</span><br><span class="line">/**</span><br><span class="line"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span><br><span class="line"> * 2.x是一个非promise，统统调用resolve</span><br><span class="line"> * 3.x是抛出异常，进入reject</span><br><span class="line"> * 4.x和promise2不能一样，会出现循环引用</span><br><span class="line"> * 5.resolve和reject都只能调用一次</span><br><span class="line"> * @param &#123;返回的promise&#125; x </span><br><span class="line"> * @param &#123;new的新&#125; promise2 </span><br><span class="line"> * @param &#123;成功方法&#125; resolve </span><br><span class="line"> * @param &#123;失败方法&#125; reject </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function resolvePromise(x, promise2, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span><br><span class="line">  if (x <span class="comment">=== promise2) &#123;</span></span><br><span class="line">    return reject(new TypeError(&#x27;循环引用&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断返回的x是否是一个promise(promsise需要有then方法)</span><br><span class="line">  // 可能是一个名为promise的对象，或者是一个自定义的promise函数</span><br><span class="line">  if ((typeof x <span class="comment">=== &#x27;object&#x27; &amp;&amp; x !== null) || (typeof x == &#x27;function&#x27;)) &#123;</span></span><br><span class="line">    // 记录状态是否改变</span><br><span class="line">    let called = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 获取返回的then方法</span><br><span class="line">      let then = x.then;</span><br><span class="line">      if (typeof then <span class="comment">=== &#x27;function&#x27;) &#123;</span></span><br><span class="line">        // 因为返回的有可能还是一个promise</span><br><span class="line">        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span><br><span class="line">        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span><br><span class="line">        then.call(x, (y) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里说明返回的promise是成功状态</span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, (r) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里是失败，直接走失败</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      // 如果状态改变了，就不往下走</span><br><span class="line">      if (called) return;</span><br><span class="line">      // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">      called = true</span><br><span class="line">      //  让promise2 变成失败态</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 进这里，说明x是一个非promise，直接调用resolve</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态改为PENDING</span><br><span class="line">    this.status = PENDING;</span><br><span class="line">    // 储存传入的成功值</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    // 储存传入的失败</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">    this.onRejectedCallbacks = [];</span><br><span class="line">    // 成功方法</span><br><span class="line"><span class="addition">+    const resolve = (value) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      // 看resolve中是否是一个promise</span></span><br><span class="line"><span class="addition">+      if (value instanceof Promise) &#123;</span></span><br><span class="line"><span class="addition">+        // 如果是，就手动掉用then方法。递归知道他不是一个promise</span></span><br><span class="line"><span class="addition">+        return value.then(resolve, reject);</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.value = value</span><br><span class="line">        // 将状态改为成功</span><br><span class="line">        this.status = FULFILLED</span><br><span class="line">        // 执行储存的成功回调</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 失败方法</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.reason = reason</span><br><span class="line">        // 将状态改为失败</span><br><span class="line">        this.status = REJECTED</span><br><span class="line">        // 执行储存的失败回调</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 默认new Promise中的函数会立即执行</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then方法</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    // 这里是then()如果传空值，就使用上一个的值</span><br><span class="line">    onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : v =&gt; v;</span><br><span class="line">    onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : e =&gt; &#123; throw e &#125;;</span><br><span class="line">    // 由于promise状态无法修改，所以不能使用同一个promise</span><br><span class="line">    // 实现链式调用不能return this</span><br><span class="line">    // 每次调用then方法 都必须返回一个全新的promise</span><br><span class="line">    let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      switch (this.status) &#123;</span><br><span class="line">        // 成功时</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          // 因为需要promise2做参数，所以需要异步调用</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span><br><span class="line">              let x = onFulfilled(this.value)</span><br><span class="line">              // 处理函数</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              // 如果出错，直接就走失败</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line">          break;</span><br><span class="line">        // 失败时</span><br><span class="line">        case REJECTED:</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = onRejected(this.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          // 等待时</span><br><span class="line">          this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到成功回调队列</span><br><span class="line">                let x = onFulfilled(this.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到失败回调队列</span><br><span class="line">                let x = onRejected(this.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 返回新的promise，供链式调用</span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  catch(errFn) &#123;</span></span><br><span class="line"><span class="addition">+     return this.then(null, errFn);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  // 静态方法resolve</span></span><br><span class="line"><span class="addition">+  static resolve(value) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      resolve(value);</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  // 静态方法reject</span></span><br><span class="line"><span class="addition">+  static reject(err) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      reject(err);</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 官方提供的测试静态方法</span><br><span class="line">// npm install promises-aplus-tests -g;</span><br><span class="line">Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  return dfd</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.all</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const PENDING = &#x27;PENDING&#x27;; // 默认等待态</span><br><span class="line">const FULFILLED = &#x27;FULFILLED&#x27;; // 成功态 </span><br><span class="line">const REJECTED = &#x27;REJECTED&#x27;; // 失败态</span><br><span class="line"></span><br><span class="line">// 处理promise逻辑的函数</span><br><span class="line">/**</span><br><span class="line"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span><br><span class="line"> * 2.x是一个非promise，统统调用resolve</span><br><span class="line"> * 3.x是抛出异常，进入reject</span><br><span class="line"> * 4.x和promise2不能一样，会出现循环引用</span><br><span class="line"> * 5.resolve和reject都只能调用一次</span><br><span class="line"> * @param &#123;返回的promise&#125; x </span><br><span class="line"> * @param &#123;new的新&#125; promise2 </span><br><span class="line"> * @param &#123;成功方法&#125; resolve </span><br><span class="line"> * @param &#123;失败方法&#125; reject </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function resolvePromise(x, promise2, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span><br><span class="line">  if (x <span class="comment">=== promise2) &#123;</span></span><br><span class="line">    return reject(new TypeError(&#x27;循环引用&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断返回的x是否是一个promise(promsise需要有then方法)</span><br><span class="line">  // 可能是一个名为promise的对象，或者是一个自定义的promise函数</span><br><span class="line">  if ((typeof x <span class="comment">=== &#x27;object&#x27; &amp;&amp; x !== null) || (typeof x == &#x27;function&#x27;)) &#123;</span></span><br><span class="line">    // 记录状态是否改变</span><br><span class="line">    let called = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 获取返回的then方法</span><br><span class="line">      let then = x.then;</span><br><span class="line">      if (typeof then <span class="comment">=== &#x27;function&#x27;) &#123;</span></span><br><span class="line">        // 因为返回的有可能还是一个promise</span><br><span class="line">        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span><br><span class="line">        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span><br><span class="line">        then.call(x, (y) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里说明返回的promise是成功状态</span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, (r) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里是失败，直接走失败</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      // 如果状态改变了，就不往下走</span><br><span class="line">      if (called) return;</span><br><span class="line">      // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">      called = true</span><br><span class="line">      //  让promise2 变成失败态</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 进这里，说明x是一个非promise，直接调用resolve</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态改为PENDING</span><br><span class="line">    this.status = PENDING;</span><br><span class="line">    // 储存传入的成功值</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    // 储存传入的失败</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">    this.onRejectedCallbacks = [];</span><br><span class="line">    // 成功方法</span><br><span class="line">    const resolve = (value) =&gt; &#123;</span><br><span class="line">      // 看resolve中是否是一个promise</span><br><span class="line">      if (value instanceof Promise) &#123;</span><br><span class="line">        // 如果是，就手动掉用then方法。递归知道他不是一个promise</span><br><span class="line">        return value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.value = value</span><br><span class="line">        // 将状态改为成功</span><br><span class="line">        this.status = FULFILLED</span><br><span class="line">        // 执行储存的成功回调</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 失败方法</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.reason = reason</span><br><span class="line">        // 将状态改为失败</span><br><span class="line">        this.status = REJECTED</span><br><span class="line">        // 执行储存的失败回调</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 默认new Promise中的函数会立即执行</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then方法</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    // 这里是then()如果传空值，就使用上一个的值</span><br><span class="line">    onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : v =&gt; v;</span><br><span class="line">    onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : e =&gt; &#123; throw e &#125;;</span><br><span class="line">    // 由于promise状态无法修改，所以不能使用同一个promise</span><br><span class="line">    // 实现链式调用不能return this</span><br><span class="line">    // 每次调用then方法 都必须返回一个全新的promise</span><br><span class="line">    let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      switch (this.status) &#123;</span><br><span class="line">        // 成功时</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          // 因为需要promise2做参数，所以需要异步调用</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span><br><span class="line">              let x = onFulfilled(this.value)</span><br><span class="line">              // 处理函数</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              // 如果出错，直接就走失败</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line">          break;</span><br><span class="line">        // 失败时</span><br><span class="line">        case REJECTED:</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = onRejected(this.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          // 等待时</span><br><span class="line">          this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到成功回调队列</span><br><span class="line">                let x = onFulfilled(this.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到失败回调队列</span><br><span class="line">                let x = onRejected(this.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 返回新的promise，供链式调用</span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(errFn) &#123;</span><br><span class="line">    return this.then(null, errFn);</span><br><span class="line">  &#125;</span><br><span class="line">  // 静态方法resolve</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 静态方法reject</span><br><span class="line">  static reject(err) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  static all(promises) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      // 将数组中的promise依次执行 </span></span><br><span class="line"><span class="addition">+      let result = [];</span></span><br><span class="line"><span class="addition">+      let index = 0;</span></span><br><span class="line"><span class="addition">+      // 处理函数</span></span><br><span class="line"><span class="addition">+      function process(v, k) &#123;</span></span><br><span class="line"><span class="addition">+        // 将函数与索引映射</span></span><br><span class="line"><span class="addition">+        result[k] = v;</span></span><br><span class="line"><span class="addition">+        if (++index === promises.length) &#123;</span></span><br><span class="line"><span class="addition">+          resolve(result)</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      for (let i = 0; i &lt; promises.length; i++) &#123;</span></span><br><span class="line"><span class="addition">+        let p = promises[i];</span></span><br><span class="line"><span class="addition">+        // 判断p是否是promsie</span></span><br><span class="line"><span class="addition">+        if (p &amp;&amp; typeof p.then === &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="addition">+          p.then(data =&gt; &#123;</span></span><br><span class="line"><span class="addition">+            process(data, i)</span></span><br><span class="line"><span class="addition">+          &#125;, reject) // 只要有一个失败，就直接调reject</span></span><br><span class="line"><span class="addition">+        &#125; else &#123;</span></span><br><span class="line"><span class="addition">+          // 说明不是promise</span></span><br><span class="line"><span class="addition">+          process(p, i)</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 官方提供的测试静态方法</span><br><span class="line">// npm install promises-aplus-tests -g;</span><br><span class="line">Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  return dfd</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>finally方法,直接写在原型上</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Promise.resolve是因为需要有等待功能</span></span><br><span class="line">    <span class="comment">// 成功就直接进then，但使用的原因是外层的原因</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function">(<span class="params">d</span>) =&gt;</span> y);</span><br><span class="line">  &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//cb执行一旦报错 就直接跳过后续的then的逻辑，直接将错误向下传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完结啦~</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>专题</tag>
      </tags>
  </entry>
</search>
