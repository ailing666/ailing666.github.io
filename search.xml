<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浏览器事件环EventLoop</title>
    <url>/2021/08/06/eventloop-liu-lan-qi-shi-jian-huan-eventloop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器事件环EventLoop"><a href="#浏览器事件环EventLoop" class="headerlink" title="浏览器事件环EventLoop"></a>浏览器事件环EventLoop</h1><h2 id="1-进程和“线程”"><a href="#1-进程和“线程”" class="headerlink" title="1.进程和“线程”"></a>1.进程和“线程”</h2><p>  进程：计算机分配任务的 和调度的任务最小单位， 浏览器是一个多进程模型， 每个页卡都是一个独立的进程 （更稳定）</p>
<p>  后端代码都是采用多进程</p>
<p>  线程 ： 常见的线程有哪些 (JS是单线程的？主线程是单线程的)</p>
<ol>
<li><p>GUI渲染 页面渲染，绘图、绘制 3d动画</p>
</li>
<li><p>js渲染引擎： 执行js代码 当js执行时 渲染线程会挂起 -》 渲染时不能执行js</p>
</li>
<li><p>事件触发线程 EventLoop</p>
</li>
<li><p>webApi 也会创建线程 事件、定时器、ajax请求都会创造一个线程</p>
</li>
</ol>
<h2 id="2-宏任务和微任务"><a href="#2-宏任务和微任务" class="headerlink" title="2.宏任务和微任务"></a>2.宏任务和微任务</h2><ol>
<li><p>宏任务</p>
<ul>
<li>&lt;执行脚本 script&gt;</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>事件</li>
<li>ajax</li>
<li>MessageChannel (I/O)</li>
</ul>
</li>
<li><p>微任务</p>
<ul>
<li><p>promise</p>
</li>
<li><p>MutationObserer（监视DOM树的变化）</p>
</li>
<li><p>node中的process.nextTick</p>
</li>
</ul>
</li>
<li><p>渲染有关</p>
<ul>
<li>requestAnimationFrame (（大约）16.6ms 会渲染一次页面，也有可能不渲染) 渲染之前执行的</li>
<li>requestIDleCallback 空闲时间执行</li>
</ul>
</li>
<li><p>总结</p>
<ol>
<li><p>先执行script脚本，将宏任务和微任务进行分类，如果调用的是浏览器api ，浏览器会开一个线程，等时间到了，会自动的放入到宏任务队列中,微任务是直接放到微任务队列中的</p>
</li>
<li><p>js执行完毕后，会清空所有的微任务，如果微任务在产生微任务，会放到当前微任务队列的尾部</p>
</li>
<li><p>微任务对列清空后，如果页面需要渲染，则会执行渲染流程</p>
</li>
<li><p>事件触发线程EventLoop会不停的扫描宏任务队列，如果宏任务队列中有对应的回调，会取出来执行一个，继续执行上述过程</p>
</li>
<li><p>宏任务每次调用一个，微任务是请空所有微任务队列</p>
</li>
<li><p>每次执行宏任务 都会创造一个新的队列，宏任务队列只有一个</p>
</li>
</ol>
</li>
</ol>
<p>画图功底有限…</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628232140260-1628232140253.png" alt="宏任务和微任务"></p>
<h2 id="3-代码实操"><a href="#3-代码实操" class="headerlink" title="3.代码实操"></a>3.代码实操</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><pre><code class="js">    document.body.style.background = 'red'
    console.log(1);
    setTimeout(() =&gt; {
      document.body.style.background = 'green'
      console.log(2);
    }, 0)
    Promise.resolve().then(() =&gt; {
      console.log(3);
      document.body.style.background = 'yellow'
    })
</code></pre>
<p>上述代码的执行结果是：1,3,2，黄变绿闪烁。原因是：微任务执行完才走渲染，red虽然是同步任务，添加到渲染线程里面了，但是微任务执行完yellow后，覆盖了，所以不会出现红色，但是宏任务green执行后，又将颜色改为了绿色，这段时间差就会出现闪烁。</p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><pre><code class="js">  &lt;button id="btn"&gt;按钮&lt;/button&gt;
  &lt;script&gt;
    btn.addEventListener('click', () =&gt; {
      Promise.resolve().then(() =&gt; console.log('micro task1'))
      console.log('click1');
    })
    btn.addEventListener('click', () =&gt; {
      Promise.resolve().then(() =&gt; console.log('micro task2'))
      console.log('click2');
    })
</code></pre>
<p>上述代码，点击按钮后，会依次打印：click1，micro task1，click2，micro task2</p>
<p>原因是js脚本运行后，会将两个点击事件放入浏览器api中，当点击了按钮，就将两个事件按先后顺序压入宏任务队列，然后执行click1，先执行同步任务console.log，在创建微任务队列执行promise，微任务执行完后，没有要渲染的页面，。就拿出第二个宏任务click2，执行同步任务，再创建微任务队列，执行promise。</p>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><pre><code class="js">  &lt;button id="btn"&gt;按钮&lt;/button&gt;
  &lt;script&gt;
    // 3
    btn.addEventListener('click', () =&gt; {
      Promise.resolve().then(() =&gt; console.log('micro task1'))
      console.log('click1');
    })
    btn.addEventListener('click', () =&gt; {
      Promise.resolve().then(() =&gt; console.log('micro task2'))
      console.log('click2');
    })
    btn.click()
</code></pre>
<p>上述代码，打印顺序是：click1,click2,micro task1,micro task1</p>
<p>原因是：手动调用click事件，就不会产生宏任务，所以先执行同步任务console.log，在一次执行promise</p>
<h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><pre><code class="js">    Promise.resolve().then(() =&gt; {
      console.log('Promise1')
      setTimeout(() =&gt; {
        console.log('setTimeout2')
      }, 0);
    })
    setTimeout(() =&gt; {
      console.log('setTimeout1');
      Promise.resolve().then(() =&gt; {
        console.log('Promise2')
      })
    }, 0);
</code></pre>
<p>上述代码答应顺序依次是：Promise1，setTimeout1，Promise2，setTimeout2</p>
<p>手动模拟一下运行时候的场景(省略了浏览器api过程)</p>
<ol>
<li><p>第一轮先将栈里的任务分别放入</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏任务队列[setTimeout1]，微任务队列[Promise1]</p>
</li>
<li><p>清空微任务，此时执行promise1打印Promise1，将产生的宏任务压入宏任务队列，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏[setTimeout1,setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout1执行，打印setTimeout1，创建微任务队列，将promise2压入队列，此时宏任务setTimeout1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[promise2]</p>
</li>
<li><p>宏任务执行完毕需要清空微任务队列，拿出promise2执行，打印promise2，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout2执行，打印setTimeout2，此时宏任务微任务队列都是空，本轮渲染结束</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[]，微[]</p>
</li>
</ol>
<h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><pre><code class="js">    console.log(1);
    async function async() {
      console.log(2);
      await console.log(3);
      console.log(4)
    }
    setTimeout(() =&gt; {
      console.log(5);
    }, 0);
    const promise = new Promise((resolve, reject) =&gt; {
      console.log(6);
      resolve(7)
    })
    promise.then(res =&gt; {
      console.log(res)
    })
    async();
    console.log(8);
</code></pre>
<p>上述代码执行结果是：16238745</p>
<p>原因是：</p>
<ol>
<li><p>解释async…await</p>
<ol>
<li><p>async 执行后返回的是一个promise</p>
</li>
<li><p>await console.log(3); =&gt; return Promise.resolve(console.log(3)).then(()=&gt;console.log(4))</p>
<p>相当于让await后面的代码立即执行，将await下面的代码用then的形式添加到微任务队列</p>
</li>
</ol>
</li>
<li><p>首先肯定打印1，继续往下走async函数声明了未调用先不用管，setTime进入宏任务队列，promise进入微任务队列，then不用管，async函数调用，将返回函数作为promise2压入微任务队列，console暂时执行不到</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise1，promise2]</p>
</li>
<li><p>先执行promise1，打印6，resolve将7传入then中，把7then压入微任务队列，promise1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise2,7then]</p>
</li>
<li><p>执行promise2，打印2，打印3，将4then压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[7then,4then]</p>
</li>
<li><p>此时async函数执行完毕。console.log(8)执行打印8</p>
</li>
<li><p>继续执行微任务7then，打印7</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[4then]</p>
</li>
<li><p>继续执行微任务4then，打印4</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[]</p>
</li>
<li><p>此时微任务队列清空，开始执行宏任务，打印5</p>
</li>
<li><p>此时宏任务，微任务全部清空，程序结束</p>
</li>
</ol>
<h3 id="案例6"><a href="#案例6" class="headerlink" title="案例6"></a>案例6</h3><pre><code class="js">    Promise.resolve().then(() =&gt; {
      console.log(0);
      return Promise.resolve(4);
    }).then((res) =&gt; {
      console.log(res)
    })
    Promise.resolve().then(() =&gt; {
      console.log(1);
    }).then(() =&gt; {
      console.log(2);
    }).then(() =&gt; {
      console.log(3);
    }).then(() =&gt; {
      console.log(5);
    })
</code></pre>
<p>上述打印结果为0,1,2,3,4,5</p>
<p>原因是</p>
<ol>
<li><p>解释return一个promise，不会立刻处理，而是会将这个promise放入异步代码中</p>
</li>
<li><p>将then0和then1放入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then0，then1]</p>
</li>
<li><p>执行then0,打印02，返回一个Promise.resolve，会执行自己的then方法</p>
</li>
<li><p>执行then1打印，将then2压入栈中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then2]</p>
</li>
<li><p>由于return一个promise的特性，then会延迟执行</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then2，then]</p>
</li>
<li><p>执行then2打印then2，将then3压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then3]</p>
</li>
<li><p>执行then，将4传入then中，将then4压入队列</p>
</li>
<li><p>执行then3，打印3，将then5压入队列中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then4，then5]</p>
</li>
<li><p>依次执行，打印4,5，程序结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>EventLoop</category>
      </categories>
      <tags>
        <tag>EventLoop</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Js数据类型</title>
    <url>/2021/08/03/javascript-js-shu-ju-lei-xing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、为什么要区分不同的数据类型"><a href="#一、为什么要区分不同的数据类型" class="headerlink" title="一、为什么要区分不同的数据类型"></a>一、为什么要区分不同的数据类型</h1><p>在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。</p>
<h1 id="二、JS中一共有七种数据类型"><a href="#二、JS中一共有七种数据类型" class="headerlink" title="二、JS中一共有七种数据类型"></a>二、JS中一共有七种数据类型</h1><ul>
<li><strong>基本数据类型（值类型）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义、Symbol(ES6新增)。</li>
<li><strong>引用数据类型（引用类型）</strong>：Object 对象。</li>
</ul>
<p>注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那六种基本数据类型之外，其他的，都称之为 Object类型。</p>
<h3 id="1-查看数据类型的方式typeof"><a href="#1-查看数据类型的方式typeof" class="headerlink" title="1.查看数据类型的方式typeof()"></a>1.查看数据类型的方式typeof()</h3><ul>
<li>typeof()返回的是一个字符串类型</li>
<li>typeof()检测的特殊值<ul>
<li>基本数据类型null返回的是object —&gt;&nbsp; js历史遗留的bug</li>
<li>复杂数据类型function返回的是functiong —&gt; 函数是js中的一等公民。有双重身份，即是obj又是function<pre><code class="javascript">function foo() { }
console.log(typeof 10);//number
//typeof 返回的是一个字符串类型
console.log(typeof (typeof 10));//string
console.log(typeof 'hello');//string
console.log(typeof false);//boolean
console.log(typeof undefined);//undefined
console.log(typeof null);//object
console.log(typeof foo);//function
console.log(typeof []);//object
console.log(typeof {});//object
// typeof不仅可以检测单个值，加小括号可以检测表达式
console.log(typeof (10 + '10'));//string
</code></pre>
<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof()"></a>2.instanceof()</h3></li>
</ul>
</li>
</ul>
<p><strong>运算符</strong>用于检测构造函数的&nbsp;<code>prototype</code>&nbsp;属性是否出现在某个实例对象的原型链<br>函数既是function又是object…</p>
<pre><code class="javascript">    console.log(foo instanceof Function);//true
    console.log(foo instanceof Object);//true
</code></pre>
<pre><code class="javascript">    var a = '10'
    let b = new String()
    console.log('a' instanceof String);//false
    console.log(b instanceof String);//true
    console.log([] instanceof Array);//true
    console.log({} instanceof Array);//false
    console.log({} instanceof Object);//true
</code></pre>
<h1 id="三、String类型"><a href="#三、String类型" class="headerlink" title="三、String类型"></a>三、String类型</h1><h2 id="1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"><a href="#1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。" class="headerlink" title="1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"></a>1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。</h2><h2 id="2-String中的转义字符"><a href="#2-String中的转义字符" class="headerlink" title="2.String中的转义字符"></a>2.String中的转义字符</h2><p>和css中的特殊字符类似</p>
<ul>
<li><code>\"</code> 表示 <code>"</code></li>
<li><code>\'</code> 表示 <code>'</code></li>
<li><code>\\</code> 表示<code>\</code></li>
<li><code>\r</code> 表示回车</li>
<li><code>\n</code> 表示换行。n 的意思是 newline。</li>
<li><code>\t</code> 表示缩进。t 的意思是 tab。</li>
<li><code>\b</code> 表示空格。b 的意思是 blank。</li>
</ul>
<h2 id="3-获取字符串的长度"><a href="#3-获取字符串的长度" class="headerlink" title="3.获取字符串的长度"></a>3.获取字符串的长度</h2><p>String.length</p>
<pre><code>  &lt;script&gt;
    var str1 = '1；23';
    var str2 = '小艾 同学';
    var str3 = 'ab,cd';

    // 注意：
    // 中文、英文字母、数字都占一个字符
    // 中英文标点符号都占一个字符
    // 空格也占一个字符
    console.log(str1.length);//4
    console.log(str2.length);//5
    console.log(str3.length);//5
  &lt;/script&gt;
</code></pre>
<h2 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4.字符串拼接"></a>4.字符串拼接</h2><p>当<code>+</code>号的连接的是一个字符串，就会变成连接符。</p>
<pre><code class="javascript">字符串 + 任意数据类型 = 拼接之后的新字符串;
</code></pre>
<p>字符串和任何数据类型拼接，都会将拼接内容隐式转为字符串，并输出一个字符串。</p>
<pre><code class="javascript">    console.log(10 + null);//10
    console.log(10 + true);//11

    //当加号的左侧或右侧为一个字符串类型时，就会作为连接符
    //将任何数据类型都转为字符串，在返回拼接后的新字符串
    console.log('10' + null);//10null
    console.log(true + '10');//true10
        //复杂数据类型也会隐式转换为字符串哦
    console.log('小艾同学' + {});//小艾同学[object Object]
</code></pre>
<p>变量与字符串拼接为了不让转为字符串，通常采用引引加加</p>
<pre><code class="javascript">    // 字符串与变量拼接
    let a = 100;
    // 要想在字符串中插入一个变量，就不能让该变量暴露在引号中
    //可以用引引加加口诀， '+a+'
    console.log('小艾同学a分');//小艾同学a分
    console.log('小艾同学' + a + '分');//小艾同学100分
</code></pre>
<p>凡是存在隐式转换的地方，都不应该广泛使用，所以字符串拼接是，尽量不用加号隐式转换，推荐使用<code>${}</code></p>
<pre><code class="javascript">    console.log(`小${a}艾同${b}学`);
</code></pre>
<h2 id="5-ES6字符串遍历"><a href="#5-ES6字符串遍历" class="headerlink" title="5.ES6字符串遍历"></a>5.ES6字符串遍历</h2><pre><code class="javascript">    var str= '123456';
    for(let char of str){
      console.log("字符："+char);
    // 字符：1
    // 字符：2
    // 字符：3
    // 字符：4
    // 字符：5
    // 字符：6
    }
</code></pre>
<h1 id="四、Number类型"><a href="#四、Number类型" class="headerlink" title="四、Number类型"></a>四、Number类型</h1><h2 id="1-所有的数字都是Number类型"><a href="#1-所有的数字都是Number类型" class="headerlink" title="1.所有的数字都是Number类型"></a>1.所有的数字都是Number类型</h2><p>Js中不存在int,folat类型，正负数，整数，小数都是Number类型</p>
<pre><code class="javascript">    &lt;script&gt;
        var num = 0x9;//前面加0x就是十六进制
        var num1 = 07;//前面加0代表八进制
        var num2 = 2e8;//e表示科学计数法次幂

        console.log(num);//9
        console.log(num1);//7
        console.log(num2);//1.7976931348623157e+308
        // Number最大范围
        console.log(Number.MAX_VALUE);//1.7976931348623157e+308
        // Number最小范围
        console.log(Number.MIN_VALUE);//5e-324
        // 无穷大Infinity
        console.log(Number.MAX_VALUE * 2);//Infinity
        // 无穷小-Infinity
        console.log(-Number.MAX_VALUE * 2);//-Infinity
    &lt;/script&gt;
</code></pre>
<blockquote>
<p>补充进制转换（以100为例）<br>几进制就是逢几进一→十进制逢十进一</p>
</blockquote>
<h4 id="各进制转十进制，就是-几进制的位数-1次幂…"><a href="#各进制转十进制，就是-几进制的位数-1次幂…" class="headerlink" title="各进制转十进制，就是*几进制的位数-1次幂…"></a>各进制转十进制，就是*几进制的位数-1次幂…</h4><ul>
<li>十进制转十进制</li>
</ul>
<p>100 = 1_10^2 + 0_10^1 + 0*10^0 = 100</p>
<ul>
<li>二进制转十进制</li>
</ul>
<p>100 = 1_2^2 + 0_2^1 + 0*2^0 = 4</p>
<ul>
<li>八进制转十进制(以0开头就是八进制)</li>
</ul>
<p>0100= 1_8^2 + 0_8^1 + 0*8^0 = 64</p>
<ul>
<li>十六进制转十进制(以0x开头就是十六进制)</li>
</ul>
<p>0x100 = 1_16^2 + 0_16^1 + 0*16^0 = 256</p>
<h4 id="十进制转各进制就是-该进制的余数倒过来…"><a href="#十进制转各进制就是-该进制的余数倒过来…" class="headerlink" title="十进制转各进制就是/该进制的余数倒过来…"></a>十进制转各进制就是/该进制的余数倒过来…</h4><ul>
<li>十进制转二进制</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661499-a409744a-df42-4062-9025-1bb38e04c68e.png#align=left&amp;display=inline&amp;height=667&amp;margin=%5Bobject%20Object%5D&amp;originHeight=667&amp;originWidth=859&amp;size=0&amp;status=done&amp;style=none&amp;width=859"></p>
<ul>
<li>别的进制同理</li>
</ul>
<h2 id="2-Number类型的特殊值—NaN"><a href="#2-Number类型的特殊值—NaN" class="headerlink" title="2.Number类型的特殊值—NaN"></a>2.Number类型的特殊值—NaN</h2><p>Not a Numberde 的简写，是Number类型</p>
<p>特点：NaN不等于任何东西，包括他自己</p>
<pre><code class="javascript">  &lt;script&gt;
    // NaN不等于任何
    console.log(NaN == NaN);//false
    console.log(NaN =-= NaN);//false
    // 返回NaN的情况
    // 1.字符串计算
    console.log('a' - 1);//NaN

    // 2.类型转换时开头有无法转换成数字的值
    // 不能转换的一定要在开头
    console.log(parseFloat('1a'));//1
    console.log(parseFloat('a1'));//NaN
    console.log(parseFloat());//NaN
    console.log(parseInt('x'));//NaN
    console.log(Number('x'));//NaN
  &lt;/script&gt;
</code></pre>
<h3 id="2-1-isNaN（）函数"><a href="#2-1-isNaN（）函数" class="headerlink" title="2.1 isNaN（）函数"></a>2.1 isNaN（）函数</h3><p>用来确定一个值是否为NaN</p>
<pre><code class="javascript">    // isNaN()，判断传入的参数是否为NaN
    console.log(isNaN(NaN)); //true

    // 只有0/0会返回true，其他任何数值都是false
    console.log(isNaN(0 / 0)); //true
    console.log(isNaN(0 / 1)); //false
    console.log(isNaN(1 / 0)); //false
    console.log(isNaN(10)); //false（ 10 是一个数值）

    //能转为数字的别的类型也会返回false,无法转换的返回true
    console.log(isNaN("10")); //false（可以被转换成数值 10）
    console.log(isNaN("a10")); //true（可以被转换成数值 10）
    console.log(isNaN("hello")); //true（不能转换成数值）
    console.log(isNaN(true)); //false（可以被转换成数值 1）
</code></pre>
<h2 id="3-0-1-0-2不等于0-3"><a href="#3-0-1-0-2不等于0-3" class="headerlink" title="3.0.1+0.2不等于0.3"></a>3.0.1+0.2不等于0.3</h2><p>失精<br>参考：<a href="https://juejin.im/post/5b90e00e6fb9a05cf9080dff">https://juejin.im/post/5b90e00e6fb9a05cf9080dff</a></p>
<pre><code class="javascript">       var a = 0.1 + 0.2;
    console.log(a);  //0.30000000000000004
</code></pre>
<h1 id="五、Boolean类型"><a href="#五、Boolean类型" class="headerlink" title="五、Boolean类型"></a>五、Boolean类型</h1><p>只有两个值：true和false<br>在输出Boolean类型时，不能加引号哦。</p>
<pre><code class="javascript">    console.log(false);//false ---&gt; 布尔类型
    console.log('false');//false ---&gt; 字符串类型
</code></pre>
<h1 id="六、Null"><a href="#六、Null" class="headerlink" title="六、Null"></a>六、Null</h1><p>null表示”空对象”，即该处不应该有值，用来表示空指针引用。<br>typeof Null 返回的是object</p>
<pre><code class="javascript">    console.log(typeof null); // object
</code></pre>
<h1 id="七、undefined"><a href="#七、undefined" class="headerlink" title="七、undefined"></a>七、undefined</h1><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<pre><code>    &lt;script&gt;
      // 变量声明了未赋值，返回的即使undefined
      var a;
      console.log(a);//undefined
      
      // 检测undefined类型
      console.log(typeof undefined);//undefined
    &lt;/script&gt;
</code></pre>
<h1 id="八、比较Null和undefined"><a href="#八、比较Null和undefined" class="headerlink" title="八、比较Null和undefined"></a>八、比较Null和undefined</h1><p>简单理解，以糖葫芦为例，本来应该是一串糖葫芦，undefined相当于就剩一个竹签了，null就是连签都没有…<br>推荐文章<br><a href="https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<pre><code>    // null与undefined
    console.log(null == undefined);//ture
    console.log(null === undefined);//false

    // 计算
    console.log(1 + null);//1
    console.log(1 + undefined);//NaN
</code></pre>
<h1 id="九、基本数据类型和引用数据类型区别"><a href="#九、基本数据类型和引用数据类型区别" class="headerlink" title="九、基本数据类型和引用数据类型区别"></a>九、基本数据类型和引用数据类型区别</h1><h2 id="1-储存位置不同"><a href="#1-储存位置不同" class="headerlink" title="1.储存位置不同"></a>1.储存位置不同</h2><ul>
<li>基本数据类型存放在栈中，数据大小确定，内存空间大小可以分配，直接按值存放的，所以可以直接按值访问。</li>
<li>引用数据类型存放在堆内存中，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址)，这个指针指向堆内存。在栈内存中保存的是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</li>
</ul>
<blockquote>
<p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。<br>堆：先进先出<br>栈：先进后出<br>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661556-a22ecd2b-19b9-49fc-a03e-a3961bdc15a0.png#align=left&amp;display=inline&amp;height=954&amp;margin=%5Bobject%20Object%5D&amp;originHeight=954&amp;originWidth=1713&amp;size=0&amp;status=done&amp;style=none&amp;width=1713"></p>
</blockquote>
<h2 id="2-复制操作"><a href="#2-复制操作" class="headerlink" title="2.复制操作"></a>2.复制操作</h2><ul>
<li>基本数据类型从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上，改变源数据不会影响到新的变量（互不干涉）</li>
<li>引用类型复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此改变其中的一个，将影响另一个；</li>
</ul>
<pre><code>  &lt;script&gt;
    var a = 10;
    var b = a;
    b = 20;

    var arr = ['小','艾','同学'];
    var arr1 = arr;
    arr1.push('666');


    // 基本数据类型复制后，改变复制的变量，原值不受影响
    console.log(a);//10
    console.log(b );//20

    // 引用类型复制后，改变复制的变量，原值也会跟着改变
    console.log(arr);//['小','艾','同学','666']
    console.log(arr1);//['小','艾','同学','666']
  &lt;/script&gt;
</code></pre>
<p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661598-aba71641-d1c0-4a7a-9606-cd5f1169e7ad.png#align=left&amp;display=inline&amp;height=1214&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1214&amp;originWidth=2880&amp;size=0&amp;status=done&amp;style=none&amp;width=2880"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBash折腾</title>
    <url>/2021/09/17/git-gitbash-mei-hua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitBash折腾"><a href="#GitBash折腾" class="headerlink" title="GitBash折腾"></a>GitBash折腾</h1><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1626950602136-1626950602129.png#height=267&amp;id=lW9vM&amp;originHeight=267&amp;originWidth=788&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=788"></p>
<h2 id="1-设置快捷键，总是管理员启动"><a href="#1-设置快捷键，总是管理员启动" class="headerlink" title="1.设置快捷键，总是管理员启动"></a>1.设置快捷键，总是管理员启动</h2><p>1.搜索<code>git bash</code>，打开文件位置<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1626950687292-1626950687287.png#height=632&amp;id=zYzLg&amp;originHeight=632&amp;originWidth=783&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=783"></p>
<h2 id="2-点击属性-gt-点击快捷键-gt-点击高级-gt-重启"><a href="#2-点击属性-gt-点击快捷键-gt-点击高级-gt-重启" class="headerlink" title="2.点击属性 -> 点击快捷键 -> 点击高级 -> 重启"></a>2.点击<code>属性</code> -&gt; 点击<code>快捷键</code> -&gt; 点击<code>高级</code> -&gt; 重启</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1626950832663-1626950832638.png#height=642&amp;id=NzpqV&amp;originHeight=642&amp;originWidth=980&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=980"></p>
<h2 id="3-搜索服务-gt-打开"><a href="#3-搜索服务-gt-打开" class="headerlink" title="3.搜索服务 -> 打开"></a>3.搜索<code>服务</code> -&gt; 打开</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1626950892027-1626950892026.png#height=638&amp;id=TVFAs&amp;originHeight=638&amp;originWidth=776&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=776"></p>
<h2 id="4-找到SysMain-gt-右键属性-gt-选中禁用-gt-重启"><a href="#4-找到SysMain-gt-右键属性-gt-选中禁用-gt-重启" class="headerlink" title="4.找到SysMain -> 右键属性 -> 选中禁用 -> 重启"></a>4.找到<code>SysMain</code> -&gt; 右键<code>属性</code> -&gt; 选中<code>禁用</code> -&gt; 重启</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1626950953421-1626950953420.png#height=648&amp;id=jFDGc&amp;originHeight=648&amp;originWidth=606&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=606"></p>
<h2 id="5-git-bash执行code-etc-profile-d-git-prompt-sh"><a href="#5-git-bash执行code-etc-profile-d-git-prompt-sh" class="headerlink" title="5.git bash执行code /etc/profile.d/git-prompt.sh"></a>5.<code>git bash</code>执行<code>code /etc/profile.d/git-prompt.sh</code></h2><p>此时vscode会打开<code>git-prompt.sh</code>文件<br>将下列代码粘贴上去</p>
<pre><code class="javascript">if test -f /etc/profile.d/git-sdk.sh
then
 TITLEPREFIX=SDK-${MSYSTEM#MINGW}
else
 TITLEPREFIX=$MSYSTEM
fi

if test -f ~/.config/git/git-prompt.sh
then
 . ~/.config/git/git-prompt.sh
else
 PS1='\[\033]0;Bash\007\]'      # 窗口标题
 PS1="$PS1"'\n'                 # 换行
 PS1="$PS1"'\[\033[36;1m\]'     # 指下一行的颜色蓝色
  # PS1="$PS1"'\u@\h '       # 我直接写成字符串了，用户名可以自己定义
  PS1="$PS1"'loveZero '          # 用户名
 PS1="$PS1"'\[\033[35;1m\]'     # 指下一行的颜色紫色
 PS1="$PS1"'➜  '               # unicode 字符，右箭头
 PS1="$PS1"'\[\033[33;1m\]'     # 指下一行的颜色黄色
 PS1="$PS1"'\W'                 # 当前目录
 PS1="$PS1"'\[\033[32;1m\]'     # 指下一行的颜色绿色
 PS1="$PS1"' [`date "+%Y-%m-%d %H:%M:%S"`]'  # 时间
 if test -z "$WINELOADERNOEXEC"
 then
  GIT_EXEC_PATH="$(git --exec-path 2&gt;/dev/null)"
  COMPLETION_PATH="${GIT_EXEC_PATH%/libexec/git-core}"
  COMPLETION_PATH="${COMPLETION_PATH%/lib/git-core}"
  COMPLETION_PATH="$COMPLETION_PATH/share/git/completion"
  if test -f "$COMPLETION_PATH/git-prompt.sh"
  then
   . "$COMPLETION_PATH/git-completion.bash"
   . "$COMPLETION_PATH/git-prompt.sh"
   PS1="$PS1"'\[\033[31m\]'   # 指下一行的颜色红色
   PS1="$PS1"'`__git_ps1`'    # 分支
  fi
 fi
 PS1="$PS1"'\[\033[35m\]'     # 指下一行的颜色紫色
 PS1="$PS1"'\n'               # new line
 PS1="$PS1"'❥ '
fi

MSYS2_PS1="$PS1"               # for detection by MSYS2 SDK's bash.basrc
 
# Evaluate all user-specific Bash completion scripts (if any)
if test -z "$WINELOADERNOEXEC"
then
 for c in "$HOME"/bash_completion.d/*.bash
 do
  # Handle absence of any scripts (or the folder) gracefully
  test ! -f "$c" ||
  . "$c"
 done
fi

</code></pre>
<h2 id="6-修改主题"><a href="#6-修改主题" class="headerlink" title="6.修改主题"></a>6.修改主题</h2><p>运行<code>$ code ~/.minttyrc</code>,粘贴代码</p>
<pre><code class="javascript">Font=DejaVu Sans Mono for Powerline
FontHeight=14
Transparency=low
FontSmoothing=default
Locale=C
Charset=UTF-8
Columns=88
Rows=26
OpaqueWhenFocused=no
Scrollbar=none
Language=zh_CN

ForegroundColour=131,148,150
BackgroundColour=0,43,54
CursorColour=220,130,71

BoldBlack=128,128,128
Red=255,64,40
BoldRed=255,128,64
Green=64,200,64
BoldGreen=64,255,64
Yellow=190,190,0
BoldYellow=255,255,64
Blue=0,128,255
BoldBlue=128,160,255
Magenta=211,54,130
BoldMagenta=255,128,255
Cyan=64,190,190
BoldCyan=128,255,255
White=200,200,200
BoldWhite=255,255,255

BellTaskbar=no
Term=xterm
FontWeight=400
FontIsBold=no
</code></pre>
<h3 id="6-2扩展"><a href="#6-2扩展" class="headerlink" title="6.2扩展"></a>6.2扩展</h3><p>这里主题已经修改好了<br>可以给终端添加扩展功能，更高效</p>
<h4 id="1-使用-alias-强化-Git-Bash"><a href="#1-使用-alias-强化-Git-Bash" class="headerlink" title="1.使用 alias 强化 Git Bash"></a>1.使用 alias 强化 Git Bash</h4><p>执行<code>$ code ~/.bash_profile</code><br>粘贴代码:<br>前面是快捷键，后面是对应的操作（例：git status 快捷键为 gs）</p>
<pre><code class="javascript">alias bashalias='code ~/.bash_profile'
alias bashcolor='code ~/.minttyrc'
alias bashconfig='code /etc/profile.d/git-prompt.sh'
alias gitconfig='code ~/.gitconfig'

alias .='cd ~'
alias ..='cd ..'
alias ...='cd ../..'
alias e='exit'
alias cls='clear'

alias i='git init' # 初始化git
# 仓库
alias pull='git pull' # 拉取最新代码
alias origin='git pull origin' # 从远程分支拉取最新代码
alias a='git add .' # 添加所有改动到暂存
alias c='git commit -m' # 将暂存区提交更新
alias ac='git commit -a -m' # 将暂存区提交更新
alias push='git push' # 推送到远程仓库
alias pf="git push -f" # 强制推送
alias feat='featFun() { git commit -m "feat: $1"; }; featFun' # commit feat
alias fix='fixFun() { git commit -m "fix: $1"; }; fixFun' # commit fix 
alias refactor='refactorFun() { git commit -m "refactor: $1"; }; refactorFun' # commit refactor
alias style='styleFun() { git commit -m "style: $1"; }; styleFun' # commit style
alias g='auto() { git add .; git commit -m "$1"; git push; }; auto' # 自动push
alias cp='cpFun() { git commit -m "$1"; git push; }; cpFun' # 自动commit push

# 查看
alias s='git status' # 查看状态
alias d='git diff' # 对比改动
alias gs='git stash' # 暂时将未提交的变化移除
alias gsp='git stash pop' # 取出暂存

# 分支
alias gc="git checkout" # 切换分支
alias gcb="git checkout -b" # 创建并切换到新分支
alias bd="git branch -d" # 删除分支
alias merge="git merge" # 合并分支 
alias ma="git merge --abort" # 合并分支 


# 撤销
alias soft="git reset --soft HEAD^" # 撤销commit
alias reset='backHard() { git reset --hard $1; git push -f;}; backHard' # 回退任意版本
alias back='git reset --hard HEAD^ &amp;&amp; git push -f' # 回退上个

# 修改
alias xiu="git commit --amend" # 修改commit信息
alias log="git log --pretty=format:'%h - %an, %ar : %s'" # 查看版本

alias host='code /c/Windows/System32/drivers/etc/hosts'

</code></pre>
<h2 id="7-vscode中使用终端"><a href="#7-vscode中使用终端" class="headerlink" title="7.vscode中使用终端"></a>7.vscode中使用终端</h2><pre><code class="javascript">{
  "terminal.integrated.shell.windows": "git-bash绝对路径",
  "terminal.integrated.shellArgs.windows": ["--login", "-i"],
}
</code></pre>
<h2 id="8-配置shh"><a href="#8-配置shh" class="headerlink" title="8.配置shh"></a>8.配置shh</h2><p>1.删除.shh下的所有文件<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627105522641-7f4044d2-c32e-42d8-ac4b-2c32995c7371.png#height=594&amp;id=u6lnW&amp;originHeight=594&amp;originWidth=688&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=688"><br>2.git命令</p>
<pre><code class="javascript">git config --global username 'loveZero'
git config --global user.email '1120877019@qq.com'
git config --list
ssh-keygen -t rsa -C "1120877019@qq.com"
一路按回车
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627106419073-df9e6589-173e-4cf2-9a45-8408c846e5c6.png#height=773&amp;id=ynhBM&amp;originHeight=773&amp;originWidth=772&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=772"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627106459086-ac033fbb-6e82-4b06-828f-097015beb3c3.png#height=532&amp;id=TpTsO&amp;originHeight=532&amp;originWidth=784&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=784"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627106479167-9dd972a9-f4ee-471a-a14d-c8b7443147b1.png#height=193&amp;id=EzIdP&amp;originHeight=193&amp;originWidth=766&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=766"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627106517411-5d58f873-849f-4720-9fb3-4ed7e56ddd86.png#height=693&amp;id=aFGpv&amp;originHeight=693&amp;originWidth=1292&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=1292"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1307005/1627106559569-5b1dddb6-25bc-410b-9ab3-bb7bd379966a.png#height=559&amp;id=WAsFW&amp;originHeight=559&amp;originWidth=1018&amp;originalType=binary&amp;ratio=1&amp;size=0&amp;status=done&amp;style=none&amp;width=1018"></p>
<h2 id="本地仓库如何同时推送到gitee和github"><a href="#本地仓库如何同时推送到gitee和github" class="headerlink" title="本地仓库如何同时推送到gitee和github"></a>本地仓库如何同时推送到gitee和github</h2><pre><code class="javascript">git remote add origin github链接
git remote set-url --add origin gitee链接
</code></pre>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2021/09/08/javascript-han-shu-shi-bian-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-函数式编程优势"><a href="#1-函数式编程优势" class="headerlink" title="1.函数式编程优势"></a>1.函数式编程优势</h2><ul>
<li>更少的时间</li>
<li>更少的 BUG</li>
<li>更好的测试性</li>
<li>更方便调试</li>
<li>适合并发执行</li>
<li>更高的复用性</li>
<li>支持 tree-shaking</li>
<li>React 和 vue3 大量使用函数式编程</li>
</ul>
<h2 id="2-什么是函数式编程"><a href="#2-什么是函数式编程" class="headerlink" title="2.什么是函数式编程"></a>2.什么是函数式编程</h2><p>函数式编程是一种编程范式</p>
<ul>
<li>面向过程式编程</li>
</ul>
<pre><code class="js">// 从上到下一行行执行，一行行写
let a = 1
let b = 2
let res1 = a + b
console.log(res1)
</code></pre>
<ul>
<li>面向对象式编程</li>
</ul>
<pre><code class="JavaScript">class Calculaor {
  add (a, b) {
    return a + b
  }
}
let c = new Calculaor()
console.log(c.add(1, 2))
</code></pre>
<ul>
<li>函数式编程</li>
</ul>
<pre><code class="JavaScript">// 函数其实是数学上的概念 y = f(x)
function addNum (a, b) {
  return a + b
}
let res2 = add(1, 2)
console.log(res2)
</code></pre>
<h2 id="3-First-class-Function-头等函数）"><a href="#3-First-class-Function-头等函数）" class="headerlink" title="3. First-class Function(头等函数）"></a>3. First-class Function(头等函数）</h2><p>函数是头等函数</p>
<ul>
<li>函数可以赋值给变量</li>
<li>函数可以作为参数</li>
<li>函数可以作为返回值</li>
</ul>
<pre><code class="js">function add (a, b) {
  return a + b
}

// 可以给变量赋值
let add1 = add

// 可以作为参数
function exec (fn, a, b) {
  return fn(a, b)
}

exec(add, 1, 2)

// 可以作为返回值
function exec2 (fn) {
  return function (a, b) {
    return fn(a, b)
  }
}
exec2(add)(1, 2)
</code></pre>
<p>作为参数和返回值的函数被称为高阶函数，高阶函数是函数式编程的基础</p>
<h2 id="4-闭包（-closure"><a href="#4-闭包（-closure" class="headerlink" title="4.闭包（ closure)"></a>4.闭包（ closure)</h2><ul>
<li><p>一个函数和对其周围状态的引用捆绑在一起这样的组合就是闭包</p>
</li>
<li><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域的变量</p>
</li>
</ul>
<pre><code class="JavaScript">function init () {
  let name = 'hello' // name 是一个被 init 创建的局部变量
  // displayName() 是内部函数，一个闭包
  function displayName () {
    console.log(name) // 使用了父函数中声明的变量
  }
  displayName()
}
init()
</code></pre>
<h2 id="5-纯函数"><a href="#5-纯函数" class="headerlink" title="5.纯函数"></a>5.纯函数</h2><h3 id="5-1-什么是纯函数"><a href="#5-1-什么是纯函数" class="headerlink" title="5.1 什么是纯函数"></a>5.1 什么是纯函数</h3><ul>
<li>函数的返回结果只依赖于它的参数，相同的輸入始终得到相同的输出</li>
<li>函数执行过程里面没有副作用（一个函数执行过程对产生了外部可观察的变化那么就可以说这个函数是有副作用）</li>
</ul>
<pre><code class="JavaScript">// 纯函数
function add (a, b) {
  return a + b
}

// 非纯函数
let c = 1
let d = 2
function add2 (a, b) {
  // 修改了外部变量
  d++
  // 返回值依赖了外部变量
  return a + b + c
}
add2()
console.log(d)
</code></pre>
<h3 id="5-2-优点"><a href="#5-2-优点" class="headerlink" title="5.2 优点"></a>5.2 优点</h3><h4 id="5-2-1-可缓存"><a href="#5-2-1-可缓存" class="headerlink" title="5.2.1 可缓存"></a>5.2.1 可缓存</h4><p>创建一个会缓存 func 结果的函数。<br>func 在调用时 this 会绑定在缓存函数上</p>
<pre><code class="js">function add (a, b) {
  console.log('执行了')
  return a + b
}
// 相同参数调用3次，函数会执行3次
console.log(add(1, 2))
console.log(add(1, 2))
console.log(add(1, 2))

/*打印结果
  执行了
  3
  执行了
  3
  执行了
  3
 */
// 缓存
function memoize (fn) {
  // 深拷贝参数
  const resolver = (...args) =&gt; JSON.stringify(args)
  // 定义缓存对象，存放参数和结果的对应关系
  let cache = {}
  return (...args) =&gt; {
    // 将传入的参数作为key
    const key = resolver(...args)
    // 如果cache中对应参数已经有值了，就直接返回值，否则就将函数调用该值的结果存入缓存中
    return cache[key] ? cache[key] : (cache[key] = fn(...args))
  }
}
// 缓存add函数
const memoizeAdd = memoize(add)
console.log(memoizeAdd(1, 2))
console.log(memoizeAdd(1, 2))
console.log(memoizeAdd(1, 2))
/*打印结果
  执行了
  3
  3
  3
 */
</code></pre>
<h4 id="5-2-1-可测试"><a href="#5-2-1-可测试" class="headerlink" title="5.2.1 可测试"></a>5.2.1 可测试</h4><p>只需简单地给函数一个输入，然后断言输出就好了。不依赖于上下文环境</p>
<pre><code class="JavaScript">function add (a, b) {
  return a + b
}
test('测试1+1', () =&gt; {
  expect(add(1, 2)).toBe(3)
})
</code></pre>
<h2 id="6-柯里化"><a href="#6-柯里化" class="headerlink" title="6.柯里化"></a>6.柯里化</h2><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<pre><code class="JavaScript">function add (a, b, c) {
  return a + b + c
}
// 柯里化函数
function curry (fn) {
  // 函数形参个数
  let argsLength = fn.length
  let curried = (...args) =&gt; {
    // 如果传入的参数小于形参的个数
    if (args.length &lt; argsLength) {
      // 将传入的参数和参数后的第一个参数作为参数，递归调用curried
      return (...rest) =&gt; curried(...args, ...rest)
    }
    // 如果传入的参数不小于形参的个数，就将所有参数传入返回函数调用值
    return fn(...args)
  }
  return curried
}
let curriedAdd = curry(add)
console.log(curriedAdd(1)(2)(3))
</code></pre>
<h2 id="7-组合"><a href="#7-组合" class="headerlink" title="7.组合"></a>7.组合</h2><p>如果一个函数要经过多个函数处理才能得到最终值，这个是可以把中间过程的函数合并成一个函数。</p>
<ul>
<li><p>函数就像是数据的管道，函数组合就是将这些管道连接起来，让数据穿过多个管道形成最终结果。</p>
</li>
<li><p>函数组合默认是从右到左默认运行的。</p>
</li>
<li><p>flow 创建一个函数每一个连续调用，传入的参数都是前一个函数返回的结果</p>
</li>
<li><p>f1owRight 类似 f1ow,除了它调用函数的顺序是从右往左的。</p>
</li>
<li><p>lodashjs 是一个一致性、模块化、高性能的 Javascript 实用工具库</p>
</li>
<li><p>lodash/fpl 中的函数数据放在后</p>
</li>
</ul>
<pre><code class="JavaScript">let _ = require('lodash')
let str = 'hello'
function add1 (str) {
  return str + 1
}

function add2 (str) {
  return str + 2
}

function add3 (str) {
  return str + 3
}
// 从左到右
let flowed = _.flow(add1, add2, add3)
// 从右到左
let flowed2 = _.flowRight(add3, add2, add1)
console.log(flowed(str))
console.log(flowed2(str))
</code></pre>
<p>自己实现的</p>
<pre><code class="JavaScript">let str = 'hello'
function add1 (str) {
  return str + 1
}

function add2 (str) {
  return str + 2
}

function add3 (str) {
  return str + 3
}
function add4 (str) {
  return str + 4
}

function flow (...fns) {
  // fns是传入的参数伪数组，如果函数的参数如果是一个，就直接返回
  if (fns.length === 1) {
    return fns[0]
  }

  return fns.reduceRight((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
function flowRight (...fns) {
  // fns是传入的参数伪数组，如果函数的参数如果是一个，就直接返回
  if (fns.length === 1) {
    return fns[0]
  }

  return fns.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
  /*
    第一次执行
    a = add4,b=add3 =&gt; (str) =&gt; add4(add3(str)))
    第二次执行
    a = add4(add3(str))),b = add2 =&gt; add4(add3(add2(str))))
    第二次执行
    a = add4(add3(add2(str)))),b = add1 =&gt;  add4(add3(add2(add1(str)))))
*/

}

// 从左到右
let flowed = flow(add1, add2, add3, add4)
let flowed2 = flowRight(add1, add2, add3, add4)
console.log(flowed(str))
console.log(flowed2(str))
</code></pre>
<h2 id="8-Pointfree"><a href="#8-Pointfree" class="headerlink" title="8. Pointfree"></a>8. Pointfree</h2><p>把数据处理的过程先定义成一种与参数无关的合成运算就叫 Point free</p>
<pre><code class="JavaScript">const { compose } = require('lodash/fp')

// Pointed 有指向的
let money = 500
// 买车
money -= 100
// 买房
money -= 200
console.log(money)

// PointedFree
let money2 = 500

function buyHouse (money) {
  return money - 200
}
function buyCar (money) {
  return money - 100
}
let fn = compose(buyHouse, buyCar)
console.log(fn(money2))
</code></pre>
<h2 id="9-函子"><a href="#9-函子" class="headerlink" title="9.函子"></a>9.函子</h2><ul>
<li><p>可以用来管理值和值的变化过程</p>
</li>
<li><p>异常和异步操作等副作用控制在可控的范国之内</p>
</li>
</ul>
<h3 id="9-1-Context"><a href="#9-1-Context" class="headerlink" title="9.1 Context"></a>9.1 Context</h3><ul>
<li>如果一个对象内部持有一个值那么它就可以称为容器（ container)</li>
</ul>
<pre><code class="js">// 如果一个对象内部能够持有一个值，就可以称为容器
class Container {
  constructor (value) {
    this.value = value
  }
}
let container = new Container(1)
console.log('container: ', container.value)
</code></pre>
<h3 id="9-2-Pointed-Container"><a href="#9-2-Pointed-Container" class="headerlink" title="9.2 Pointed Container"></a>9.2 Pointed Container</h3><ul>
<li>如果它有 of 方法可称为有指向的容器</li>
</ul>
<pre><code class="js">// 如果一个容器里面有of方法，就称它为有指向容器
class PointedContainer {
  constructor (value) {
    this.value = value
  }
  // 函数式编程尽可能不要new，写一个of方法返回想要的实例
  static of (value) {
    return new PointedContainer(value)
  }
}

let pointedContainer = PointedContainer.of(1)
console.log('pointedContainer: ', pointedContainer.value)
</code></pre>
<h3 id="9-3-Functor"><a href="#9-3-Functor" class="headerlink" title="9.3 Functor"></a>9.3 Functor</h3><ul>
<li>如果它有<code>map</code>方法可称为 Functor(子）</li>
<li>函子一会有一个静态的 <code>of</code> 方法，用来生成实例</li>
<li>函子内部会保存一个值 <code>value</code></li>
<li>函子提供 <code>map</code> 方法，接入各种运算函数，从而引发值的变化</li>
</ul>
<pre><code class="js">class Functor {
  constructor (value) {
    this.value = value
  }
  // 函数式编程尽可能不要new，写一个of方法返回想要的实例
  static of (value) {
    return new Functor(value)
  }
  // 接收一个函数，返回值还是一个同类型的对象
  // 可以把老的实例映射为新的实例
  // 提供map方法，接入各种运算逻辑，从而引起值的变化
  map (fn) {
    return new Functor(fn(this.value))
  }
}

let functor = Functor.of(1)
  .map(x =&gt; x + 1)
  .map(x =&gt; x + 2)
  .map(x =&gt; x + 3)
  .map(x =&gt; x + 4)
console.log('functor: ', functor.value)
</code></pre>
<h3 id="9-4-Maybe-函子"><a href="#9-4-Maybe-函子" class="headerlink" title="9.4 Maybe 函子"></a>9.4 Maybe 函子</h3><ul>
<li><p>容器内部的值可能是个空值而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错</p>
</li>
<li><p><code>Maybe</code> 函子可以过滤空值能过滤空值的函子被称为 <code>Maybe</code> 函子</p>
</li>
</ul>
<pre><code class="js">// 可以过滤空值
class Maybe {
  constructor (value) {
    this.value = value
  }
  static of (value) {
    return new Maybe(value)
  }
  map (fn) {
    return this.value ? new Maybe(fn(this.value)) : this
  }
}

let res = Maybe.of(null).map(x =&gt; x.toString())

console.log('Maybe: ', res.value)
</code></pre>
<h3 id="9-5-Either-函子"><a href="#9-5-Either-函子" class="headerlink" title="9.5 Either 函子"></a>9.5 Either 函子</h3><ul>
<li>内部有两个值，左值只会在右值不存在时起作用</li>
</ul>
<pre><code class="js">// 默认值处理,内部有两个值，左值只会在右值不存在时起作用
class Either {
  constructor (left, right) {
    this.left = left
    this.right = right
  }
  static of (left, right) {
    return new Either(left, right)
  }
  map (fn) {
    // 当右边值存在时，用右边的值，当右边值不存在时，用左边的默认值
    return this.right
      ? Either.of(this.left, fn(this.right))
      : Either.of(fn(this.left), this.right)
  }
  get value () {
    return this.right || this.left
  }
}

let res = { name: 'loveZero', age: 18 }
let res2 = { name: 'loveZero', age: null }
let either = Either.of(20, res.age).map(x =&gt; `年龄:${x}`)
let either2 = Either.of(20, res2.age).map(x =&gt; `年龄:${x}`)
console.log('either: ', either.value) // either:  年龄:18
console.log('either: ', either2.value) // either:  年龄:20
</code></pre>
<h3 id="9-6-ap-函子"><a href="#9-6-ap-函子" class="headerlink" title="9.6 ap 函子"></a>9.6 ap 函子</h3><ul>
<li><p>ap(applicative)的函子拥有 ap 方法</p>
</li>
<li><p>ap 方法时以让一个函子内的函数使用另一个函子的值进行计算</p>
</li>
<li><p>ap 方法参数不是一个函数，而是另一个函子</p>
</li>
</ul>
<pre><code class="js">class Ap {
  constructor (value) {
    this.value = value
  }
  static of (value) {
    return new Ap(value)
  }
  ap (functor) {
    return Ap.of(this.value(functor.value))
  }
}
let A = Ap.of(x =&gt; x + 1)
let B = Ap.of(1)
let result = A.ap(B)
console.log(result.value)
</code></pre>
<h3 id="9-7-Monad-函子"><a href="#9-7-Monad-函子" class="headerlink" title="9.7 Monad 函子"></a>9.7 Monad 函子</h3><ul>
<li><p>函子的值也可以是函子，这样会出现多层函子嵌套的情况</p>
</li>
<li><p>Monad(单子不可分割的实体])函子的作用是，总是返回一个单层的函子</p>
</li>
<li><p>它有一个<code>flatMap</code>方法，与<code>map</code>方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层容器，不会出现嵌套的情况</p>
</li>
</ul>
<pre><code class="js">// 函子
class Functor {
  constructor (value) {
    this.value = value
  }
  static of (value) {
    return new Functor(value)
  }
  map (fn) {
    return new Functor(fn(this.value))
  }
}

// 如果fn的返回值是一个函子，那么会 一层一层嵌套
let functor = Functor.of(1)
  .map(x =&gt; Functor.of(x + 1))
  .map(x =&gt; Functor.of(x + 2))
  .map(x =&gt; Functor.of(x + 3))
  .map(x =&gt; Functor.of(x + 4))
console.log('functor: ', functor) // Functor { value: Functor { value: '[object Object]4' } }

// 函子
class Monad {
  constructor (value) {
    this.value = value
  }
  static of (value) {
    return new Monad(value)
  }
  map (fn) {
    return new Monad(fn(this.value))
  }
  join () {
    return this.value
  }
  flatMap (fn) {
    return this.map(fn).join()
  }
}

// 如果fn的返回值是一个函子，那么会 一层一层嵌套
let monad = Monad.of(1)
  .flatMap(x =&gt; Monad.of(x + 1))
  .flatMap(x =&gt; Monad.of(x + 2))
  .flatMap(x =&gt; Monad.of(x + 3))
  .flatMap(x =&gt; Monad.of(x + 4))
console.log('monad: ', monad) // Monad { value: 11 }
</code></pre>
<h3 id="9-8-IO-函子与副作用"><a href="#9-8-IO-函子与副作用" class="headerlink" title="9.8 IO 函子与副作用"></a>9.8 IO 函子与副作用</h3><ul>
<li><p>副作用就是程序和外部世界的交互，比如读取文件或用援口</p>
</li>
<li><p>由于外部世界不可控，包含副作用的逻辑往往不要预测</p>
</li>
<li><p>函数式编程提倡把副作用分离出来，把没有副作用的纯逻辑放在一起远离包含副作用的逻辑，这时就需要<code>IO Monad</code></p>
</li>
<li><p>IO 就是 Input/Output,副作用无非是对外部世界的 Input(读）和 Output(写）</p>
</li>
<li><p>IO 函子通过推退执行的方式来实现对副作用的管理和隔离</p>
</li>
</ul>
<pre><code class="js">let { compose } = require('lodash/fp')

let localStorage = {
  getItem (key) {
    if (key === 'data') {
      return `{"code":"0","userId":"1"}`
    } else if (key === '1') {
      return `{"userId":"1","name":"loveZero"}`
    }
  }
}
// 函子
class IO {
  constructor (value) {
    this.value = value
  }

  map (fn) {
    // compose吧this.value和fn组合成一个新的函数
    return new IO(compose(fn, this.value))
  }
  flatMap (fn) {
    return new IO(compose(x =&gt; x.value(), fn, this.value))
  }
  start (callback) {
    callback(this.value())
  }
}
// 输入有副作用
const readByKey = key =&gt; new IO(() =&gt; localStorage.getItem(key))
// 无副作用
const parseJSON = str =&gt; JSON.parse(str)
// 输出，有副作用
const write = console.log
// IO函子通过推迟执行的方式实现对副作用的管理和隔离
readByKey('data') // 拿到数据‘data’
  .map(parseJSON) // 转json
  .map(x =&gt; x.userId) // 拿到对应的userId
  .flatMap(readByKey) // 取出对应userId=1的字段
  .map(parseJSON) // 转json
  .start(write) // 什么时候调start，什么时候执行
</code></pre>
<h3 id="9-9-task-函子"><a href="#9-9-task-函子" class="headerlink" title="9.9 task 函子"></a>9.9 task 函子</h3><ul>
<li><p>Task 函子通过类似 Promise 的 resolve 的风格来声明一个异步流程</p>
</li>
<li><p>FP 中除了容器（ Container),也可以用上下文（ Context)来称呼包裏了一个值的结构</p>
</li>
<li><p>Promise 的任务是立刻执行的，面 ask 是在调用的时候才开始执行</p>
</li>
</ul>
<pre><code class="js">const Task = execute =&gt; ({
  execute,
  map: fn =&gt; {
    return Task(resolve =&gt; execute(x =&gt; resolve(fn(x))))
  },
  flapMap: fn =&gt; {
    return Task(resolve =&gt; execute(x =&gt; fn(x).execute(resolve)))
  }
})
function get (url) {
  if (url == 'data') {
    return Promise.resolve({ code: '0', userId: '1' })
  } else if (url == '1') {
    return Promise.resolve({ userId: '1', name: 'loveZero' })
  }
}
const request = url =&gt; Task(resolve =&gt; get(url).then(resolve))
request('data')
  .map(x =&gt; x.userId)
  .flapMap(request)
  .map(x =&gt; x.name)
  .execute(data =&gt; console.log(data))
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装配置</title>
    <url>/2021/09/06/mysql-mysql-ji-ben-cao-zuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>MySQL是一个关系型数据库，其实本质上就是一款软件、一个程序</p>
<ul>
<li>管理着多个数据库；</li>
<li>每个数据库中可以有多张表；</li>
<li>每个表中可以有多条数据；</li>
</ul>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629878806403-1629878806392.png" alt="1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629878881074-1629878881066.png" alt="2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629878911671-1629878911666.png" alt="3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629878952427-1629878952425.png" alt="4"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879322252-1629879322251.png" alt="5"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879350068-1629879350066.png" alt="6"></p>
<p>同意协议并安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879422827-1629879422825.png" alt="7"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879471690-1629879471688.png" alt="8"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879489797-1629879489795.png" alt="9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879534425-1629879534424.png" alt="10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879548909-1629879548908.png" alt="11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879591332-1629879591330.png" alt="12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879699239-1629879699237.png" alt="13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879873195-1629879873194.png" alt="14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879902070-1629879902069.png" alt="15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879925378-1629879925377.png" alt="16"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879973029-1629879973027.png" alt="17"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629879992913-1629879992912.png" alt="18"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629880007203-1629880007202.png" alt="19"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629880029302-1629880029301.png" alt="20"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629880103114-1629880103113.png" alt="21"></p>
<h2 id="三、连接"><a href="#三、连接" class="headerlink" title="三、连接"></a>三、连接</h2><h3 id="1-连接"><a href="#1-连接" class="headerlink" title="1.连接"></a>1.连接</h3><h4 id="1-1配置环境变量"><a href="#1-1配置环境变量" class="headerlink" title="1.1配置环境变量"></a>1.1配置环境变量</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629880719980-1629880719974.png" alt="1.1"></p>
<p>不要忘记点击确认</p>
<h4 id="1-2-查看版本"><a href="#1-2-查看版本" class="headerlink" title="1.2 查看版本"></a>1.2 查看版本</h4><p>运行<code>mysql --version</code>即可成功查看版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629880847739-1629880847738.png" alt="1.2"></p>
<h4 id="1-3-连接数据库"><a href="#1-3-连接数据库" class="headerlink" title="1.3 连接数据库"></a>1.3 连接数据库</h4><p>运行<code>mysql -uroot -p</code></p>
<p>输入密码，即可连接数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629881387763-1629881387762.png" alt="1.3"></p>
<h3 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h3><h4 id="2-1-查看现有的数据库"><a href="#2-1-查看现有的数据库" class="headerlink" title="2.1 查看现有的数据库"></a>2.1 查看现有的数据库</h4><p>运行<code>SHOW DATABASES;</code></p>
<blockquote>
<p>注意：<br>1.字母要大写<br>2.结尾需要加分号</p>
</blockquote>
<p>会有四个默认数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629881608806-1629881608806.png" alt="2.1"></p>
<h4 id="2-2-创建数据库"><a href="#2-2-创建数据库" class="headerlink" title="2.2 创建数据库"></a>2.2 创建数据库</h4><p>运行<code>CREATE DATABASE 库名;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629881956169-1629881956169.png" alt="2.2"></p>
<h4 id="2-3-查看当前正在使用的数据库"><a href="#2-3-查看当前正在使用的数据库" class="headerlink" title="2.3 查看当前正在使用的数据库"></a>2.3 查看当前正在使用的数据库</h4><p>运行<code>SELECT DATABASE();</code></p>
<p>显示null表示没有使用任何数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629882017494-1629882017493.png" alt="2.3"></p>
<h4 id="2-4-使用数据库"><a href="#2-4-使用数据库" class="headerlink" title="2.4 使用数据库"></a>2.4 使用数据库</h4><p>运行<code>USE 库名;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629882100297-1629882100297.png" alt="2.4"></p>
<h3 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3. 表操作"></a>3. 表操作</h3><h4 id="3-1-创建表"><a href="#3-1-创建表" class="headerlink" title="3.1 创建表"></a>3.1 创建表</h4><p>运行<code>CREATE TABLE 表明(字段名 字段类型);</code></p>
<h4 id="3-2-查看表"><a href="#3-2-查看表" class="headerlink" title="3.2 查看表"></a>3.2 查看表</h4><p>运行<code>SHOW TABLES;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629882512209-1629882512208.png" alt="3.2"></p>
<h4 id="3-3-查看表中的数据"><a href="#3-3-查看表中的数据" class="headerlink" title="3.3 查看表中的数据"></a>3.3 查看表中的数据</h4><p>运行<code>SELECT * FROM 表名</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629946658928-1629946658925.png" alt="3.3"></p>
<h4 id="3-4-向表中插入数据"><a href="#3-4-向表中插入数据" class="headerlink" title="3.4 向表中插入数据"></a>3.4 向表中插入数据</h4><p>运行<code>INSERT INTO 表名 (字段1,字段2) VALUES (字段1值,字段2值);</code></p>
<blockquote>
<p>值需要符合字段格式</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629947026842-1629947026842.png" alt="3.4"></p>
<h2 id="四、Navicat使用"><a href="#四、Navicat使用" class="headerlink" title="四、Navicat使用"></a>四、Navicat使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>傻瓜式安装</p>
<p>pj：</p>
<ul>
<li>断网</li>
<li>管理员运行zcj</li>
<li>点击patch</li>
<li>打开Navicat</li>
<li>点击generate</li>
<li>点击手动激活</li>
<li>复制请求码</li>
<li>生成激活码</li>
</ul>
<h4 id="1-1-连接"><a href="#1-1-连接" class="headerlink" title="1.1 连接"></a>1.1 连接</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949265131-1629949265129.png" alt="1.1.1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949300861-1629949300860.png" alt="1.1.2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949348144-1629949348143.png" alt="1.1.3"></p>
<h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h3><h4 id="2-1-在哪写sql"><a href="#2-1-在哪写sql" class="headerlink" title="2.1 在哪写sql"></a>2.1 在哪写sql</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629950688924-1629950688923.png" alt="2.1"></p>
<h4 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h4><h5 id="2-2-1-新建数据库"><a href="#2-2-1-新建数据库" class="headerlink" title="2.2.1 新建数据库"></a>2.2.1 新建数据库</h5><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949715690-1629949715689.png" alt="2.2.1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949800682-1629949800680.png" alt="2.2.2"></p>
<p>刷新一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629949855721-1629949855720.png" alt="2.2.3"></p>
<h5 id="2-2-2-查看数据库"><a href="#2-2-2-查看数据库" class="headerlink" title="2.2.2 查看数据库"></a>2.2.2 查看数据库</h5><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629950603758-1629950603757.png" alt="2.2.2"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化</title>
    <url>/2021/08/16/javascript-mo-kuai-hua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><h2 id="一、什么是模块化"><a href="#一、什么是模块化" class="headerlink" title="一、什么是模块化"></a>一、什么是模块化</h2><p>模块化开发最终的目的是将程序划分成一个个小的模块</p>
<ul>
<li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li>
<li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li>
<li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li>
</ul>
<p>按照这种结构划分开发程序的过程，就是模块化开发的过程</p>
<h2 id="二、没有模块化带来的问题"><a href="#二、没有模块化带来的问题" class="headerlink" title="二、没有模块化带来的问题"></a>二、没有模块化带来的问题</h2><ol>
<li>污染全局作用域</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>文件只能按照script标签的书写顺序进行加载</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ol>
<p>开发项目时，aaa和bbb给变量命名的时候都命名为<code>flag</code>，在index引入时根据<code>flag</code>的值作相应逻辑，这时候会因为命名冲突产生报错，<code>flag</code>会因为引入文件的顺序而产生不确定性。</p>
<pre><code class="js">// aaa.js
let flag = true
·
// bbb.js
let flag = fals
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629107910242-1629107910236.png"></p>
<h2 id="三、模块化方案"><a href="#三、模块化方案" class="headerlink" title="三、模块化方案"></a>三、模块化方案</h2><h3 id="1-CommonJs"><a href="#1-CommonJs" class="headerlink" title="1.CommonJs"></a>1.CommonJs</h3><p>CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了<br>体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS</p>
<p>CommonJS规范的核心变量：exports、module.exports、require；</p>
<p>exports和module.exports可以负责对模块中的内容进行导出；</p>
<p>require函数负责导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="1-exports"><a href="#1-exports" class="headerlink" title="1.exports"></a>1.exports</h4><p>exports是一个对象，在这个对象中添加很多个属性，添加的属性会导出</p>
<pre><code class="js">// foo.js
let age = 18;
const obj = {id:757};
function sayHello(name) {
  console.log("Hello " + name);
}
// 挂载到对象可以使用别名
exports.ageAlias = age
exports.obj = obj
exports.sayHello = sayHello


// bar.js
const foo =  require('./foo')
foo.ageAlias = 99
console.log(foo.ageAlias);
console.log(foo.obj);
foo.sayHello('loveZero')
</code></pre>
<h5 id="思考：exports导出在内存如何体现"><a href="#思考：exports导出在内存如何体现" class="headerlink" title="思考：exports导出在内存如何体现"></a>思考：exports导出在内存如何体现</h5><ol>
<li>1s后在foo.js中修改age值，2s后在bar里打印，值为修改后的值</li>
</ol>
<pre><code class="js">// foo.js
let age = 18;

setTimeout(() =&gt; {
  exports.age = 23;
}, 1000)

exports.age = age

// bar.js
const foo = require('./foo')
console.log('bar---age', foo.age); // 18
setTimeout(() =&gt; {
  console.log('bar---age', foo.age); // 23
}, 2000)
</code></pre>
<ol start="2">
<li>1s后再bar里修改age的值，2s后再foo里打印age为bar修改后的值</li>
</ol>
<pre><code class="js">// foo.js
let age = 18;

setTimeout(() =&gt; {
  console.log('foo---age', exports.age); // 99
}, 2000)

exports.age = age

// bar.js
const foo = require('./foo')

// 验证
setTimeout(() =&gt; {
  foo.age = 99
}, 1000)
</code></pre>
<ol start="3">
<li>结论</li>
</ol>
<p>exports导出的对象和require接受的对象指向统一引用地址</p>
<p>相当于一个浅拷贝，本质是引用赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629185027808-1629185027801.png"></p>
<h4 id="2-module-exports"><a href="#2-module-exports" class="headerlink" title="2.module.exports"></a>2.module.exports</h4><pre><code class="js">// foo.js
let age = 18;
const obj = { id: 757 };
function sayHello(name) {
  console.log("Hello " + name);
}

module.exports = {
  ageAlias: age,
  obj,
  sayHello
}

// bar.js
const foo = require('./foo')
console.log('bar---obj', foo.obj);
console.log('bar---age', foo.ageAlias);
foo.sayHello('loveZero')
</code></pre>
<h5 id="思考：exports和module-exports区别"><a href="#思考：exports和module-exports区别" class="headerlink" title="思考：exports和module.exports区别"></a>思考：exports和module.exports区别</h5><p>先打印一下他们是否相等</p>
<pre><code class="js">console.log({} === {}); // false
console.log(exports === module.exports); // true
</code></pre>
<p>两个对象<code>===</code>，说明他们指向统一引用地址，就是赋值关系</p>
<p>是exports赋值给module.exports还是module.exports赋值给exports呢？需要进一步验证</p>
<pre><code class="js">// foo.js
let age = 100;

console.log('module.exports', module.exports); // {}
console.log('exports', exports); // {}

module.exports = { age }

module.exports = { name: 'loveZero' };

console.log('module.exports', module.exports);  // { name: 'loveZero' }
console.log('exports', exports); // {}

// bar.js
const foo = require('./foo');
console.log('foo', foo) // { name: 'loveZero' }
</code></pre>
<p>通过上述代码可以看出，module.exports和exports初始值都是空对象，通过module.exports导出age后，改变module.exports的值，之后打印exports的值仍为空对象，bar中引入的值是module.exports的值</p>
<pre><code class="js">// foo.js
let age = 100;

console.log('module.exports', module.exports); // {}
console.log('exports', exports); // {}

exports.age = 200;

exports = { name: 'loveZero' };

console.log('module.exports', module.exports);  // { age: 200 }
console.log('exports', exports); // { name: 'loveZero' }


// bar.js
const foo = require('./foo');
console.log('foo', foo) // { age: 200 }
</code></pre>
<p>通过上述验证可以看到，module.exports和exports初始值都是空对象，通过exports将age导出后，修改exports的值，此时module.exports的值为<code>{ age: 200 }</code>，exports的值为<code>{ name: 'loveZero' }</code> ，bar中引用的值是module.exports的值</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol>
<li>module.exports 初始值为一个空对象 {}</li>
<li>exports 是指向的 module.exports 的引用</li>
<li>require导出的内容是module.exports的指向的内存块内容，并不是exports的。</li>
</ol>
<h4 id="3-require"><a href="#3-require" class="headerlink" title="3.require"></a>3.require</h4><p>require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象</p>
<pre><code class="js">require('X')
</code></pre>
<h5 id="1-查找路径"><a href="#1-查找路径" class="headerlink" title="1. 查找路径"></a>1. 查找路径</h5><h6 id="1-X是一个核心模块"><a href="#1-X是一个核心模块" class="headerlink" title="1. X是一个核心模块"></a>1. X是一个核心模块</h6><p> 直接返回核心模块，并且停止查找</p>
<h6 id="2-X是一个以-或-或根目录开头的"><a href="#2-X是一个以-或-或根目录开头的" class="headerlink" title="2.X是一个以./或../或根目录开头的"></a>2.X是一个以./或../或根目录开头的</h6><p> 第一步：将X当做一个文件在对应的目录下查找；</p>
<ol>
<li><p>如果有后缀名，按照后缀名的格式查找对应的文件</p>
</li>
<li><p>如果没有后缀名，会按照如下顺序：</p>
<ol>
<li>直接查找文件X</li>
<li>查找X.js文件</li>
<li>查找X.json文件</li>
<li>查找X.node文件</li>
</ol>
</li>
</ol>
<p>第二步：没有找到对应的文件，将X作为一个目录</p>
<p> 查找目录下面的index文件</p>
<ol>
<li>查找X/index.js文件</li>
<li>查找X/index.json文件</li>
<li>查找X/index.node文件</li>
</ol>
<p>如果没有找到，那么报错：not found</p>
<h6 id="3-直接是一个X（没有路径），并且X不是一个核心模块"><a href="#3-直接是一个X（没有路径），并且X不是一个核心模块" class="headerlink" title="3.直接是一个X（没有路径），并且X不是一个核心模块"></a>3.直接是一个X（没有路径），并且X不是一个核心模块</h6><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629188758555-1629188758546.png"></p>
<p> 如果上面的路径中都没有找到，那么报错：not found</p>
<h5 id="2-模块的加载过程"><a href="#2-模块的加载过程" class="headerlink" title="2.模块的加载过程"></a>2.模块的加载过程</h5><h6 id="模块在被第一次引入时，模块中的js代码会被运行一次"><a href="#模块在被第一次引入时，模块中的js代码会被运行一次" class="headerlink" title="模块在被第一次引入时，模块中的js代码会被运行一次"></a>模块在被第一次引入时，模块中的js代码会被运行一次</h6><h6 id="模块被多次引入时，会缓存，最终只加载（运行）一次"><a href="#模块被多次引入时，会缓存，最终只加载（运行）一次" class="headerlink" title="模块被多次引入时，会缓存，最终只加载（运行）一次"></a>模块被多次引入时，会缓存，最终只加载（运行）一次</h6><p>当模块被引用后，module中的loaded属性会改为true，会缓存起来，该模块再次被引用时，将不再重新加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629190140490-1629190140472.png"></p>
<h6 id="如果有循环引入，使用深度优先算法"><a href="#如果有循环引入，使用深度优先算法" class="headerlink" title="如果有循环引入，使用深度优先算法"></a>如果有循环引入，使用深度优先算法</h6><pre><code class="js">// aaa.js
console.log('aaa');
require('./ccc');

// bbb.js
console.log('bbb');

require('./ccc');
require('./eee');

// ccc.js
console.log('ccc');

require('./ddd');

// ddd.js
console.log('ddd');

require('./eee');

// eee.js
console.log('eee');

// main.js
console.log("main")

require('./aaa');
require('./bbb');

// main
// aaa
// ccc
// ddd
// eee
// bbb
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629189768881-1629189768875.png"></p>
<h4 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h4><ol>
<li>CommonJS模块加载js文件的过程是运行时加载的，并且是同步的<ol>
<li>一个文件没有加载结束之前，后面的代码都不会执行</li>
</ol>
</li>
<li>导出的是一个对象<ol>
<li>导出的和引入的指向都是同一个对象，所以一个变量修改了对象的属性，所有的地方都会被修改</li>
</ol>
</li>
</ol>
<pre><code class="js">// foo.js
let age = 18;
exports.age = age

// bar.js
if (true) {
  const foo = require('./foo')
  console.log(foo);
  console.log('后面的代码');
}
</code></pre>
<h3 id="2-ES-Module"><a href="#2-ES-Module" class="headerlink" title="2.ES Module"></a>2.ES Module</h3><p>基本使用：</p>
<ol>
<li>普通script标签执行顺序与书写顺序有关，而加上<code>type="module"</code>后，script将为异步引入，不会阻塞后面的标签</li>
<li>export 导出模块</li>
<li>import 导入模块</li>
</ol>
<h4 id="1-export"><a href="#1-export" class="headerlink" title="1.export"></a>1.export</h4><p>第一种导出方式：在语句声明的前面直接加上export关键字</p>
<pre><code class="js">// index.html
&lt;body&gt;
  &lt;script src="./index.js" type="module"&gt;&lt;/script&gt;
  &lt;script src="./normal.js"&gt;&lt;/script&gt;
&lt;/body&gt;

// index.js
import { name, age, sayHello } from './modules/bar.js';

console.log(name);
console.log(age);
sayHello('hah')

// bar.js
export const name = "loveZero";
export const age = 18;
export const sayHello = function (name) {
  console.log("你好" + name);
}

// 控制台结果为
我是普通的script标签
loveZero
18
你好hah
</code></pre>
<p>第二种导出方式：将所有需要导出的标识符，放到export后面的 {}中</p>
<pre><code class="js">const name = "loveZero";
const age = 18;
const sayHello = function (name) {
  console.log("你好" + name);
}
export {
  // 可以给导出的变量起别名，使用时也需要使用别名
  name as nameAlias,
  age,
  sayHello
}
</code></pre>
<p><strong style="color:red;">注意</strong>:这里的 {}不是表示对象</p>
<h4 id="2-import"><a href="#2-import" class="headerlink" title="2.import"></a>2.import</h4><p>第一种导出方式：import {标识符列表} from ‘模块’</p>
<pre><code class="js">// 可以通过as 起别名
import { nameAlias, age as ageAlias, sayHello } from './modules/bar.js';
</code></pre>
<p>第二种导出方式：通过 * 将模块功能放到一个模块功能对象（a module object）上</p>
<pre><code class="js">import * as foo from './modules/bar.js';
console.log(foo.age);
console.log(foo.nameAlias);
foo.sayHello('???')
</code></pre>
<h4 id="3-export和import混用"><a href="#3-export和import混用" class="headerlink" title="3.export和import混用"></a>3.export和import混用</h4><p>这里相当于是引入了bar里的age，同时导出了age</p>
<pre><code class="js">// foo.js
export { age } from './bar.js';
</code></pre>
<p>使用场景：</p>
<p>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中，这样方便指定统一的接口规范，也方便阅读</p>
<h4 id="4-default"><a href="#4-default" class="headerlink" title="4.default"></a>4.default</h4><p>默认导出:</p>
<ul>
<li><p>默认导出export时可以不需要指定名字；</p>
</li>
<li><p>在导入时不需要使用 {}，并且可以自己来指定名字</p>
</li>
</ul>
<pre><code class="js">// fun.js
export default function () {
  console.log("do something");
}

// index.js
import fun from './modules/fun.js'
fun()
</code></pre>
<h4 id="5-import函数"><a href="#5-import函数" class="headerlink" title="5.import函数"></a>5.import函数</h4><p> 不可以在逻辑代码中使用import加载模块</p>
<pre><code class="js">if (true) {
  import { age } from './modules/bar.js';
  console.log(age);
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629268467258-1629268467253.png"></p>
<p>因为ES Module在被JS引擎解析时，就必须知道它的依赖关系</p>
<p>可以通过import函数进行动态加载</p>
<pre><code class="js">
if (true) {
  import('./modules/bar.js')
    .then(res =&gt; {
      console.log("在then中的打印");
      console.log(res.age);
    })
    .catch(err =&gt; {
      console.log(err);
    })
}
</code></pre>
<h4 id="6-特点"><a href="#6-特点" class="headerlink" title="6.特点"></a>6.特点</h4><ol>
<li><p>ES Module加载js文件的过程是编译（解析）时加载的，并且是异步的</p>
</li>
<li><p>ES Module是静态解析的，而不是动态或者运行时解析的</p>
</li>
<li><p>ES Module通过export导出的是变量本身的引用</p>
<ol>
<li>export在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment  record）</li>
<li>模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的</li>
<li>在导入的地方，可以实时的获取到绑定的最新值</li>
</ol>
<pre><code class="js">// foo.js
let age = 18;

setTimeout(() =&gt; {
  age = 999
}, 1000)
export {
  age,
}
//index.js
import { age } from './foo.js';

setTimeout(() =&gt; {
  console.log(age); // 999
}, 2000)
</code></pre>
<ol start="4">
<li>在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）</li>
</ol>
<pre><code class="js">// foo.js
let age = 18;

setTimeout(() =&gt; {
  console.log(age); // 18
}, 2000)
export {
  age,
}

// index.js
import { age } from './foo.js';

setTimeout(() =&gt; {
  age = 999
}, 1000)
</code></pre>
<p>无法修改且会报错</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629269598906-1629269598890.png"></p>
<p>内存里大概是这个样子</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629270422607-1629270422597.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>专题</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句</title>
    <url>/2021/09/07/mysql-ji-ben-sql-yu-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><h3 id="1-1-数字类型"><a href="#1-1-数字类型" class="headerlink" title="1.1 数字类型"></a>1.1 数字类型</h3><ul>
<li>整数数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT；</li>
<li>浮点数字类型：FLOAT，DOUBLE（FLOAT是4个字节，DOUBLE是8个字节）；</li>
<li>精确数字类型：DECIMAL，NUMERIC（DECIMAL是NUMERIC的实现形式）</li>
</ul>
<h3 id="1-2-日期类型"><a href="#1-2-日期类型" class="headerlink" title="1.2 日期类型"></a>1.2 日期类型</h3><p> YEAR以YYYY格式显示值</p>
<ul>
<li>范围 1901到2155，和 0000。</li>
</ul>
<p>DATE类型用于具有日期部分但没有时间部分的值：</p>
<ul>
<li>DATE以格式YYYY-MM-DD显示值 ；</li>
<li>支持的范围是 ‘1000-01-01’ 到 ‘9999-12-31’；</li>
</ul>
<p> DATETIME类型用于包含日期和时间部分的值：</p>
<ul>
<li>DATETIME以格式’YYYY-MM-DD hh:mm:ss’显示值；</li>
<li>支持的范围是1000-01-01 00:00:00到9999-12-31 23:59:59</li>
</ul>
<p>TIMESTAMP数据类型被用于同时包含日期和时间部分的值：</p>
<ul>
<li>TIMESTAMP以格式’YYYY-MM-DD hh:mm:ss’显示值；</li>
<li>但是它的范围是UTC的时间范围：’1970-01-01 00:00:01’到’2038-01-19 03:14:07’;</li>
</ul>
<p>DATETIME或TIMESTAMP 值可以包括在高达微秒（6位）精度的后小数秒一部分</p>
<ul>
<li>DATETIME表示的范围可以是’1000-01-01 00:00:00.000000’到’9999-12-31 23:59:59.999999’;</li>
</ul>
<h3 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3 字符串类型"></a>1.3 字符串类型</h3><p> CHAR类型在创建表时为固定长度，长度可以是0到255之间的任何值；</p>
<ul>
<li>在被查询时，会删除后面的空格；</li>
</ul>
<p>VARCHAR类型的值是可变长度的字符串，长度可以指定为0到65535之间的值；</p>
<ul>
<li>在被查询时，不会删除后面的空格；</li>
</ul>
<p> BINARY和VARBINARY 类型用于存储二进制字符串，存储的是字节字符串；</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html">https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html</a></li>
</ul>
<p>BLOB用于存储大的二进制类型；</p>
<p>TEXT用于存储大的字符串类型；</p>
<h2 id="2-DDL（Data-Definition-Language）"><a href="#2-DDL（Data-Definition-Language）" class="headerlink" title="2. DDL（Data Definition Language）"></a>2. DDL（Data Definition Language）</h2><p>数据定义语言；可以通过DDL语句对数据库或者表进行：创建、删除、修改等操作</p>
<h3 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h3><h4 id="2-1-1-查看当前数据库"><a href="#2-1-1-查看当前数据库" class="headerlink" title="2.1.1 查看当前数据库"></a>2.1.1 查看当前数据库</h4><pre><code class="sql">-- 查看所有的数据库
SHOW DATABASES;

-- 选择某一个数据库
USE lovezero;

-- 查看当前正在使用的数据库
SELECT DATABASE();
</code></pre>
<h4 id="2-1-2-创建数据库"><a href="#2-1-2-创建数据库" class="headerlink" title="2.1.2 创建数据库"></a>2.1.2 创建数据库</h4><pre><code class="sql">-- 创建一个新的数据库
-- CREATE DATABASE hello;

-- 当这个数据库不存在时创建一个新的数据库
CREATE DATABASE IF NOT EXISTS hello;

-- 当这个数据库不存在时创建一个指定编码和排序方式的数据库
-- CREATE DATABASE IF NOT EXISTS hello DEFAULT CHARACTER SET utf8mb4
--     COLLATE utf8mb4_0900_ai_ci;
</code></pre>
<h4 id="2-1-3-删除数据库"><a href="#2-1-3-删除数据库" class="headerlink" title="2.1.3 删除数据库"></a>2.1.3 删除数据库</h4><pre><code class="sql">-- 如果这个数据库存在，就删除这个数据库
DROP DATABASE IF EXISTS test;
</code></pre>
<h4 id="2-1-4-修改数据库"><a href="#2-1-4-修改数据库" class="headerlink" title="2.1.4 修改数据库"></a>2.1.4 修改数据库</h4><pre><code class="sql">-- 修改数据库的编码和排序方式
ALTER DATABASE hello CHARACTER SET = utf8 COLLATE = utf8_unicode_ci;
</code></pre>
<h3 id="2-2-数据表操作"><a href="#2-2-数据表操作" class="headerlink" title="2.2 数据表操作"></a>2.2 数据表操作</h3><h4 id="2-2-1-查看所有表"><a href="#2-2-1-查看所有表" class="headerlink" title="2.2.1 查看所有表"></a>2.2.1 查看所有表</h4><pre><code class="mysql"># 查看所有的表
SHOW TABLES;
</code></pre>
<h4 id="2-2-2-新建表"><a href="#2-2-2-新建表" class="headerlink" title="2.2.2 新建表"></a>2.2.2 新建表</h4><pre><code class="sql">CREATE TABLE IF NOT EXISTS `students` (
 `name` VARCHAR(4),
 `age` int
);
</code></pre>
<h4 id="2-2-3-删除表"><a href="#2-2-3-删除表" class="headerlink" title="2.2.3 删除表"></a>2.2.3 删除表</h4><pre><code class="sql">DROP TABLE IF EXISTS users;
</code></pre>
<h4 id="2-2-4-查看表的结构"><a href="#2-2-4-查看表的结构" class="headerlink" title="2.2.4 查看表的结构"></a>2.2.4 查看表的结构</h4><pre><code class="sql">DESC `students`;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629962990638-1629962990635.png" alt="2.2.4"></p>
<h4 id="2-2-5-表约束"><a href="#2-2-5-表约束" class="headerlink" title="2.2.5 表约束"></a>2.2.5 表约束</h4><p>不能为空：NOT NULL</p>
<ul>
<li>某些字段要求用户必须插入值，不可以为空，这个时候可以使用 NOT NULL 来约束；</li>
</ul>
<p>默认值：DEFAULT</p>
<ul>
<li>某些字段希望在没有设置值时给予一个默认值，这个时候可以使用 DEFAULT来完成；</li>
</ul>
<p>自动递增：AUTO_INCREMENT</p>
<ul>
<li>某些字段希望不设置值时可以进行递增，比如用户的id，这个时候可以使用AUTO_INCREMENT来完成；</li>
</ul>
<p>外键约束</p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS `users` (
 -- 设置为主键，自动递增
 `id` INT PRIMARY KEY AUTO_INCREMENT,
 -- VARCHAR类型，长度为10，不为空
 `name` VARCHAR(10) NOT NULL,
 -- INT类型，默认值为0
 `age` INT DEFAULT 0,
 -- VARCHAR类型，长度为20，唯一值
 `phone` VARCHAR(20) UNIQUE,
 -- TIMESTAMP类型
 `createTime` 
);
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629965978672-1629965978671.png" alt="2.2.5"></p>
<h4 id="2-2-6-修改表"><a href="#2-2-6-修改表" class="headerlink" title="2.2.6 修改表"></a>2.2.6 修改表</h4><pre><code class="sql">-- 修改表名
ALTER TABLE `users` RENAME TO `user`;

-- 添加一个新列
ALTER TABLE `user` ADD `updateTime` TIMESTAMP;

-- 修改字段名
ALTER TABLE `user` CHANGE `phone` `telPhone` VARCHAR(20) UNIQUE;

-- 删除字段
ALTER TABLE `user` DROP `age`;

-- 根据一个表的结构创建另一张表
CREATE TABLE `user2` LIKE `user`;

-- 根据一个表的内容创建另一张表
CREATE TABLE `user3` (SELECT * FROM `user`);

-- 修改createTime默认值为创建时间
ALTER TABLE `user` MODIFY `createTime` TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- 修改updateTime默认时间为创建时间，并在更新时自动更新时间
ALTER TABLE `user` MODIFY `updateTime` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629966650306-1629966650305.png" alt="2.2.6.1"><br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629966798878-1629966798877.png" alt="2.2.6.2"></p>
<h2 id="3-DML（Data-Manipulation-Language）"><a href="#3-DML（Data-Manipulation-Language）" class="headerlink" title="3. DML（Data Manipulation Language）"></a>3. DML（Data Manipulation Language）</h2><p>数据操作语言；可以通过DML语句对表进行：添加、删除、修改等操作；</p>
<h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><pre><code class="sql">INSERT INTO `user` VALUES (666, '易烊千玺', '66666666','2021-08-26', '2021-08-26');


-- 对应指定字段，key与val要一一对应
INSERT INTO `user` (name, telPhone, createTime)
      VALUES ('我', '88888888', '2021-08-27');


INSERT INTO `user` (name, telPhone)
      VALUES ('她', '11111111');
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629972381286-1629972381282.png" alt="3.1.1"></p>
<h3 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h3><pre><code class="sql">-- 删除所有数据
DELETE FROM `user`;

-- 删除符合条件的数据
DELETE FROM `user` WHERE id = 666;
</code></pre>
<h3 id="3-3-更新"><a href="#3-3-更新" class="headerlink" title="3.3 更新"></a>3.3 更新</h3><pre><code class="sql">-- 更新所有的数据
UPDATE `user` SET `name` = '咯喽', `createTime` = '1999-09-09';

-- 更新符合条件的数据
UPDATE `user` SET name = '哈哈', `createTime` = '2020-02-02' WHERE id = 670;
</code></pre>
<h2 id="4-DQL（Data-Query-Language）"><a href="#4-DQL（Data-Query-Language）" class="headerlink" title="4. DQL（Data Query Language）"></a>4. DQL（Data Query Language）</h2><p>数据查询语言；可以通过DQL从数据库中查询记录</p>
<h3 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1 查询"></a>4.1 查询</h3><h4 id="4-1-1-基本查询"><a href="#4-1-1-基本查询" class="headerlink" title="4.1.1 基本查询"></a>4.1.1 基本查询</h4><pre><code class="sql">-- 查询所有字段
SELECT * FROM `products`;

-- 查询指定字段
SELECT title,price FROM `products`;
</code></pre>
<pre><code class="sql">-- 给查询结果起别名
SELECT title as phoneTitle,price as currentPrice FROM `products`;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629974608778-1629974608769.png" alt="4.1.1"></p>
<h4 id="4-1-2-WHERE条件查询"><a href="#4-1-2-WHERE条件查询" class="headerlink" title="4.1.2 WHERE条件查询"></a>4.1.2 WHERE条件查询</h4><ol>
<li><p>比较运算符</p>
<pre><code class="sql">SELECT * FROM `products` WHERE price &lt; 1000;
SELECT * FROM `products` WHERE price &gt;= 1000;
SELECT * FROM `products` WHERE brand = '华为';
SELECT title,price FROM `products` WHERE price != 1000;
</code></pre>
</li>
<li><p>逻辑运算符</p>
<pre><code class="sql">-- 逻辑与：三种写法
SELECT * FROM `products` WHERE price &gt; 1000 AND price &lt; 2000;
SELECT * FROM `products` WHERE price &gt; 1000 &amp;&amp; price &lt; 2000;
-- BETWEEN AND 包含等于
SELECT * FROM `products` WHERE price BETWEEN 1099 AND 2000;

-- 逻辑或
SELECT * FROM `products` WHERE price &gt; 5000 || brand = '华为';
SELECT * FROM
</code></pre>
</li>
<li><p>null</p>
<pre><code class="sql">
UPDATE `products` SET url = NULL WHERE id &gt;= 85 and id &lt;= 88;
-- 查询某一个值为NULL
SELECT * FROM `products` WHERE url IS NULL;
-- 查询值不为NULL
SELECT * FROM `products` WHERE url IS NOT NULL;
</code></pre>
</li>
<li><p>IN</p>
<pre><code class="sql">-- IN表示取多个值中的其中一个
SELECT * FROM `products` WHERE brand IN ('华为','小米','苹果');
-- 效果等同与
SELECT * FROM `products` WHERE brand = '华为' || brand = '小米' || brand = '苹果';
</code></pre>
</li>
</ol>
<h4 id="4-1-3-模糊查询"><a href="#4-1-3-模糊查询" class="headerlink" title="4.1.3 模糊查询"></a>4.1.3 模糊查询</h4><ul>
<li><code>%</code>表示匹配任意个任意字符</li>
<li><code>_</code>表示匹配一个任意字符</li>
</ul>
<pre><code class="sql">-- 查询包含8GB的
SELECT * FROM `products` WHERE title LIKE '%8GB%';

-- 查询以v开头的
SELECT * FROM `products` WHERE title LIKE 'v%';

-- 查询带M必须是第单三个字符
SELECT * FROM `products` WHERE title LIKE '__M%';
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630642113009-1630642113005.png" alt="4.3模糊查询"></p>
<h4 id="4-1-4-对查询结果进行排序"><a href="#4-1-4-对查询结果进行排序" class="headerlink" title="4.1.4 对查询结果进行排序"></a>4.1.4 对查询结果进行排序</h4><p>当我们查询到结果的时候，可以使用<code>DRDER BY</code>将结果按照某种方式进行排序<br>ORDER BY有两个常用的值：</p>
<ul>
<li>ASC:升序排列；</li>
<li>DESC:降序排列</li>
</ul>
<pre><code class="sql">-- 按价格升序，当价格相同时按评分降序
SELECT * FROM `products` WHERE brand IN ('华为','小米','苹果') ORDER BY price ASC,score DESC;
</code></pre>
<h4 id="4-1-5-分页查询"><a href="#4-1-5-分页查询" class="headerlink" title="4.1.5 分页查询"></a>4.1.5 分页查询</h4><p>当数据库中的数据非常多时，一次性查询到所有的结果进行显示是不太现实的</p>
<ul>
<li><p>在真实开发中，用户会传入 offset、 limiti或者page等字段；</p>
</li>
<li><p>它们的目的是让我们可以在数据库中进行分页查询；</p>
</li>
<li><p>它的用法有[ LIMIT (offset, row_count row_ count OFFSET offset</p>
</li>
</ul>
<pre><code class="sql">-- 分页查询
-- 查询20条，从0开始 1 - 20 
SELECT * FROM `products` LIMIT 20 OFFSET 0;
-- 查询20条，从20开始 21 - 40 
SELECT * FROM `products` LIMIT 20 OFFSET 20;
-- 查询10条，从40开始
SELECT * FROM `products` LIMIT 40,10;
</code></pre>
<h3 id="4-2-聚合函数"><a href="#4-2-聚合函数" class="headerlink" title="4.2 聚合函数"></a>4.2 聚合函数</h3><p>将表里的所有数据视为一组数据，进行操作</p>
<h4 id="4-2-1-基本使用"><a href="#4-2-1-基本使用" class="headerlink" title="4.2.1 基本使用"></a>4.2.1 基本使用</h4><p><code>SELECT</code>后面不能跟任何字段</p>
<ol>
<li><p>求和</p>
<pre><code class="sql">-- 求和
SELECT SUM(price) FROM `products`;
-- 对结果起别名
SELECT SUM(price) totalPrice FROM `products`;
-- 求华为手机的总和
SELECT SUM(price) FROM `products` WHERE brand = '华为';
</code></pre>
</li>
<li><p>求平均值</p>
<pre><code class="sql">-- 求平均价格
SELECT AVG(price) FROM `products`;
</code></pre>
</li>
<li><p>求最大值和最小值</p>
<pre><code class="sql">-- 求最高和最低
SELECT MAX(price) FROM `products`;

SELECT MIN(price) FROM `products`;
</code></pre>
</li>
<li><p>求总数</p>
<pre><code class="sql">-- 求表里总个数
SELECT COUNT(*) FROM `products`;
-- 求表里url的总个数
SELECT COUNT(url) FROM `products`;
-- 去掉重复的price
SELECT COUNT(DISTINCT price)  FROM `products`;
</code></pre>
</li>
</ol>
<h4 id="4-2-2-GROUP-BY"><a href="#4-2-2-GROUP-BY" class="headerlink" title="4.2.2 GROUP BY"></a>4.2.2 GROUP BY</h4><p>GROUP BY通常和聚合函数一起使用：</p>
<ul>
<li>表示我们先对数据进行分组，再对每一组数据，进行聚合函数的计算</li>
</ul>
<p><code>SELECT</code>后可以跟上分组字段</p>
<pre><code class="sql">-- 根据品牌将手机分组，并计算出每组数据的平均值，总数，平均分
SELECT brand, AVG(price), COUNT(*),AVG(score) FROM `products` GROUP BY brand;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630646512654-1630646512645.png" alt="4.2.2"></p>
<h5 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h5><pre><code class="sql">-- HAVING
-- 分组后，不支持where查询，可以用having筛选
-- 根据品牌将手机分组，并计算出每组数据的平均值，总数，平均分，并筛选出平均价格大于2000的手机
SELECT brand, AVG(price) avgPrice, COUNT(*),AVG(score) FROM `products` GROUP BY brand HAVING avgPrice &gt;2000;
-- 如果要使用where，需要在分组前
-- 筛选出评分大于7.5分的手机，根据品牌进行分组，并计算出每组数据的平均值，总数，平均分
SELECT brand, AVG(price) avgPrice, COUNT(*),AVG(score) FROM `products` WHERE score &gt;7.5 GROUP BY brand;
</code></pre>
<h2 id="5-DCL（Data-Control-Language）"><a href="#5-DCL（Data-Control-Language）" class="headerlink" title="5. DCL（Data Control Language）"></a>5. DCL（Data Control Language）</h2><p>数据控制语言；对数据库、表格的权限进行相关访问控制操作；</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL多表操作</title>
    <url>/2021/09/10/mysql-duo-biao-cao-zuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h1><h2 id="1-创建多表"><a href="#1-创建多表" class="headerlink" title="1. 创建多表"></a>1. 创建多表</h2><p>创建外键<br>将两张表联系起来，我们可以将 product中的 brand_id关联到 brand中的id</p>
<ul>
<li>如果是创建表添加外键约束，我们需要在创建表的最后添加如下语句</li>
</ul>
<pre><code class="sql">
FOREIGN KEY(brand_id)REFERENCES brand(id)
</code></pre>
<ul>
<li>如果是表已经创建好，额外添加外键</li>
</ul>
<pre><code class="sql">
ALTER TABLE `products` ADD FOREIGN KEY(brand_id) REFERENCES brand(id);
</code></pre>
<pre><code class="sql">-- 1.创建brand的表
CREATE TABLE IF NOT EXISTS `brand`(
 id INT PRIMARY KEY AUTO_INCREMENT,
 name VARCHAR(20) NOT NULL,
 website VARCHAR(100),
 phoneRank INT
);

-- 2.插入数据
INSERT INTO `brand` (name, website, phoneRank) VALUES ('华为', 'www.huawei.com', 2);
INSERT INTO `brand` (name, website, phoneRank) VALUES ('苹果', 'www.apple.com', 10);
INSERT INTO `brand` (name, website, phoneRank) VALUES ('小米', 'www.mi.com', 5);
INSERT INTO `brand` (name, website, phoneRank) VALUES ('oppo', 'www.oppo.com', 12);
INSERT INTO `brand` (name, website, phoneRank) VALUES ('京东', 'www.jd.com', 8);
INSERT INTO `brand` (name, website, phoneRank) VALUES ('Google', 'www.google.com', 9);


-- 3.给brand_id设置引用brand中的id的外键约束
-- 添加一个brand_id字段
ALTER TABLE `products` ADD `brand_id` INT;

-- 修改brand_id为外键
ALTER TABLE `products` ADD FOREIGN KEY(brand_id) REFERENCES brand(id);

-- 设置brand_id的值
UPDATE `products` SET `brand_id` = 1 WHERE `brand` = '华为';
UPDATE `products` SET `brand_id` = 2 WHERE `brand` = '苹果';
UPDATE `products` SET `brand_id` = 3 WHERE `brand` = '小米';
UPDATE `products` SET `brand_id` = 4 WHERE `brand` = 'oppo';
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630652813942-1630652813935.png" alt="6.1"></p>
<h3 id="1-1-修改外键"><a href="#1-1-修改外键" class="headerlink" title="1.1 修改外键"></a>1.1 修改外键</h3><p>直接修改外键会报错<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630665094842-1630665094837.png" alt="6.1.2"></p>
<p>修改 on delete或者 on update的值；<br>我们可以给更新或者删除时设置几个值</p>
<ul>
<li><p>RESTRICT（默认属性）：当更新或删除某个记录时，会检査该记录是否有关联的外键记录，有的话会报错,不允许更新或删除</p>
</li>
<li><p>NO ACTION:和 RESTRICT是一致的，是在SQL标准中定义的</p>
</li>
<li><p>CASCADE:当更新或删除某个记录时，会检査该记录是否有关联的外键记录，有的话</p>
<ul>
<li><p>更新：那么会更新对应的记录；</p>
</li>
<li><p>删除：那么关联的记录会被一起删除掉</p>
</li>
</ul>
</li>
<li><p>SET NULL:当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话，将对应的值设置为NULL</p>
</li>
</ul>
<pre><code class="sql">-- 1.获取到目前的外键的名称
SHOW CREATE TABLE `products`;
-- 得到结果
-- CREATE TABLE `products` (
--   `id` int NOT NULL AUTO_INCREMENT,
--   `brand` varchar(20) DEFAULT NULL,
--   `title` varchar(100) NOT NULL,
--   `price` double NOT NULL,
--   `score` decimal(2,1) DEFAULT NULL,
--   `voteCnt` int DEFAULT NULL,
--   `url` varchar(100) DEFAULT NULL,
--   `pid` int DEFAULT NULL,
--   `brand_id` int DEFAULT NULL,
--   PRIMARY KEY (`id`),
--   KEY `brand_id` (`brand_id`),
--   CONSTRAINT `products_ibfk_1` FOREIGN KEY (`brand_id`) REFERENCES `brand` (`id`) // 外键名称products_ibfk_1
-- ) ENGINE=InnoDB AUTO_INCREMENT=109 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
-- 

-- 2.根据名称将外键删除掉
ALTER TABLE `products` DROP FOREIGN KEY products_ibfk_1;

-- 3.重新添加外键约束：修改时联动，删除时默认
ALTER TABLE `products` ADD FOREIGN KEY (brand_id) REFERENCES brand(id)
                         ON UPDATE CASCADE 
                         ON DELETE RESTRICT;

-- 4.修改外键
UPDATE `brand` SET `id` = 100 WHERE `id` = 1;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630665397698-1630665397693.png" alt="修改前后对比"><br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1630665457227-1630665457223.png" alt="修改成功"></p>
<h2 id="2-多表查询"><a href="#2-多表查询" class="headerlink" title="2. 多表查询"></a>2. 多表查询</h2><h3 id="6-3-多表查询"><a href="#6-3-多表查询" class="headerlink" title="6.3 多表查询"></a>6.3 多表查询</h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理工具</title>
    <url>/2021/08/19/npm-bao-guan-li-gong-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="一、Npm"><a href="#一、Npm" class="headerlink" title="一、Npm"></a>一、Npm</h2><p>Node Package Manager，就是Node包管理器</p>
<h3 id="1-npm管理的包存放在哪里"><a href="#1-npm管理的包存放在哪里" class="headerlink" title="1. npm管理的包存放在哪里"></a>1. npm管理的包存放在哪里</h3><p>发布包其实是发布到registry上面的；</p>
<p>当我们安装一个包时其实是从registry上面下载的包；</p>
<h3 id="2-项目配置文件-package-json"><a href="#2-项目配置文件-package-json" class="headerlink" title="2. 项目配置文件 package.json"></a>2. 项目配置文件 package.json</h3><p>所有用npm下载的包或者要上传至npm的模块都会有一个package.json文件，这个文件总是存在于模块(或者包)的根目录下。</p>
<p>package.json是对下载的包或模块的描述信息，如果你要上传包到npm服务器也要有对应的模块说明。说明包括项目名称、版本、作者等等。package.json必须是一个严格的json格式，也就是说每一个字段都要使用双引号，不论是key值还是value值。</p>
<h4 id="2-1-创建-package-json"><a href="#2-1-创建-package-json" class="headerlink" title="2.1 创建 package.json"></a>2.1 创建 package.json</h4><p>执行命令<code>npm init -y</code>会默认创建一个package.json文件</p>
<p>name默认值是当前文件夹的名称(不能有中文)</p>
<pre><code class="js">{
  "name": "npm",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</code></pre>
<h4 id="2-2-属性说明"><a href="#2-2-属性说明" class="headerlink" title="2.2 属性说明"></a>2.2 属性说明</h4><ul>
<li><code>name</code> 设置了应用程序/软件包的名称。</li>
<li><code>version</code> 表明了当前的版本。</li>
<li><code>description</code> 是应用程序/软件包的简短描述。</li>
<li><code>main</code> 设置了应用程序的入口点。</li>
<li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外地发布到 <code>npm</code>。</li>
<li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li>
<li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>engines</code> 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>
<li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li>
</ul>
<p>其中必写属性是<code>name</code>和<code>version</code></p>
<h5 id="2-2-1-name"><a href="#2-2-1-name" class="headerlink" title="2.2.1 name"></a>2.2.1 name</h5><ul>
<li>名称不能超过214个字符</li>
<li>名称不能以点或者下划线开头</li>
<li>包的名称中不能包含大写字母</li>
<li>此名称将会成为URL的一部分，因此不能包含非URL的字符</li>
<li>若包名称中存在一些符号，将符号去除后不得与现有包名重复<ul>
<li>由于react-native已经存在，react.native、reactnative都不可以再创建。</li>
</ul>
</li>
</ul>
<p>查看包名是否被占用</p>
<p>使用<code>npm view</code></p>
<p>能查询到信息说明已被使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629362311235-1629362311218.png"></p>
<p>抛出404说明该包名未被使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629362347676-1629362347675.png"></p>
<h5 id="2-2-2-version"><a href="#2-2-2-version" class="headerlink" title="2.2.2 version"></a>2.2.2 version</h5><blockquote>
<p>使用遵循CommonJS规范的require(‘moduleName’)就会加载main字段指定的目录下的文件。这个字段的默认值是模块根目录下面的index.js，</p>
</blockquote>
<ul>
<li>版本号由主版本.此版本.补丁版本组成</li>
<li>版本必须要由<a href="https://link.segmentfault.com/?url=https://docs.npmjs.com/misc/semver.html">node-semver</a>解析，它与npm捆绑在一起作为依赖项。</li>
</ul>
<h5 id="2-2-3-description和keywords"><a href="#2-2-3-description和keywords" class="headerlink" title="2.2.3 description和keywords"></a>2.2.3 description和keywords</h5><p>description用于添加模块的的描述信息，方便别人了解你的模块。</p>
<p>keywords用于给你的模块添加关键字。</p>
<p>当使用 npm search 检索模块时，会到description 和 keywords 中进行匹配。写好 description 和 keywords 有利于你的模块获得更多更精准的曝光</p>
<pre><code class="json">{
   "description": "说明信息",
   "keywords": [
      "node",
      "配置",
      "json"
    ]
}
</code></pre>
<h5 id="2-2-4-main"><a href="#2-2-4-main" class="headerlink" title="2.2.4 main"></a>2.2.4 main</h5><p>字段指定了程序的主入口文件</p>
<p>使用遵循CommonJS规范的require(‘moduleName’)就会加载main字段指定的目录下的文件。这个字段的默认值是模块根目录下面的index.js，</p>
<h5 id="2-2-5-author-和-contributors"><a href="#2-2-5-author-和-contributors" class="headerlink" title="2.2.5 author 和 contributors"></a>2.2.5 author 和 contributors</h5><p>author 指包的主要作者，一个 author 对应一个人。 contributors 指贡献者信息，一个 contributors 对应多个贡献者，值为数组</p>
<pre><code class="json">{
  "author": "作者 &lt;example@example.com&gt; (http://xxx.com)",
  "contributors": [
    {
      "name": "贡献者",
      "email": "example@example.com",
      "url": "http://xxx.com"
    }
  ]
}
</code></pre>
<h5 id="2-2-6-homepage-和-repository"><a href="#2-2-6-homepage-和-repository" class="headerlink" title="2.2.6 homepage 和 repository"></a>2.2.6 homepage 和 repository</h5><p>homepage 用于指定该模块的主页，repository 用于指定模块的代码仓库。</p>
<h5 id="2-2-7-scripts"><a href="#2-2-7-scripts" class="headerlink" title="2.2.7 scripts"></a>2.2.7 scripts</h5><p>指定了运行脚本命令的npm命令行缩写，，以键值对的形式存在</p>
<p>比如start指定了运行<code>npm run start</code>时，所要执行的命令。</p>
<p>对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；</p>
<pre><code class="json">  "scripts": {
    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
    "start": "npm run dev",
    "unit": "jest --config test/unit/jest.conf.js --coverage",
    "test": "npm run unit",
    "lint": "eslint --ext .js,.vue src test/unit",
    "build": "node build/build.js"
  },
</code></pre>
<h5 id="2-2-8-engines"><a href="#2-2-8-engines" class="headerlink" title="2.2.8 engines"></a>2.2.8 engines</h5><p>用于指定Node和NPM的版本号；也可以指定所在的操作系统 “os” : [ “darwin”, “linux” ]</p>
<p>在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；</p>
<pre><code class="json">  "engines": {
    "node": "&gt;= 6.0.0",
    "npm": "&gt;= 3.0.0"
  },
</code></pre>
<h5 id="2-2-9-dependencies和devDependencies"><a href="#2-2-9-dependencies和devDependencies" class="headerlink" title="2.2.9 dependencies和devDependencies"></a>2.2.9 dependencies和devDependencies</h5><p>dependencies是指定无论开发环境还是生成环境都需要依赖的包；通常是我们项目实际开发用到的一些库模块；</p>
<p>devDependencies是指一些包在生成环境是不需要的，比如webpack、babel等；</p>
<p>这个时候我们会通过 npm install webpack –save-dev，将它安装到devDependencies属性中；</p>
<pre><code class="json">  "dependencies": {
    "vue": "^2.5.2"
  },
</code></pre>
<h4 id="2-3-版本问题"><a href="#2-3-版本问题" class="headerlink" title="2.3 版本问题"></a>2.3 版本问题</h4><p>我们会发现安装的依赖版本出现：<code>^2.0.3</code>或<code>~2.0.3</code>，这是什么意思呢？</p>
<p>npm的包通常需要遵从semver版本规范：</p>
<ul>
<li>semver：<a href="https://link.zhihu.com/?target=https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li>
<li>npm semver：<a href="https://link.zhihu.com/?target=https://docs.npmjs.com/misc/semver">https://docs.npmjs.com/misc/semver</a></li>
</ul>
<p>semver版本规范是X.Y.Z：</p>
<ul>
<li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；</li>
<li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；</li>
<li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；</li>
</ul>
<p>我们这里解释一下 ^和~的区别：</p>
<ul>
<li><code>^x.y.z</code>：表示x是保持不变的，y和z永远安装最新的版本；</li>
<li><code>~x.y.z</code>：表示x和y保持不变的，z永远安装最新的版本；</li>
</ul>
<h3 id="3-npm工具解析"><a href="#3-npm工具解析" class="headerlink" title="3.npm工具解析"></a>3.npm工具解析</h3><h4 id="3-1-全局安装"><a href="#3-1-全局安装" class="headerlink" title="3.1 全局安装"></a>3.1 全局安装</h4><p>全局安装是直接将某个包安装到全局：</p>
<p>比如yarn的全局安装：</p>
<pre><code class="npm">npm install yarn -g
</code></pre>
<p>通常使用npm全局安装的包都是一些工具包：yarn、webpack等</p>
<h4 id="3-2-局部安装"><a href="#3-2-局部安装" class="headerlink" title="3.2 局部安装"></a>3.2 局部安装</h4><p>局部安装会在当前目录下生产一个 <code>node_modules</code> 文件夹</p>
<pre><code class="npm"># 安装开发和生产依赖
npm install axios --save
npm install axios -S
npm install axios
npm i axios

# 开发者
npm install axios --save-dev
npm install axios -D
npm i axios -D
</code></pre>
<h3 id="4-npm-install原理"><a href="#4-npm-install原理" class="headerlink" title="4. npm install原理"></a>4. npm install原理</h3><h4 id="4-1-package-lock-json文件"><a href="#4-1-package-lock-json文件" class="headerlink" title="4.1 package-lock.json文件"></a>4.1 package-lock.json文件</h4><pre><code class="json">{
  "name": "npm",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "axios": {
      "version": "0.20.0",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.20.0.tgz",
      "integrity": "sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M/v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA==",
      "requires": {
        "follow-redirects": "^1.10.0"
      }
    },
    "follow-redirects": {
      "version": "1.13.0",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.13.0.tgz",
      "integrity": "sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd/TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA=="
    }
  }
}
</code></pre>
<ul>
<li><p>name：项目的名称；</p>
</li>
<li><p>version：项目的版本；</p>
</li>
<li><p>lockfileVersion：lock文件的版本；</p>
</li>
<li><p>requires：使用requires来跟着模块的依赖关系；</p>
</li>
<li><p>dependencies：项目的依赖</p>
<ul>
<li><ul>
<li>version表示实际安装的axios的版本；</li>
</ul>
</li>
<li>resolved用来记录下载的地址，registry仓库中的位置；</li>
<li>requires记录当前模块的依赖；</li>
<li>integrity用来从缓存中获取索引，再通过索引去获取压缩包文件；</li>
<li>当前项目依赖axios，但是axios依赖follow-redireacts；</li>
<li>axios中的属性如下</li>
</ul>
</li>
</ul>
<h4 id="4-2-原理图"><a href="#4-2-原理图" class="headerlink" title="4.2 原理图"></a>4.2 原理图</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629365279284-1629365279279.png"></p>
<h3 id="5-npm其他命令"><a href="#5-npm其他命令" class="headerlink" title="5. npm其他命令"></a>5. npm其他命令</h3><p>卸载某个依赖包：</p>
<ul>
<li>npm uninstall package</li>
<li>npm uninstall package –save-dev</li>
<li>npm uninstall package -D</li>
</ul>
<p>强制重新build</p>
<ul>
<li>npm rebuild</li>
</ul>
<p>清除缓存</p>
<ul>
<li>npm cache clean</li>
</ul>
<h2 id="二、Yarn工具"><a href="#二、Yarn工具" class="headerlink" title="二、Yarn工具"></a>二、Yarn工具</h2><p>另一个node包管理工具yarn：</p>
<ul>
<li>yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；</li>
<li>yarn 是为了弥补 npm 的一些缺陷而出现的；</li>
<li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；</li>
<li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；</li>
</ul>
<p>这里给出一张常用命令的对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629365546307-1629365546304.png"></p>
<h2 id="三、cnpm"><a href="#三、cnpm" class="headerlink" title="三、cnpm"></a>三、cnpm</h2><p>由于一些特殊的原因，某些情况下我们没办法很好的从 <code>https://registry.npmjs.org</code>下载下来一些需要的包。</p>
<p>查看npm镜像：</p>
<pre><code class="text">npm config get registry # npm config get registry
</code></pre>
<p>我们可以直接设置npm的镜像：</p>
<pre><code class="text">npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>但是对于大多数人来说（比如我），并不希望将npm镜像修改了：</p>
<ul>
<li>第一，不太希望随意修改npm原本从官方下来包的渠道；</li>
<li>第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；</li>
</ul>
<p>这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：</p>
<pre><code class="text">npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm config get registry # https://r.npm.taobao.org/
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer</title>
    <url>/2021/08/19/node-buffer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="一、知识补充"><a href="#一、知识补充" class="headerlink" title="一、知识补充"></a>一、知识补充</h2><h3 id="1-数据的二进制"><a href="#1-数据的二进制" class="headerlink" title="1.数据的二进制"></a>1.数据的二进制</h3><p>计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示</p>
<table>
<thead>
<tr>
<th>128</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<h2 id="2-Buffer-缓冲区"><a href="#2-Buffer-缓冲区" class="headerlink" title="2.Buffer(缓冲区)"></a>2.Buffer(缓冲区)</h2><p><code>JavaScript</code> 语言自身只有字符串数据类型，没有二进制数据类型，但在处理像 <code>TCP</code> 流或文件流时，必须使用到二进制数据，因此在 <code>Node.js</code> 中，定义了一个 <code>Buffer</code> 类，该类用来创建一个专门存放二进制数据的缓存区</p>
<p>Buffer 用于读取或操作二进制数据流，做为 Node.js API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且是无法调整的，</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><h4 id="1-1-将字符串转为buffer"><a href="#1-1-将字符串转为buffer" class="headerlink" title="1.1 将字符串转为buffer"></a>1.1 将字符串转为buffer</h4><pre><code class="js">const buffer = Buffer.from('Hello');
console.log(buffer); // &lt;Buffer 48 65 6c 6c 6f&gt;
</code></pre>
<h4 id="1-2将中文转为buffer"><a href="#1-2将中文转为buffer" class="headerlink" title="1.2将中文转为buffer"></a>1.2将中文转为buffer</h4><p>用什么格式转为buffer，就用什么格式解码</p>
<pre><code class="js">
const buffer2 = Buffer.from('你好', 'utf16le');
console.log(buffer2); // &lt;Buffer 60 4f 7d 59&gt;
// buffer转字符串
console.log(buffer2.toString('utf16le')); // 你好
</code></pre>
<h4 id="1-3创建buffer"><a href="#1-3创建buffer" class="headerlink" title="1.3创建buffer"></a>1.3创建buffer</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>Express模块</title>
    <url>/2021/11/25/node-express/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p> 方式一：安装express-generator</p>
<pre><code class="js">  安装脚手架
  npm install -g express-generator
  创建项目
  express express-demo
  安装依赖
  npm install
  启动项目
  node bin/www
</code></pre>
<p>访问<code>localhost:3000</code>出现hello Express说明启动成功<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16377409450341637740945022.png" alt="express"><br>方式二：从零搭建自己的express应用结构</p>
<pre><code class="js">  npm init -y
  npm i express
</code></pre>
<h2 id="二、中间件"><a href="#二、中间件" class="headerlink" title="二、中间件"></a>二、中间件</h2><p><strong>中间件必须调用<code>next()</code>才会匹配下一个中间件，最后一个中间件用<code>res.end()</code>结束</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16378104654941637810465475.png" alt="中间件"></p>
<h3 id="1-普通中间件"><a href="#1-普通中间件" class="headerlink" title="1.普通中间件"></a>1.普通中间件</h3><p>可以匹配任何请求，任何路径</p>
<pre><code class="js">app.use((req, res, next) =&gt; {
  res.end('结束')
})

app.use('/home', (req, res, next) =&gt; {
  next()
})
</code></pre>
<h3 id="2-get-post中间件"><a href="#2-get-post中间件" class="headerlink" title="2.get/post中间件"></a>2.get/post中间件</h3><pre><code class="js">// get监听默认路径
app.get('/', (req, res, next) =&gt; {
  res.end('get请求')
})

// post监听默认路径
app.post('/', (req, res, next) =&gt; {
  res.end('post请求')
})

app.post('/login', (req, res, next) =&gt; {
  res.end('post请求login')
})
</code></pre>
<h3 id="3-连续调用中间件"><a href="#3-连续调用中间件" class="headerlink" title="3.连续调用中间件"></a>3.连续调用中间件</h3><pre><code class="js">app.get("/home", (req, res, next) =&gt; {
  console.log("home path and method middleware 02");
  next();
}, (req, res, next) =&gt; {
  console.log("home path and method middleware 03");
  next();
}, (req, res, next) =&gt; {
  console.log("home path and method middleware 04");
  res.end("home page");
});
</code></pre>
<h3 id="4-express解析json数据"><a href="#4-express解析json数据" class="headerlink" title="4.express解析json数据"></a>4.express解析json数据</h3><pre><code class="js">const express = require('express');

const app = express();

// 使用express提供的body解析
app.use(express.json());

app.post('/login', (req, res, next) =&gt; {
  console.log(req.body);
  res.end("请求成功");
});

</code></pre>
<h3 id="5-express解析application-x-www-form-urlencoded数据"><a href="#5-express解析application-x-www-form-urlencoded数据" class="headerlink" title="5.express解析application/x-www-form-urlencoded数据"></a>5.express解析application/x-www-form-urlencoded数据</h3><pre><code class="js">const express = require('express');

const app = express();
// extended
// true: 使用qs解析urlencoded
// false: 使用querystring解析urlencoded
app.use(express.urlencoded({ extended: true }));

app.post('/login', (req, res, next) =&gt; {
  console.log(req.body);
  res.end("请求成功");
});
</code></pre>
<h3 id="6-express解析form-data数据"><a href="#6-express解析form-data数据" class="headerlink" title="6.express解析form-data数据"></a>6.express解析form-data数据</h3><p><code>npm i multer</code>安装<code>multer</code></p>
<pre><code class="js">const express = require('express');
const multer = require('multer');

const app = express();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const upload = multer();

app.use(upload.any());

app.post('/login', (req, res, next) =&gt; {
  console.log(req.body);
  res.end("用户登录成功~")
});
</code></pre>
<h3 id="7-express上传文件"><a href="#7-express上传文件" class="headerlink" title="7.express上传文件"></a>7.express上传文件</h3><pre><code class="js">const path = require('path');

const express = require('express');
const multer = require('multer');

const app = express();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const storage = multer.diskStorage({
  // 指定文件存放路径,必须是已存在的文件夹
  destination: (req, file, cb) =&gt; {
    cb(null, './uploads/');
  },
  // 自定义文件名
  filename: (req, file, cb) =&gt; {
    cb(null, Date.now() + path.extname(file.originalname));
  }
})

const upload = multer({
  storage
});

// upload.any()不要作为全局的中间件
app.post('/login', upload.any(), (req, res, next) =&gt; {
  console.log(req.body);
  res.end("用户登录成功~")
});

// upload.array:多文件上传,文件存储在req.files
// upload.single：单文件,we年存储在req.flie
// 参数是接口传进来的key
app.post('/upload', upload.single('file'), (req, res, next) =&gt; {
  console.log(req.file);
  res.end("文件上传成功~");
});
</code></pre>
<h3 id="8-express保存日志信息"><a href="#8-express保存日志信息" class="headerlink" title="8.express保存日志信息"></a>8.express保存日志信息</h3><p><code>npm i morgan</code>安装<code>morgan</code></p>
<pre><code class="js">const fs = require('fs');

const express = require('express');
const morgan = require('morgan');

const app = express();

const writerStream = fs.createWriteStream('./logs/access.log', {
  flags: "a+"
})

app.use(morgan("combined", { stream: writerStream }));

app.get('/home', (req, res, next) =&gt; {
  res.end("Hello World");
})

app.listen(8000, () =&gt; {
  console.log("express初体验服务器启动成功~");
});
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Node中的内置模块</title>
    <url>/2021/08/18/node-node-zhong-de-nei-zhi-mo-kuai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node中的内置模块"><a href="#Node中的内置模块" class="headerlink" title="Node中的内置模块"></a>Node中的内置模块</h1><h2 id="一、path"><a href="#一、path" class="headerlink" title="一、path"></a>一、path</h2><h3 id="从路径中获取信息"><a href="#从路径中获取信息" class="headerlink" title="从路径中获取信息"></a>从路径中获取信息</h3><ul>
<li>dirname：获取文件的父文件夹</li>
<li>basename：获取文件名</li>
<li>extname：获取文件扩展名</li>
</ul>
<pre><code class="js">const path = require('path');
// 1.获取路径的信息
const filepath = '/User/loveZero/abc.txt';

console.log(path.dirname(filepath)); // /User/loveZero
console.log(path.basename(filepath)); // abc.txt
console.log(path.extname(filepath)); // .txt
</code></pre>
<h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>只是拼接各个path片段</p>
<pre><code class="js">const basepath = '../User/loveZero';
const filename = './abc.txt';

const filepath1 = path.join(basepath, filename);
console.log(filepath1); // ..\User\loveZero\abc.txt
</code></pre>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p>会判断拼接的路径字符串中,是否有以/或./或../开头的路径</p>
<p>有的话就返回一个以相对于当前的工作目录（working directory）的绝对路径。</p>
<ol>
<li>参数从后向前，若字符以 / 开头，不会拼接到前面的路径；</li>
<li>若以 ../ 开头，拼接前面的路径，但是不含前面一节的最后一层路径；</li>
<li>若以 ./ 开头 或者没有符号 则拼接前面路径</li>
</ol>
<pre><code class="js">const basepath = '../User/loveZero';
const filename = './abc.txt';
const filepath2 = path.resolve(basepath, filename);
console.log(filepath2); // c:\Users\loveZero\Desktop\my\User\loveZero\abc.txt
</code></pre>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li>join是把各个path片段连接在一起， resolve把‘／’当成根目录</li>
<li>resolve在传入的第一参数为非根路径时，会返回一个带当前目录路径的绝对路径。</li>
</ol>
<pre><code class="js">console.log(path.resolve()) // c:\Users\loveZero\Desktop\my\study-demo
console.log(path.resolve('')) // c:\Users\loveZero\Desktop\my\study-demo
console.log(path.resolve(__dirname)) // c:\Users\loveZero\Desktop\my\study-demo\基础\02-内置模块\path
console.log(path.resolve('/img/books', '/net'))   // c:\net
console.log(path.resolve('img/books', '/net'))    // c:\net
console.log(path.resolve('img/books', './net'))   // c:\Users\loveZero\Desktop\my\study-demo\img\books\net
console.log(path.resolve('/img/books', './net'))   // c:\img\books\net
console.log(path.resolve('/img/books', 'net'))     // c:\img\books\net
console.log(path.resolve('/img/books', '../net'))         // c:\img\net
console.log(path.resolve('src', '/img/books', '../net'))   // c:\img\net
console.log(path.resolve('src', './img/books', '../net'))   // c:\Users\loveZero\Desktop\my\study-demo\src\img\net
console.log(path.resolve('src', 'img/books', '../net'))     // c:\Users\loveZero\Desktop\my\study-demo\src\img\net
</code></pre>
<pre><code class="js">console.log(path.join())           // .
console.log(path.join(''))         // .
console.log(path.join(__dirname))  // c:\Users\loveZero\Desktop\my\study-demo\基础\02-内置模块\path
console.log(path.join('/img/books', '/net'))   // \img\books\net
console.log(path.join('img/books', '/net'))    // img\books\net
console.log(path.join('img/books', './net'))   // img\books\net
console.log(path.join('/img/books', './net'))   // \img\books\net
console.log(path.join('/img/books', 'net'))     // \img\books\net
console.log(path.join('/img/books', '../net'))         // \img\net
console.log(path.join('src', '/img/books', '../net'))   // src\img\net
console.log(path.join('src', './img/books', '../net'))   // src\img\net
console.log(path.join('src', 'img/books', '../net'))     // src\img\net
</code></pre>
<h2 id="二、fs"><a href="#二、fs" class="headerlink" title="二、fs"></a>二、fs</h2><p>fs是File System的缩写，表示文件系统</p>
<h3 id="1-获取文件状态"><a href="#1-获取文件状态" class="headerlink" title="1.获取文件状态"></a>1.获取文件状态</h3><h4 id="同步获取"><a href="#同步获取" class="headerlink" title="同步获取"></a>同步获取</h4><pre><code class="js">const fs = require('fs');
const info = fs.statSync('./abc.txt');
console.log(info);
console.log("后续需要执行的代码");
/**
 Stats {
  dev: 3728757869,
  mode: 33206,
  nlink: 1,
  uid: 0,
  gid: 0,
  rdev: 0,
  blksize: 4096,
  ino: 8725724278139394,
  size: 3,
  blocks: 0,
  atimeMs: 1629275163060.15,
  mtimeMs: 1629275163060.15,
  ctimeMs: 1629275163060.15,
  birthtimeMs: 1629275160923.6409,
  atime: 2021-08-18T08:26:03.060Z,
  mtime: 2021-08-18T08:26:03.060Z,
  ctime: 2021-08-18T08:26:03.060Z,
  birthtime: 2021-08-18T08:26:00.924Z
 }
  后续需要执行的代码
 */
</code></pre>
<h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><pre><code class="js">fs.stat('./abc.txt', (err, info) =&gt; {
  if (err) {
    console.log(err);
    return;
  }
  console.log(info);
  // 判断是否是文件
  console.log(info.isFile());
  // 判断是否是文件夹
  console.log(info.isDirectory());
});
console.log("后续需要执行的代码");
/*
后续需要执行的代码
Stats {
  dev: 3728757869,
  mode: 33206,
  nlink: 1,
  uid: 0,
  gid: 0,
  rdev: 0,
  blksize: 4096,
  ino: 8725724278139394,
  size: 3,
  blocks: 0,
  atimeMs: 1629275163060.15,
  mtimeMs: 1629275163060.15,
  ctimeMs: 1629275163060.15,
  birthtimeMs: 1629275160923.6409,
  atime: 2021-08-18T08:26:03.060Z,
  mtime: 2021-08-18T08:26:03.060Z,
  ctime: 2021-08-18T08:26:03.060Z,
  birthtime: 2021-08-18T08:26:00.924Z
}
true
false
*/
</code></pre>
<h4 id="promise方式"><a href="#promise方式" class="headerlink" title="promise方式"></a>promise方式</h4><pre><code class="js">fs.promises.stat('./abc.txt').then(info =&gt; {
  console.log(info);
}).catch(err =&gt; {
  console.log(err);
});
console.log("后续需要执行的代码");
</code></pre>
<h3 id="2-文件描述符"><a href="#2-文件描述符" class="headerlink" title="2.文件描述符"></a>2.文件描述符</h3><p><strong>文件描述符</strong>（file descriptor）在形式上是一个非负整数。实际上，它是一个索引值，每一个文件描述符会与一个打开文件相对应。</p>
<p>每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。</p>
<p>在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件</p>
<pre><code class="js">const fs = require('fs');

fs.open("./abc.txt", (err, fd) =&gt; {
  if (err) {
    console.log('err', err);
    return;
  }

  console.log(fd);
  //  fd就是文件描述符，一旦获得了文件描述符，就可以通过任何方式执行所需的所有操作
  // 通过描述符去获取文件的信息
  fs.fstat(fd, (err, info) =&gt; {
    console.log(info);
  })
})
</code></pre>
<h3 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3.文件读写"></a>3.文件读写</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629278489244-1629278489240.png"></p>
<pre><code class="js">const fs = require('fs');

fs.readFile("./abc.txt", 'utf-8', (err, data) =&gt; {
  if (err) {
    console.error(err)
    return
  }
  console.log(data)
});
</code></pre>
<ol>
<li>如果不指定encoding格式，默认将以<buffer>格式返回</buffer></li>
<li>如果options是字符串格式，默认是encoding值</li>
</ol>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><pre><code class="js">const fs = require('fs')

const content = '一些内容'

fs.writeFile('./abc.txt', content, err =&gt; {
  if (err) {
    console.error(err)
    return
  }
  console.error('文件写入成功')
})
</code></pre>
<p>将内容追加到文件末尾</p>
<pre><code class="js">fs.appendFile('./abc.txt', content, err =&gt; {
  if (err) {
    console.error(err)
    return
  }
  console.error('文件写入成功')
})
</code></pre>
<h4 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h4><ul>
<li>w打开文件写入，默认值；</li>
<li>w+打开文件进行读写，如果不存在则创建文件；</li>
<li>r+打开文件进行读写，如果不存在那么抛出异常；</li>
<li>r打开文件读取，读取时的默认值；</li>
<li>a打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；</li>
<li>a+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件</li>
</ul>
<pre><code class="js">fs.writeFile('./abc.txt', content, { flag: 'a+' }, err =&gt; {
  if (err) {
    console.error(err)
    return
  }
  console.error('文件写入成功')
})
</code></pre>
<h3 id="4-文件夹操作"><a href="#4-文件夹操作" class="headerlink" title="4.文件夹操作"></a>4.文件夹操作</h3><h4 id="1-判断文件夹是否存在"><a href="#1-判断文件夹是否存在" class="headerlink" title="1.判断文件夹是否存在"></a>1.判断文件夹是否存在</h4><p>方式一</p>
<pre><code class="js">fs.existsSync('./loveZero')
</code></pre>
<p>方式二</p>
<pre><code class="js">const dirname = './loveZero';
// 检查文件是否存在于当前目录中。
fs.access(dirname, fs.constants.F_OK, (err) =&gt; {
  console.log(`${dirname} ${err ? '不存在' : '存在'}`);
});

// 检查文件是否可读。
fs.access(dirname, fs.constants.R_OK, (err) =&gt; {
  console.log(`${dirname} ${err ? '不可读' : '可读'}`);
});

// 检查文件是否可写。
fs.access(dirname, fs.constants.W_OK, (err) =&gt; {
  console.log(`${dirname} ${err ? '不可写' : '可写'}`);
});

// 检查文件是否存在于当前目录中、以及是否可写。
fs.access(dirname, fs.constants.F_OK | fs.constants.W_OK, (err) =&gt; {
  if (err) {
    console.error(
      `${dirname} ${err.code === 'ENOENT' ? '不存在' : '只可读'}`);
  } else {
    console.log(`${dirname} 存在，且可写`);
  }
});
</code></pre>
<h4 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2.创建文件夹"></a>2.创建文件夹</h4><p>使用 <code>fs.mkdir()</code> 或 <code>fs.mkdirSync()</code> 可以创建新的文件夹。</p>
<pre><code class="js">if (!fs.existsSync(dirname)) {
  fs.mkdir(dirname, err =&gt; {
    console.log(err);
  });
}
</code></pre>
<h4 id="3-读取目录内容"><a href="#3-读取目录内容" class="headerlink" title="3.读取目录内容"></a>3.读取目录内容</h4><pre><code class="js">const folderPath = '../fs'
fs.readdir(folderPath, (err, files) =&gt; {
  console.log(files);
});
/*
[
  '01-获取文件状态.js',
  '02-文件描述符.js',
  '03-文件读取.js',
  '04-文件写入.js',
  '05-文件夹操作.js',
  'abc.txt',
  'loveZero'
]*/
</code></pre>
<p>递归遍历文件夹里的所有文件</p>
<pre><code class="js">const fs = require('fs');
const path = require('path');
const dirname = './loveZero';

function getFiles(dirname) {
  fs.readdir(dirname, { withFileTypes: true }, (err, files) =&gt; {
    for (let file of files) {
      if (file.isDirectory()) {
        const filepath = path.resolve(dirname, file.name);
        getFiles(filepath);
      } else {
        console.log(file.name);
      }
    }
  });
}

getFiles(dirname);
/*
aaa.txt
第二层aaa.txt
第三层aaa.txt
*/
</code></pre>
<h4 id="4-文件夹重命名"><a href="#4-文件夹重命名" class="headerlink" title="4.文件夹重命名"></a>4.文件夹重命名</h4><pre><code class="js">fs.rename('./oldName', './newName', err =&gt; {
  if (err) {
    console.error(err)
    return
  }
})
</code></pre>
<h4 id="5-文件夹删除"><a href="#5-文件夹删除" class="headerlink" title="5.文件夹删除"></a>5.文件夹删除</h4><p>安装<code>npm install fs-extra</code></p>
<pre><code class="js">const fs = require('fs-extra')

const folder = './newName'

fs.remove(folder, err =&gt; {
  console.error(err)
})
</code></pre>
<p>递归删除非空文件夹</p>
<pre><code class="js">function removeDir(dir) {
  let files = fs.readdirSync(dir)
  for (var i = 0; i &lt; files.length; i++) {
    let newPath = path.join(dir, files[i]);
    let stat = fs.statSync(newPath)
    if (stat.isDirectory()) {
      //如果是文件夹就递归下去
      removeDir(newPath);
    } else {
      //删除文件
      fs.unlinkSync(newPath);
    }
  }
  fs.rmdirSync(dir)//如果文件夹是空的，就将自己删除掉
}
removeDir(folder);
</code></pre>
<h2 id="三、events"><a href="#三、events" class="headerlink" title="三、events"></a>三、events</h2><h3 id="1-监听和触发事件"><a href="#1-监听和触发事件" class="headerlink" title="1.监听和触发事件"></a>1.监听和触发事件</h3><p><code>emitter.on</code>和<code>emitter.addListener</code>监听事件</p>
<p><code>emitter.emit</code>触发事件</p>
<p>addListener是on的别名，没什么区别</p>
<pre><code class="js">const EventEmitter = require("events");

// 创建发射器
const emitter = new EventEmitter();

// 监听某一个事件
// addListener是on的alias简写
emitter.on('click', (args) =&gt; {
  console.log("click事件on监听", args);
})

emitter.addListener('click', (args) =&gt; {
  console.log("click事件addListener监听", args);
})

setTimeout(() =&gt; {
  emitter.emit("click", "loveZero");
}, 1000);
</code></pre>
<h3 id="2-移除监听"><a href="#2-移除监听" class="headerlink" title="2.移除监听"></a>2.移除监听</h3><p><code>emitter.off</code>跟上对应的函数可以移除监听，<code>on</code>和<code>addListener</code>一样</p>
<pre><code class="js">const EventEmitter = require("events");

// 创建发射器
const emitter = new EventEmitter();

function onClick(args) {
  console.log("click事件on监听", args);
}
emitter.on('click', onClick)

function addListenerClick(args) {
  console.log("click事件addListener监听", args);

}
emitter.addListener('click', addListenerClick)

setTimeout(() =&gt; {
  emitter.emit("click", "loveZero");
  // emitter.off("click", onClick);
  // emitter.off("click", addListenerClick);
  emitter.emit("click", "loveZero");
}, 1000);
</code></pre>
<pre><code class="js">  // 移除所有对某一事件的监听
  emitter.removeAllListeners('click')
/*
click事件on监听 loveZero
click事件addListener监听 loveZero
*/
</code></pre>
<h3 id="3-获取事件信息"><a href="#3-获取事件信息" class="headerlink" title="3.获取事件信息"></a>3.获取事件信息</h3><pre><code class="js">const EventEmitter = require("events");

// 创建发射器
const emitter = new EventEmitter();

function onClick(args) {
  console.log("click事件on监听", args);
}
emitter.on('click', onClick)

function addListenerClick(args) {
  console.log("click事件addListener监听", args);
}
emitter.addListener('click', addListenerClick)

emitter.on('input', (args) =&gt; {
  console.log(args);
})

// 获取监听事件名
console.log(emitter.eventNames()); // [ 'click', 'input' ]
// 获取click事件监听的次数
console.log(emitter.listenerCount("click")); // 2
// 获取click事件监听函数
console.log(emitter.listeners("click")); // [ [Function: onClick], [Function: addListenerClick] ]
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa</title>
    <url>/2021/12/15/node-koa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h1><h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>初始化 <code>npm init -y</code><br>安装 <code>npm i koa</code></p>
<pre><code class="js">  const Koa = require('koa');

  const app = new Koa();

  app.use((ctx, next) =&gt; {
    ctx.response.body = "Hello World";
  });

  app.listen(8000, () =&gt; {
    console.log("服务器启动成功");
  });
</code></pre>
<h2 id="二、中间件"><a href="#二、中间件" class="headerlink" title="二、中间件"></a>二、中间件</h2><pre><code class="js">const Koa = require('koa');

const app = new Koa();

// use注册中间件
app.use((ctx, next) =&gt; {
  if (ctx.request.url === '/login') {
    if (ctx.request.method === 'GET') {
      ctx.response.body = "Login Success~";
    }
  } else {
    ctx.response.body = "other request~";
  }
});

app.listen(8000, () =&gt; {
  console.log("koa初体验服务器启动成功~");
});
</code></pre>
<h2 id="三、路由"><a href="#三、路由" class="headerlink" title="三、路由"></a>三、路由</h2><h3 id="1-安装库"><a href="#1-安装库" class="headerlink" title="1.安装库"></a>1.安装库</h3><p><code>npm install koa-router</code></p>
<h3 id="2-注册路由"><a href="#2-注册路由" class="headerlink" title="2.注册路由"></a>2.注册路由</h3><p>allowedMethods:用于判断某一个method是否支持</p>
<ul>
<li>路由中支持的请求就正常显示</li>
<li>请求 link、copy、lock，自动报错：Not Implemented，状态码：501；</li>
<li>请求 link、copy、lock，自动报错：Not Implemented，状态码：501；</li>
</ul>
<pre><code class="js">// user.js
const Router = require('koa-router');

const router = new Router({prefix: "/users"});

router.get('/', (ctx, next) =&gt; {
  ctx.response.body = "get request~";
});

router.post('/', (ctx, next) =&gt; {
  ctx.response.body = "post request~";
});


module.exports = router;


// index.js
const Koa = require('koa');

const userRouter = require('./router/user');

const app = new Koa();

app.use((ctx, next) =&gt; {
  next();
});

app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () =&gt; {
  console.log("koa路由服务器启动成功~");
});
</code></pre>
<h2 id="四、参数解析"><a href="#四、参数解析" class="headerlink" title="四、参数解析"></a>四、参数解析</h2><h3 id="1-params"><a href="#1-params" class="headerlink" title="1. params"></a>1. params</h3><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394499128141639449912805.png" alt="params"></p>
<p><code>http://localhost:8000/users/007</code></p>
<pre><code class="js">router.get('/:id', (ctx, next) =&gt; {
  console.log(ctx.request.params);
  ctx.response.body = ctx.request.params;
})
</code></pre>
<h3 id="2-query"><a href="#2-query" class="headerlink" title="2. query"></a>2. query</h3><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394499553561639449955347.png" alt="query"></p>
<pre><code class="js">router.get('/', (ctx, next) =&gt; {
  console.log(ctx.request.query);
  ctx.response.body = ctx.request.query;
});
</code></pre>
<h3 id="3-json和urlencoded"><a href="#3-json和urlencoded" class="headerlink" title="3. json和urlencoded"></a>3. json和urlencoded</h3><p>安装第三方库<code>npm i koa-bodyparser</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394509017231639450901714.png" alt="json"></p>
<pre><code class="js">const bodyParser = require('koa-bodyparser');

app.use(bodyParser());

app.use((ctx, next) =&gt; {
  console.log(ctx.request.body);
  ctx.response.body = ctx.request.body;
});
</code></pre>
<h3 id="4-formdata"><a href="#4-formdata" class="headerlink" title="4. formdata"></a>4. formdata</h3><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394512120051639451211996.png" alt="formdata"><br>安装<code>npm install koa-multer</code></p>
<pre><code class="js">const multer = require('koa-multer');

const upload = multer();

app.use(upload.any());

app.use((ctx, next) =&gt; {
  console.log(ctx.req.body);
  ctx.response.body = ctx.req.body;
});
</code></pre>
<h3 id="4-响应数据"><a href="#4-响应数据" class="headerlink" title="4. 响应数据"></a>4. 响应数据</h3><pre><code class="js">app.use((ctx, next) =&gt; {
  ctx.status = 404;
  ctx.body = "Hello Koa~";
});
</code></pre>
<h2 id="五、文件上传"><a href="#五、文件上传" class="headerlink" title="五、文件上传"></a>五、文件上传</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394521143481639452114339.png" alt="文件上传"></p>
<pre><code class="js">const Koa = require('koa');
const path = require('path');
const Router = require('koa-router');
const multer = require('koa-multer');

const app = new Koa();
const uploadRouter = new Router({prefix: '/upload'});

const storage = multer.diskStorage({
  destination: (req, file, cb) =&gt; {
    cb(null, './uploads/')
  },
  filename: (req, file, cb) =&gt; {
    cb(null, Date.now() + path.extname(file.originalname))
  }
})
const upload = multer({
  storage
});

// upload.single()里面的参数必须是传进来的文件名
uploadRouter.post('/avatar', upload.single('avatar'), (ctx, next) =&gt; {
  console.log(ctx.req.file);
  ctx.response.body = "上传头像成功~";
});

app.use(uploadRouter.routes());

app.listen(8000, () =&gt; {
  console.log("koa初体验服务器启动成功~");
});
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>http模块</title>
    <url>/2021/11/25/node-http-mo-kuai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h1><h2 id="一、http初体验"><a href="#一、http初体验" class="headerlink" title="一、http初体验"></a>一、http初体验</h2><pre><code class="js">// 引入http模块
const http = require('http')

// 创建http请求
const server = http.createServer((req, res) =&gt; {
  res.end('hello http')
})

// 监听http请求
server.listen(8888, 'localhost', () =&gt; {
  console.log('启动成功');
})
</code></pre>
<p>此时每次修改http请求，都需要重新运行代码，比较麻烦。可以借用工具<code>nodemon</code>实现自动监听</p>
<ol>
<li>安装<code>npm install -g nodemon</code></li>
<li>终端使用<code>nodemon</code>启动服务器<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16375729062861637572906278.png" alt="nodemon"></li>
</ol>
<h2 id="二、参数解析"><a href="#二、参数解析" class="headerlink" title="二、参数解析"></a>二、参数解析</h2><h3 id="1-创建服务器"><a href="#1-创建服务器" class="headerlink" title="1.创建服务器"></a>1.创建服务器</h3><ol>
<li><code>http.createServer</code>创建</li>
</ol>
<pre><code class="js">const server1 = http.createServer((req, res) =&gt; {
  res.end('server1')
})

server1.listen(8000, 'localhost', () =&gt; {
  console.log('server1启动成功');
})
</code></pre>
<ol start="2">
<li><code>new http.Server</code>创建</li>
</ol>
<pre><code class="js">const server2 = new http.Server((req, res) =&gt; {
  res.end('server2')
})
server2.listen(8001, 'localhost', () =&gt; {
  console.log('server2启动成功');
})
</code></pre>
<h3 id="2-listen参数"><a href="#2-listen参数" class="headerlink" title="2.listen参数"></a>2.listen参数</h3><ol>
<li>端口port:可以不传，系统会默认分配端口，通常会写入到环境变量中；</li>
<li>主机host通常可以传入 localhost、ip地址127.0.0.1、或者ip地址0.0.0.0,默认是0.0.0.0<ol>
<li>localhost:本质上是一个域名，通常情况下会被解析成127.0.0.1;</li>
<li>127.0.0.1:回环地址,表达的意思其实是主机自己发出去的包，直接被自己接收<ul>
<li>在网络层直接就被获取到了，是不会经常数据链路层和物理层的</li>
<li>监听127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的；</li>
</ul>
</li>
<li>0.0.0.0<ul>
<li>监听IPV4上所有的地址，再根据端口找到不同的应用程序</li>
<li>监听0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的</li>
</ul>
</li>
</ol>
</li>
<li>回调函数：服务器启动成功时的回调函数</li>
</ol>
<h3 id="3-request对象"><a href="#3-request对象" class="headerlink" title="3.request对象"></a>3.request对象</h3><p>request对象中封装了客户端给我们服务器传递过来的所有信息</p>
<pre><code class="js">const server = http.createServer((req, res) =&gt; {
  console.log('req.url', req.url);
  console.log('req.method', req.method);
  console.log('req.headers', req.headers);
  res.end('server')
})
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376533698081637653369780.png" alt="request对象"><br>![request对象post](<a href="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/163765359097616376535909">https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/163765359097616376535909</a><br>  // 直接打印  /login?name=loveZero&amp;password=666<br>  console.log(‘req.url’, req.url);<br>      // 直接打印  /login?name=loveZero&amp;password=666<br>      console.log(‘req.url’, req.url);</p>
<pre><code>
2. url.parse和qs.parse

通过url.parse可以得到pathname和query
解析方便，但是现在已废弃

```js
  const url = require('url')
  const qs = require('querystring')
  const server = http.createServer((req, res) =&gt; {
 console.log('url.parse', url.parse(req.url));
 const { query } = url.parse(req.url);
 if (url.parse(req.url).pathname === '/login') {
   const { username, password } = qs.parse(query);
   console.log(username, password);
 }
  })
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376551274871637655127477.png" alt="url.parse"></p>
<ol start="3">
<li>通过URL实例</li>
</ol>
<pre><code class="js">// 通过URL实例能得到pathname和searchParams
const baseURL = req.protocol + '://' + req.headers.host + '/';
const reqUrl = new URL(req.url, baseURL);
console.log('reqUrl', reqUrl);
const { pathname, searchParams } = reqUrl
if (pathname === '/login') {
  console.log(searchParams.get('name'), searchParams.get('password'));
  res.end("请求结果~");
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16376552102891637655210281.png" alt="URL实例"></p>
<h4 id="3-2-request-method"><a href="#3-2-request-method" class="headerlink" title="3.2 request.method"></a>3.2 request.method</h4><p>通过<code>method</code>判断是否是POST请求，可以拿到请求中的<code>body</code></p>
<pre><code class="js">// 引入http模块
const http = require('http')

// 创建http请求
const server = http.createServer((req, res) =&gt; {
  // 通过URL实例能得到pathname和searchParams
  const baseURL = req.protocol + '://' + req.headers.host + '/';
  const reqUrl = new URL(req.url, baseURL);
  if (reqUrl.pathname === '/login') {
    if (req.method === 'POST') {
      req.setEncoding('utf-8');
      req.on('data', (data) =&gt; {
        console.log('%cdata: ', 'color: #58e2ba;', data);
        const { name, password } = JSON.parse(data);
        console.log(name, password);
      });
      res.end("请求结果~");
    }
  }
})

server.listen(8000, 'localhost', () =&gt; {
  console.log('server启动成功');
})
</code></pre>
<h4 id="3-3-request-headers"><a href="#3-3-request-headers" class="headerlink" title="3.3 request.headers"></a>3.3 request.headers</h4><ul>
<li><p>content-type是这次请求携带的数据的类型</p>
<ul>
<li>application/json表示是一个json类型；</li>
<li>text/plain表示是文本类型；</li>
<li>application/xml表示是xml类型；</li>
<li>multipart/form-data表示是上传文件</li>
</ul>
</li>
<li><p>content-length：文件的大小和长度</p>
</li>
<li><p>keep-alive：</p>
<ul>
<li>http是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；</li>
<li>在http1.0中，如果想要继续保持连接：<ul>
<li>浏览器需要在请求头中添加 connection: keep-alive；</li>
<li>服务器需要在响应头中添加 connection:keey-alive；</li>
<li>当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；</li>
</ul>
</li>
<li>在http1.1中，所有连接默认是 connection: keep-alive的；<ul>
<li>不同的Web服务器会有不同的保持 keep-alive的时间；</li>
<li>Node中默认是5s中；</li>
</ul>
</li>
</ul>
</li>
<li><p>accept-encoding：告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件；</p>
</li>
<li><p>accept：告知服务器，客户端可接受文件的格式类型；</p>
</li>
<li><p>user-agent：客户端相关的信息；<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16377347724631637734772452.png" alt="headers"><br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16377347724631637734772452.png" alt="headers"></p>
</li>
</ul>
<h3 id="4-response对象"><a href="#4-response对象" class="headerlink" title="4.response对象"></a>4.response对象</h3><h4 id="4-1-响应结果"><a href="#4-1-响应结果" class="headerlink" title="4.1 响应结果"></a>4.1 响应结果</h4><ul>
<li>Write方法：这种方式是直接写出数据，但是并没有关闭流；</li>
<li>end方法：这种方式是写出最后的数据，并且写出后会关闭流；</li>
</ul>
<pre><code class="js">  res.write("响应结果一");
  res.end("Hello World");
</code></pre>
<h4 id="4-2-响应状态码"><a href="#4-2-响应状态码" class="headerlink" title="4.2 响应状态码"></a>4.2 响应状态码</h4><p>方式一: 直接给属性赋值</p>
<pre><code class="js">  res.statusCode = 400;
</code></pre>
<p>方式二: 和Head一起设置</p>
<pre><code class="js">  res.writeHead(503)
</code></pre>
<h4 id="4-3-响应头文件"><a href="#4-3-响应头文件" class="headerlink" title="4.3 响应头文件"></a>4.3 响应头文件</h4><p>方式一:setHeader<br>一次写入一个头部信息</p>
<pre><code class="js"> res.setHeader("Content-Type", "text/plain;charset=utf8");
</code></pre>
<p>方式二：writeHead<br>同时写入header和status</p>
<pre><code class="js">  res.writeHead(200, {
      "Content-Type": "text/html;charset=utf8"
    });
</code></pre>
<h2 id="3-发送请求"><a href="#3-发送请求" class="headerlink" title="3.发送请求"></a>3.发送请求</h2><h3 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h3><pre><code class="js">http.get('http://localhost:8000', res =&gt; {
  res.on('data', (data) =&gt; {
    console.log(data.toString());
  });
  res.on('end', () =&gt; {
    console.log("获取到了所有的结果");
  })
})
</code></pre>
<h3 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h3><pre><code class="js">const req = http.request({
  method: 'POST',
  hostname: 'localhost',
  port: 8000
}, (res) =&gt; {
  res.on('data', (data) =&gt; {
    console.log(data.toString());
  });

  res.on('end', () =&gt; {
    console.log("获取到了所有的结果");
  })
});

req.end();
</code></pre>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>React-setState</title>
    <url>/2021/12/15/react-setstate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><h2 id="一、为什么使用-setState"><a href="#一、为什么使用-setState" class="headerlink" title="一、为什么使用 setState"></a>一、为什么使用 setState</h2><p>1.因为直接修改 state 的值 React 并不知道数据发生了变化，必须通过 setState 来告知 React 数据已发生变化<br>2.setState 方法是从 Component 中继承过来的<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394936635791639493663574.png" alt="为什么使用 setState"></p>
<h2 id="二、setState-时候异步还是同步"><a href="#二、setState-时候异步还是同步" class="headerlink" title="二、setState 时候异步还是同步"></a>二、setState 时候异步还是同步</h2><ul>
<li>在组件生命周期或 React 合成事件中，setState 是异步；</li>
<li>在 setTimeout 或者原生 dom 事件中，setState 是同步；</li>
</ul>
<h3 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h3><p>通过 setState 改变数据后打印该数据，发现页面数据发生了改变，但打印的仍然是改变之前的数据，可见 setState 是异步的操作，我们并不能在执行完 setState 之后立马拿到最新的 state 的结果</p>
<pre><code class="js">import React, { Component } from 'react'

export default class App extends Component {
  constructor (props) {
    super(props)

    this.state = {
      message: 'Hello World'
    }
  }

  render () {
    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.message}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.changeText()}&gt;改变文本&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  changeText () {
    this.setState({
      message: '你好'
    })
    console.log(this.state.message)
  }
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394938250681639493825066.png" alt="异步"></p>
<h4 id="1-1-为什么是异步？"><a href="#1-1-为什么是异步？" class="headerlink" title="1.1 为什么是异步？"></a>1.1 为什么是异步？</h4><p><strong>提升性能</strong></p>
<ul>
<li>如果每次调用 setState 都进行一次更新，那么 render 函数会被频繁调用，界面重新渲染，这样效率非常低，最好的办法应该是获取到多个更新，之后进行批量更新</li>
<li>如果同步更新了 state，但是还没有执行 render 函数，那么 state 和 props 不能保持同步</li>
</ul>
<h4 id="1-2-如何拿到异步-setState-结果"><a href="#1-2-如何拿到异步-setState-结果" class="headerlink" title="1.2 如何拿到异步 setState 结果"></a>1.2 如何拿到异步 setState 结果</h4><p>方法一：setState 第二个参数传入回调函数，这个回调函数会在更新后会执行</p>
<pre><code class="js">  changeText () {
    this.setState(
      {
        message: '你好'
      },
      e =&gt; {
        console.log(this.state.message)
      }
    )
  }
</code></pre>
<p>方法二：componentDidUpdate 生命周期中获取</p>
<pre><code class="js">  componentDidUpdate () {
    // 方式二: 获取异步更新的state
    console.log(this.state.message)
  }
</code></pre>
<h3 id="2-同步"><a href="#2-同步" class="headerlink" title="2.同步"></a>2.同步</h3><h4 id="2-1-将-setState-放入到定时器中"><a href="#2-1-将-setState-放入到定时器中" class="headerlink" title="2.1 将 setState 放入到定时器中"></a>2.1 将 setState 放入到定时器中</h4><pre><code class="js"> changeText () {
    setTimeout(() =&gt; {
      this.setState({
        message: '你好'
      })
      console.log(this.state.message)
    }, 0)
  }
</code></pre>
<h4 id="2-2-原生事件中"><a href="#2-2-原生事件中" class="headerlink" title="2.2 原生事件中"></a>2.2 原生事件中</h4><pre><code class="js">  render () {
    return (
      &lt;div&gt;
        &lt;button id='btn'&gt;改变文本&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  componentDidMount () {
    document.getElementById('btn').addEventListener('click', e =&gt; {
      this.setState({/
        message: '你好'
      })
      console.log(this.state.message)
    })
  }
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP环境搭建</title>
    <url>/2021/09/09/php-huan-jing-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PHP环境"><a href="#PHP环境" class="headerlink" title="PHP环境"></a>PHP环境</h1><h2 id="1-安装-phpStudy-Pro"><a href="#1-安装-phpStudy-Pro" class="headerlink" title="1.安装 phpStudy-Pro"></a>1.安装 phpStudy-Pro</h2><h2 id="2-开启-apache-服务"><a href="#2-开启-apache-服务" class="headerlink" title="2.开启 apache 服务"></a>2.开启 apache 服务</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629818261421-1629818261416.png"></p>
<h2 id="3-新建网页"><a href="#3-新建网页" class="headerlink" title="3.新建网页"></a>3.新建网页</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629818298407-1629818298398.png"></p>
<h2 id="4-修改-host"><a href="#4-修改-host" class="headerlink" title="4.修改 host"></a>4.修改 host</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629818345032-1629818345028.png"></p>
<h2 id="5-在域名的根目录下新建-index-php-文件"><a href="#5-在域名的根目录下新建-index-php-文件" class="headerlink" title="5.在域名的根目录下新建 index.php 文件"></a>5.在域名的根目录下新建 index.php 文件</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629818366252-1629818366250.png"></p>
<h2 id="6-用本机浏览器访问域名"><a href="#6-用本机浏览器访问域名" class="headerlink" title="6.用本机浏览器访问域名"></a>6.用本机浏览器访问域名</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629818374225-1629818374220.png"></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>React基础</title>
    <url>/2021/11/25/react-ji-chu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="一、HelloReact"><a href="#一、HelloReact" class="headerlink" title="一、HelloReact"></a>一、HelloReact</h2><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h3><p>需要依赖3个包</p>
<ul>
<li>react：包含react所必须的核心代码</li>
<li>react-dom：react渲染在不同平台所需要的核心代码<ul>
<li>web端：react-dom会讲jsx最终渲染成真实的DOM，显示在浏览器中</li>
<li>native端：react-dom会讲jsx最终渲染成原生的控件（比如Android中的Button，iOS中的UIButton）</li>
</ul>
</li>
<li>babel：将jsx转换成React代码的工具<ul>
<li>使用ES6来编写源码，之后通过Babel工具，将ES6转成大多数浏览器都支持的ES5的语法</li>
</ul>
</li>
</ul>
<p><strong>方式一：CDN引入</strong></p>
<pre><code class="js">  &lt;!-- 添加React的依赖 --&gt;
  &lt;script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt;
</code></pre>
<p><strong>方式二：下载后本地依赖</strong></p>
<p><strong>方式三：使用npm管理</strong></p>
<h3 id="2-hello-react"><a href="#2-hello-react" class="headerlink" title="2.hello-react"></a>2.hello-react</h3><p><strong>原生实现</strong></p>
<pre><code class="html">  &lt;h2 id="text"&gt;&lt;/h2&gt;
  &lt;button id="btn"&gt;改变文本&lt;/button&gt;

  &lt;script&gt;
    // 命令式编程：每做一个操作都是给计算机一个命令
    // 1.定义数据
    let message = 'Hello World'

    // 2.将数据显示h2元素中
    const textEl = document.getElementById("text")
    text.innerText = message

    // 3.点击按钮，改变页面数据
    const btnEl = document.getElementById("btn")
    btnEl.addEventListener('click', () =&gt; {
      message = 'Hello React'
      textEl.innerText = message
    })

  &lt;/script&gt;
</code></pre>
<p><strong>React实现</strong></p>
<ol>
<li>编写React的script代码中，必须添加 type=”text/babel”，作用是可以让babel解析jsx语法</li>
<li>ReactDOM.render函数<ul>
<li>第一个参数是要渲染的内容，这个内容可以是HTML元素，也可以是React的组件</li>
<li>第二个参数是将渲染的内容，挂载到哪一个HTML元素上</li>
</ul>
</li>
</ol>
<pre><code class="html">  &lt;div id="box"&gt;box&lt;/div&gt;
  &lt;!-- 添加React的依赖 --&gt;
  &lt;script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt;
  &lt;!-- babel --&gt;
  &lt;script type="text/babel"&gt;
    let msg = "Hello World";

    function btnClick() {
      msg = "Hello React";
      console.log(msg);
      render();
    }
    function render() {
      ReactDOM.render(
        &lt;div&gt;
          &lt;h2&gt;{msg}&lt;/h2&gt;
          &lt;button onClick={btnClick}&gt;改变文本&lt;/button&gt;
        &lt;/div&gt;,
        document.getElementById("box")
      );
    }

    render();
  &lt;/script&gt;
</code></pre>
<p><strong>组件化HelloReact</strong></p>
<ol>
<li>定义一个类继承自React.Component</li>
<li>类中有一个render函数，返回jsx内容</li>
<li>数据依赖<ol>
<li>参与界面更新的数据（参与数据流）：当数据变量时，需要更新组件渲染的内容<ol>
<li>定义在state对象中</li>
<li>当数据变化时需要调用<code>this.setState</code>来变更数据</li>
</ol>
</li>
<li>不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容</li>
</ol>
</li>
<li>事件绑定<ol>
<li>click触发时，this是undefined。因为React渲染的不是真实DOM,其中button实际上市react的Element对象，所以触发时this时undefined</li>
<li>解决：可以通过<code>bind</code>改变this指向</li>
</ol>
</li>
</ol>
<pre><code class="html">  &lt;script type="text/babel"&gt;
  // 封装组件
  class App extends React.Component {
    constructor() {
      super()
      this.state = {
        message: "HelloWorld"
      }
    }

    render() {
      return (
        &lt;div&gt;
          &lt;h2&gt;{this.state.message}&lt;/h2&gt;
          &lt;button onClick={this.btnClick.bind(this)}&gt;改变文本&lt;/button&gt;
        &lt;/div&gt;
      )
    }

    btnClick() {
      // setState改变后，才会重新渲染
      this.setState({
        message: "HelloReact"
      })
    }
  }

  // 渲染组件
  ReactDOM.render(&lt;App /&gt;, document.getElementById("app"))
&lt;/script&gt;
</code></pre>
<h2 id="二、JSX语法"><a href="#二、JSX语法" class="headerlink" title="二、JSX语法"></a>二、JSX语法</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><p><code>{/*注释*/}</code></p>
<pre><code class="jsx">      render() {
        return (
          &lt;div&gt;
            {/*注释*/}
          &lt;/div&gt;
        )
      }
</code></pre>
<h3 id="2-嵌入数据"><a href="#2-嵌入数据" class="headerlink" title="2.嵌入数据"></a>2.嵌入数据</h3><pre><code class="js">    class App extends React.Component {
      constructor() {
        super()
        this.state = {
          // 1.可以正常显示
          name: 'loveZero',// String
          age: 18,//Number
          list: [1, 2, 'asdf', 'abc'],//Array
          // 2.不显示
          test1: null,
          test2: undefined,
          bool: true,
          // 3.对象不能作为jsx的子类
          obj: {
            id: '007'
          }
        }
      }

      render() {
        return (
          &lt;div&gt;
            {/*可以正常显示*/}
            &lt;h2&gt;{this.state.name}&lt;/h2&gt;
            &lt;h2&gt;{this.state.age}&lt;/h2&gt;
            &lt;h2&gt;{this.state.list}&lt;/h2&gt;
            {/*不显示*/}
            &lt;h2&gt;{this.state.test1}&lt;/h2&gt;
            &lt;h2&gt;{this.state.test2}&lt;/h2&gt;
            &lt;h2&gt;{this.state.bool}&lt;/h2&gt;
            {/*可以通过转为字符串让其渲染*/}
            &lt;h2&gt;{this.state.test1 + ''}&lt;/h2&gt;
            &lt;h2&gt;{this.state.test2 + ''}&lt;/h2&gt;
            &lt;h2&gt;{this.state.bool.toString()}&lt;/h2&gt;
            {/*对象不能作为jsx的子类*/}
            {/*&lt;h2&gt;{this.state.obj}&lt;/h2&gt;*/}
          &lt;/div&gt;
        )
      }
    }
</code></pre>
<h3 id="3-嵌入表达式"><a href="#3-嵌入表达式" class="headerlink" title="3.嵌入表达式"></a>3.嵌入表达式</h3><pre><code class="js">  {/*1.运算符表达式*/}
  &lt;h2&gt;{name + " " + age}&lt;/h2&gt;
  &lt;h2&gt;{20 * 50}&lt;/h2&gt;

  {/*2.三元表达式*/}
  &lt;h2&gt;{bool ? "真~" : "假~"}&lt;/h2&gt;

  {/*3.进行函数调用*/}
  &lt;h2&gt;{this.addNum()}&lt;/h2&gt;
</code></pre>
<h3 id="4-绑定属性"><a href="#4-绑定属性" class="headerlink" title="4.绑定属性"></a>4.绑定属性</h3><pre><code class="jsx">  &lt;img src={imgUrl} /&gt;
  &lt;a href={linkUrl}&gt;百度&lt;/a&gt;
  &lt;label htmlFor=""&gt;&lt;/label&gt;
</code></pre>
<h3 id="5-绑定class"><a href="#5-绑定class" class="headerlink" title="5.绑定class"></a>5.绑定class</h3><pre><code class="jsx">  &lt;div className="box"&gt;box1&lt;/div&gt;
  {/*动态绑定class*/}
  &lt;div className={"box " + (active &amp;&amp; "active")}&gt;box2&lt;/div&gt;
</code></pre>
<h3 id="6-绑定style"><a href="#6-绑定style" class="headerlink" title="6.绑定style"></a>6.绑定style</h3><pre><code class="jsx">  &lt;div style={{ color: 'red', fontWeight: 700 }}&gt;绑定style&lt;/div&gt;
</code></pre>
<h3 id="7-绑定事件"><a href="#7-绑定事件" class="headerlink" title="7.绑定事件"></a>7.绑定事件</h3><p>通过箭头函数来解决<code>this</code>指向</p>
<pre><code class="jsx">    class App extends React.Component {
      constructor() {
        super()
        this.state = {
          list: ["大话西游", "海王", "流浪地球", "盗梦空间"]
        }
      }

      render() {
        const { list } = this.state
        return (
          &lt;div&gt;
            &lt;ul&gt;
              {
                list.map((item, index) =&gt; {
                  return (
                    &lt;li className="li"
                      style={{ color: 'red' }}
                      onClick={e =&gt; { this.liClick(item, index, e) }}&gt;
                      {item}
                    &lt;/li&gt;
                  )
                })
              }
            &lt;/ul&gt;
          &lt;/div&gt;
        )
      }
      liClick(item, index, e) {
        console.log(this);
        console.log(item);
        console.log(index);
        console.log(e);
      }
    }
</code></pre>
<h3 id="8-条件渲染"><a href="#8-条件渲染" class="headerlink" title="8.条件渲染"></a>8.条件渲染</h3><p>方式一：通过<code>if</code>控制</p>
<pre><code class="jsx">    class App extends React.Component {
      constructor() {
        super()
        this.state = {
          login: true
        }
      }

      render() {
        let message = null
        let btnText = null
        if (this.state.login) {
          message = '您已登录'
          btnText = '退出'
        } else {
          message = '请先登录'
          btnText = '登录'
        }
        return (
          &lt;div&gt;
            &lt;h2&gt;{message}&lt;/h2&gt;
            &lt;button onClick={e =&gt; this.btnClick()}&gt;{btnText}&lt;/button&gt;
            &lt;hr /&gt;
            &lt;div&gt;{this.state.login &amp;&amp; '欢迎'}&lt;/div&gt;
          &lt;/div &gt;
        )
      }
      btnClick() {
        this.setState({
          login: !this.state.login
        })
      }
    }
</code></pre>
<p>方式二：通过控制<code>display</code>,类似<code>v-show</code></p>
<pre><code class="jsx">    class App extends React.Component {
      constructor(props) {
        super(props);

        this.state = {
          isLogin: true
        }
      }

      render() {
        const { isLogin } = this.state;
        const titleDisplayValue = isLogin ? "block" : "none";
        return (
          &lt;div&gt;
            &lt;button onClick={e =&gt; this.loginClick()}&gt;{isLogin ? "退出" : "登录"}&lt;/button&gt;
            &lt;h2 style={{ display: titleDisplayValue }}&gt;你好&lt;/h2&gt;
          &lt;/div&gt;
        )
      }

      loginClick() {
        this.setState({
          isLogin: !this.state.isLogin
        })
      }
    }
</code></pre>
<h3 id="9-列表渲染"><a href="#9-列表渲染" class="headerlink" title="9.列表渲染"></a>9.列表渲染</h3><p>通过es6函数渲染</p>
<pre><code class="jsx">      render() {
        return (
          &lt;div&gt;
            {/*1.全部渲染*/}
            &lt;h2&gt;全部渲染&lt;/h2&gt;
            &lt;ul&gt;
              {
                this.state.list.map(item =&gt; &lt;li&gt;{item}&lt;/li&gt;)
              }
            &lt;/ul&gt;
            {/*2.渲染大于50的*/}
            &lt;h2&gt;渲染大于50&lt;/h2&gt;
            &lt;ul&gt;
              {
                this.state.list.filter(item =&gt; item &gt; 50).map(item =&gt; &lt;li&gt;{item}&lt;/li&gt;)
              }
            &lt;/ul&gt;
            {/*3.渲染前4条*/}
            &lt;h2&gt;渲染前4条&lt;/h2&gt;
            &lt;ul&gt;
              {
                this.state.list.slice(0, 4).map(item =&gt; &lt;li&gt;{item}&lt;/li&gt;)
              }
            &lt;/ul&gt;
          &lt;/div&gt;
        )
      }
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件</title>
    <url>/2021/12/15/react-zu-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React-组件化开发"><a href="#React-组件化开发" class="headerlink" title="React 组件化开发"></a>React 组件化开发</h1><h1 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h1><h2 id="1-安装脚手架"><a href="#1-安装脚手架" class="headerlink" title="1.安装脚手架"></a>1.安装脚手架</h2><p><code>npm i -g create-react-app</code></p>
<h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><p><code>create-react-app 项目名称</code></p>
<h2 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16390558348691639055834863.png" alt="目录结构"></p>
<h1 id="二、组件"><a href="#二、组件" class="headerlink" title="二、组件"></a>二、组件</h1><h2 id="1-组件的定义方式"><a href="#1-组件的定义方式" class="headerlink" title="1.组件的定义方式"></a>1.组件的定义方式</h2><h3 id="1-1-类组件"><a href="#1-1-类组件" class="headerlink" title="1.1 类组件"></a>1.1 类组件</h3><p>特点：</p>
<ul>
<li>需要注意 this 指向</li>
<li>组件的名称是大写字符开头</li>
<li>需要继承自 React.Component</li>
<li>必须实现 render 函数</li>
</ul>
<pre><code class="js">export default class App extends Component {
  // constructor可选，通常用来初始化数据
  constructor () {
    super()
    // 储存组件内部的数据
    this.state = {
      message: 'Hello'
    }
  }
  // 必须
  render () {
    return &lt;h2&gt;{this.state.message}&lt;/h2&gt;
  }
}
</code></pre>
<h3 id="1-2-函数组件"><a href="#1-2-函数组件" class="headerlink" title="1.2 函数组件"></a>1.2 函数组件</h3><p>特点：</p>
<ul>
<li>没有 this</li>
<li>没有内部状态（state）</li>
<li>会被更新并挂载，但没有生命周期函数</li>
</ul>
<pre><code class="js">export default function App () {
  return (
    &lt;div&gt;
      &lt;h2&gt;Hello&lt;/h2&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="1-3-组件-render-返回值"><a href="#1-3-组件-render-返回值" class="headerlink" title="1.3 组件 render 返回值"></a>1.3 组件 render 返回值</h3><ul>
<li>React 元素：通过 JSX 创建</li>
<li>数组或 fragments：使得 render 方法可以返回多个元素。</li>
</ul>
<pre><code class="js">render () {
    return [&lt;h2&gt;Hello&lt;/h2&gt;, &lt;h2&gt;Hello&lt;/h2&gt;]
  }
</code></pre>
<ul>
<li>Portals：可以渲染子节点到不同的 DOM 子树中。</li>
<li>字符串或数值类型：它们在 DOM 中会被渲染为文本节点</li>
<li>布尔类型或 null：什么都不渲染。</li>
</ul>
<h2 id="2-组件的生命周期"><a href="#2-组件的生命周期" class="headerlink" title="2.组件的生命周期"></a>2.组件的生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16393111158731639311115869.png" alt="组件的生命周期"></p>
<h3 id="2-1-挂载时"><a href="#2-1-挂载时" class="headerlink" title="2.1 挂载时"></a>2.1 挂载时</h3><p>执行顺序：constructor-&gt;render-&gt;componentDidMount 方法</p>
<pre><code class="js">import React, { Component } from 'react'

export default class Cycle extends Component {
  constructor () {
    console.log('constructor')
    super()
  }
  render () {
    console.log('render')
    return &lt;div&gt;Cycle&lt;/div&gt;
  }

  componentDidMount () {
    console.log('componentDidMount方法')
  }
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16393112077011639311207700.png" alt="挂载时"></p>
<p><strong>constructor</strong></p>
<ul>
<li>如果不初始化 state 或不进行方法绑定，则不需要 constructor</li>
<li>作用<ul>
<li>初始化内部的 state</li>
<li>为事件绑定实例 this</li>
</ul>
</li>
</ul>
<p><strong>componentDidMount 方法</strong></p>
<ul>
<li>会在组件挂载后（插入 DOM 树中）立即调用，依赖于 DOM 的操作可以在这里进行</li>
<li>发送网络请求最好的地方</li>
<li>可以在此处添加一些订阅（会在 componentWillUnmount 取消订阅）</li>
</ul>
<h3 id="2-2-更新时"><a href="#2-2-更新时" class="headerlink" title="2.2 更新时"></a>2.2 更新时</h3><p>执行顺序：render-&gt;componentDidUpdate 方法</p>
<pre><code class="js">import React, { Component } from 'react'

export default class Cycle extends Component {
  constructor () {
    super()

    this.state = {
      counter: 0
    }
  }
  render () {
    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;hr /&gt;
      &lt;/div&gt;
    )
  }
  increment () {
    this.setState({ counter: this.state.counter + 1 })
  }

  componentDidUpdate (prevProps, prevState, snapshot) {
    console.log('componentDidUpdate方法')
  }
}
</code></pre>
<p><strong>componentDidUpdate</strong></p>
<ul>
<li>会在更新后会被立即调用，首次渲染不会执行此方法</li>
<li>当组件更新后，可以在此处对 DOM 进行操作</li>
<li>如果对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</li>
</ul>
<h3 id="2-2-卸载时"><a href="#2-2-卸载时" class="headerlink" title="2.2 卸载时"></a>2.2 卸载时</h3><pre><code class="js">import React, { Component } from 'react'
class Son extends Component {
  render () {
    return &lt;h2&gt;我是Son组件&lt;/h2&gt;
  }

  componentWillUnmount () {
    console.log('调用了Son的componentWillUnmount方法')
  }
}

export default class Cycle extends Component {
  constructor () {
    super()

    this.state = {
      isShow: true
    }
  }
  render () {
    console.log('render')
    return (
      &lt;div&gt;
        Cycle
        &lt;button onClick={e =&gt; this.changeCpnShow()}&gt;切换&lt;/button&gt;
        {this.state.isShow &amp;&amp; &lt;Son&gt;&lt;/Son&gt;}
      &lt;/div&gt;
    )
  }

  changeCpnShow () {
    this.setState({ isShow: !this.state.isShow })
  }

  componentDidUpdate (prevProps, prevState, snapshot) {
    console.log('componentDidUpdate方法')
  }
}
</code></pre>
<p><strong>componentWillUnmount 方法</strong></p>
<ul>
<li>会在组件卸载及销毁之前直接调用</li>
<li>在此方法中执行必要的清理操作：清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等</li>
</ul>
<h2 id="3-组件通讯"><a href="#3-组件通讯" class="headerlink" title="3.组件通讯"></a>3.组件通讯</h2><h3 id="3-1-父子通讯"><a href="#3-1-父子通讯" class="headerlink" title="3.1 父子通讯"></a>3.1 父子通讯</h3><p>父组件通过 属性=值 的形式来传递给子组件数据，子组件通过 props 参数获取父组件传递过来的数据</p>
<pre><code class="js">import React, { Component } from 'react'

// 类组件
class ChildCpn extends Component {
  componentDidMount () {
    console.log(this.props, 'componentDidMount')
  }

  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return &lt;h2&gt;子组件展示数据: {name + ' ' + age + ' ' + height}&lt;/h2&gt;
  }
}

// 函数组件
function ChildFun (props) {
  const { name, age, height } = props
  return &lt;h2&gt;子组件展示数据: {name + ' ' + age + ' ' + height}&lt;/h2&gt;
}

// 父组件
export default class Son extends Component {
  render () {
    return (
      &lt;div&gt;
        &lt;ChildCpn name='loveZero' age='18' height='1.58' /&gt;
        &lt;ChildCpn name='千玺' age='20' height='1.78' /&gt;
        &lt;ChildFun name='loveZero' age='18' height='1.58' /&gt;
        &lt;ChildFun name='千玺' age='20' height='1.78' /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h4 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h4><p>用于属性验证和默认值<br><a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html">官网</a></p>
<pre><code class="js">import React, { Component } from 'react'
import PropTypes from 'prop-types'
// 类组件
class ChildCpn extends Component {
  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return &lt;h2&gt;子组件展示数据: {name + ' ' + age + ' ' + height}&lt;/h2&gt;
  }
}
// 属性验证
ChildCpn.propTypes = {
  // 字符串类型，必填
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  height: PropTypes.string
}

// 默认值
ChildCpn.defaultProps = {
  name: 'loveZero',
  age: 18,
  height: '1.58'
}

// 父组件
export default class Son extends Component {
  render () {
    return (
      &lt;div&gt;
        &lt;ChildCpn name='loveZero' age={18} height='1.58' /&gt;
        &lt;ChildCpn name='千玺' age={20} height='1.78' /&gt;
        &lt;ChildCpn /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>类组件的属性验证和默认值写法二</p>
<pre><code class="js">class ChildCpn extends Component {
  // es6中的class fields写法
  static propTypes = {
    // 字符串类型，必填
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    height: PropTypes.string
  }

  static defaultProps = {
    name: 'loveZero',
    age: 18,
    height: '1.58'
  }
  render () {
    // 通过this.props拿到父组件传来的数据
    const { name, age, height } = this.props
    return &lt;h2&gt;子组件展示数据: {name + ' ' + age + ' ' + height}&lt;/h2&gt;
  }
}
</code></pre>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><pre><code class="js">class CounterButton extends Component {
  render () {
    const { onClick } = this.props
    return &lt;button onClick={onClick}&gt;+1&lt;/button&gt;
  }
}

// 父组件
export default class Son extends Component {
  constructor () {
    super()
    this.state = {
      num: 0
    }
  }
  render () {
    return (
      &lt;div&gt;
        &lt;button
          onClick={e =&gt; {
            this.numClick()
          }}
        &gt;
          +
        &lt;/button&gt;
        &lt;h2&gt;{this.state.num}&lt;/h2&gt;
        &lt;CounterButton
          onClick={e =&gt; {
            this.numClick()
          }}
        /&gt;
      &lt;/div&gt;
    )
  }
  numClick () {
    this.setState({
      num: this.state.num + 1
    })
  }
}
</code></pre>
<h3 id="3-2-跨组件通讯"><a href="#3-2-跨组件通讯" class="headerlink" title="3.2 跨组件通讯"></a>3.2 跨组件通讯</h3><h4 id="3-2-1-props"><a href="#3-2-1-props" class="headerlink" title="3.2.1 props"></a>3.2.1 props</h4><p>使用 props 属性展开<br><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/16394080416551639408041652.png" alt="props"></p>
<pre><code class="js">import React, { Component } from 'react'

function Sun (props) {
  return (
    &lt;div&gt;
      &lt;h2&gt;用户昵称: {props.nickname}&lt;/h2&gt;
      &lt;h2&gt;用户等级: {props.level}&lt;/h2&gt;
    &lt;/div&gt;
  )
}

function Son (props) {
  return (
    &lt;div&gt;
      &lt;Sun {...props} /&gt;
      &lt;ul&gt;
        &lt;li&gt;设置1&lt;/li&gt;
        &lt;li&gt;设置2&lt;/li&gt;
        &lt;li&gt;设置3&lt;/li&gt;
        &lt;li&gt;设置4&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      &lt;div&gt;
        &lt;Son {...this.state} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h4 id="3-2-2-context"><a href="#3-2-2-context" class="headerlink" title="3.2.2 context"></a>3.2.2 context</h4><p><strong>1.创建 context</strong></p>
<pre><code class="js">const UserContext = React.createContext({ 默认值 })
</code></pre>
<p><strong>2.父组件中使用</strong></p>
<pre><code class="js">&lt;UserContext.Provider value={this.state}&gt;
  &lt;Son /&gt;
&lt;/UserContext.Provider&gt;
</code></pre>
<p><strong>3.后续组件中绑定</strong></p>
<pre><code class="js">Sun.contextType = UserContext
</code></pre>
<p><code>React.createContext</code></p>
<ul>
<li>创建一个 context 对象</li>
<li>会离自身最近开始匹配的 Provider 中读取 context 值</li>
<li>如果没找到 Provider 就会使用默认值</li>
</ul>
<p><code>Context.Provider</code></p>
<ul>
<li>Provider 接收一个 value 属性，传递给消费组件</li>
<li>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染</li>
</ul>
<p><code>Class.contextType</code></p>
<ul>
<li>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象</li>
<li>使用 this.context 来消费最近 Context 上的那个值；</li>
<li>可以在任何生命周期中访问到它，包括 render 函数中</li>
</ul>
<p><code>Context.Consumer</code></p>
<ul>
<li>在函数式组件中使用</li>
</ul>
<pre><code class="js">// 类组件中使用
import React, { Component } from 'react'
// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1
})

class Sun extends Component {
  render () {
    console.log(this.context)
    return (
      &lt;div&gt;
        &lt;h2&gt;用户昵称: {this.context.nickname}&lt;/h2&gt;
        &lt;h2&gt;用户等级: {this.context.level}&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
}
Sun.contextType = UserContext

class Son extends Component {
  render () {
    console.log(this.context)
    return (
      &lt;div&gt;
        &lt;Sun /&gt;
        &lt;ul&gt;
          &lt;li&gt;设置1&lt;/li&gt;
          &lt;li&gt;设置2&lt;/li&gt;
          &lt;li&gt;设置3&lt;/li&gt;
          &lt;li&gt;设置4&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      &lt;div&gt;
        &lt;UserContext.Provider value={this.state}&gt;
          &lt;Son /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<pre><code class="js">// 在函数式组件中使用
import React, { Component } from 'react'
// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1
})

function Sun () {
  return (
    &lt;UserContext.Consumer&gt;
      {value =&gt; {
        return (
          &lt;div&gt;
            &lt;h2&gt;用户昵称:{value.nickname} &lt;/h2&gt;
            &lt;h2&gt;用户等级:{value.level} &lt;/h2&gt;
          &lt;/div&gt;
        )
      }}
    &lt;/UserContext.Consumer&gt;
  )
}

class Son extends Component {
  render () {
    return (
      &lt;div&gt;
        &lt;Sun /&gt;
        &lt;ul&gt;
          &lt;li&gt;设置1&lt;/li&gt;
          &lt;li&gt;设置2&lt;/li&gt;
          &lt;li&gt;设置3&lt;/li&gt;
          &lt;li&gt;设置4&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}

export default class Father extends Component {
  constructor (props) {
    super(props)

    this.state = {
      nickname: 'loveZero',
      level: 99
    }
  }

  render () {
    return (
      &lt;div&gt;
        &lt;UserContext.Provider value={this.state}&gt;
          &lt;Son /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="4-react-实现插槽"><a href="#4-react-实现插槽" class="headerlink" title="4.react 实现插槽"></a>4.react 实现插槽</h2><pre><code class="js">import React, { Component } from 'react'

class NavBar extends Component {
  render () {
    const { leftSlot, centerSlot, rightSlot } = this.props

    return (
      &lt;div className='nav-item nav-bar'&gt;
        &lt;div className='nav-left'&gt;{leftSlot}&lt;/div&gt;
        &lt;div className='nav-item nav-center'&gt;{centerSlot}&lt;/div&gt;
        &lt;div className='nav-item nav-right'&gt;{rightSlot}&lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

export default class Slot extends Component {
  render () {
    const leftJsx = &lt;span&gt;aaa&lt;/span&gt;
    return (
      &lt;div&gt;
        &lt;NavBar
          leftSlot={leftJsx}
          centerSlot={&lt;strong&gt;bbb&lt;/strong&gt;}
          rightSlot={&lt;a href='/#'&gt;ccc&lt;/a&gt;}
        /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>养鹦鹉</title>
    <url>/2021/11/02/ji-lu-yang-ying-wu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="养鹦鹉手册"><a href="#养鹦鹉手册" class="headerlink" title="养鹦鹉手册"></a>养鹦鹉手册</h1><h2 id="一、不同时期注意事项"><a href="#一、不同时期注意事项" class="headerlink" title="一、不同时期注意事项"></a>一、不同时期注意事项</h2><h3 id="1-婴儿期"><a href="#1-婴儿期" class="headerlink" title="1.婴儿期"></a>1.婴儿期</h3><p>指的是刚从蛋孵化出来，还没长满羽毛，身体无力还不会走路，不会自主进食需要主人喂</p>
<p>注意：</p>
<ul>
<li>需要保温</li>
<li>不能长时间撸它</li>
</ul>
<p>需要做的：</p>
<ul>
<li>长时间相处，培养亲人关系</li>
<li>喂食 (让它慢慢依赖你，让它知道你是食物的来源和它的依靠)</li>
<li>让它知道自己的名字(喂一勺奶，叫一声他的名字 )</li>
</ul>
<h3 id="2-走路期-走地鸡"><a href="#2-走路期-走地鸡" class="headerlink" title="2.走路期(走地鸡)"></a>2.走路期(走地鸡)</h3><p>有一点力量了，会自己走路。饿的时候会朝你跑过去 ，找你要吃的</p>
<p>需要做的 ：</p>
<ul>
<li>熟悉名字(叫它的时候会有所反应)</li>
<li>建立奖励机制</li>
<li>练胆训练(在室外温度ok，并他已经会走路的时候，要经常的带她出门，慢慢熟悉外部的环境)</li>
<li>亲人关系(多陪多撸多溜达，日后关系更融洽)</li>
<li>了解他的行为(更好的掌握它的心里状态)</li>
</ul>
<h3 id="3-全毛期"><a href="#3-全毛期" class="headerlink" title="3.全毛期"></a>3.全毛期</h3><p>身体被羽毛全部覆盖，可以熟练的爬高上低活动自如</p>
<p>需要做的：</p>
<ul>
<li>练胆训练(2周的黄金时期)</li>
<li>奖励和惩罚机制(让它知道你是主人，而且非常亲人)</li>
<li>定点排便</li>
<li>熟悉环境</li>
<li>上手训练</li>
<li>断奶期(保持营养的状态下，慢慢从流食到软固体再到固体食物，多给它各种食物，种类越多越好，避免日后挑食)</li>
</ul>
<h3 id="4-学飞期"><a href="#4-学飞期" class="headerlink" title="4.学飞期"></a>4.学飞期</h3><p>羽毛已经完全长好，有起飞的迹象</p>
<p>需要做的：</p>
<ul>
<li>练胆训练(最好是拴着)</li>
<li>奖励惩罚机制已经熟练(继续保持)</li>
<li>定点排便(强化 )</li>
<li>断奶</li>
<li>简单的命令(转圈，躺下…)</li>
<li>室内飞手(随叫随到 )</li>
</ul>
<h3 id="5-幼鸟期"><a href="#5-幼鸟期" class="headerlink" title="5.幼鸟期"></a>5.幼鸟期</h3><p>这个时候该会的都会了，只是没有长到成鸟的大小(三个月以上，一岁一下 )</p>
<p>需要做的：</p>
<ul>
<li>室外飞手训练(注意受惊的走失)</li>
<li>奖励惩罚机制已经完全ok</li>
<li>定点排便(乱拉的次数变少)</li>
<li>已断奶</li>
<li>脱敏训练(对什么事物有恐惧就一对一脱敏训练)</li>
</ul>
<h3 id="6-成鸟期"><a href="#6-成鸟期" class="headerlink" title="6.成鸟期"></a>6.成鸟期</h3><ul>
<li>保持手喂的习惯</li>
<li>保持恰当的关系</li>
<li>保持撸它的癖好</li>
<li>保持定时定点吃饭的习惯</li>
<li>保持放飞和练胆的训练</li>
<li>保持食物的多样性</li>
<li>保证它睡眠时间</li>
</ul>
<h2 id="二、注意事项"><a href="#二、注意事项" class="headerlink" title="二、注意事项"></a>二、注意事项</h2><h3 id="1-养成前准备"><a href="#1-养成前准备" class="headerlink" title="1.养成前准备"></a>1.养成前准备</h3><ul>
<li>一个15-20天的幼鸟，更认主，更亲人，更好训练</li>
<li>充足的时间</li>
<li>春季最佳</li>
<li>幼鸟奶粉</li>
<li>木屑(一包即可)</li>
<li>喂食工具(勺子)</li>
<li>哨子(防止走丢)</li>
<li>放飞绳</li>
<li>混合鸟粮</li>
<li>麻子(训练用)</li>
<li>站架</li>
<li>玩具</li>
</ul>
<h2 id="2-喂食"><a href="#2-喂食" class="headerlink" title="2.喂食"></a>2.喂食</h2><ul>
<li>喂食工具清洗干净</li>
<li>温度 42-45度</li>
<li>15-20天4小时一顿，20-30天每天3-4顿，30-40天每天3顿</li>
<li>盒子+木屑</li>
<li>室内温度20-25度</li>
<li>及时清理粪便</li>
<li>全毛期以后才能洗澡</li>
</ul>
<h3 id="3-训练"><a href="#3-训练" class="headerlink" title="3.训练"></a>3.训练</h3><p>模式：得到信息 – 给予反馈 – 得到好处</p>
<p>重要：即时奖励。当它做完后立马给予奖励</p>
<p>惩罚：不要打它！这样会破坏信任关系，可以关小黑屋</p>
<p>成功？当你不喂食的时候叫它，它也会过来，这就说明已经成功</p>
<ul>
<li>训练必须单独完成，不可由别人替代，才能建立主人的角色</li>
<li>在他已经熟悉环境的情况下训练</li>
<li>以名字/命令进行训练</li>
<li>训练越早越好</li>
</ul>
<p>上手训练</p>
<ul>
<li>放到远处(1-2米) – 发出命令 – 走/飞过来 – 给予奖励</li>
</ul>
<h2 id="4-练胆"><a href="#4-练胆" class="headerlink" title="4.练胆"></a>4.练胆</h2><p>练胆练得越好，越不容易走失</p>
<p>时机：羽毛已经覆盖皮肤，天气合适25度左右，可以安静在站在肩膀上</p>
<p>超过2个月的鹦鹉在去练胆，效果会大打折扣</p>
<p>方法：走路,骑车把它放肩膀上慢慢溜达</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-什么时候能带出门"><a href="#1-什么时候能带出门" class="headerlink" title="1.什么时候能带出门"></a>1.什么时候能带出门</h3><p>羽毛已经覆盖皮肤，室外温度15-30度(25度最佳)，腿脚已可以站立，下地走路很顺畅</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>科目四</title>
    <url>/2021/10/25/ji-lu-ke-mu-si/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ul>
<li><p>关于灯光的题</p>
<ul>
<li>看到交替选交替，没有交替选近光灯</li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><p>减速停车</p>
</li>
<li><p>近心端</p>
</li>
<li><p>心脏跳动100-120</p>
</li>
</ul>
</li>
<li><p>躲不掉了就紧急制动</p>
</li>
</ul>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><ul>
<li><p>远近在一起就是正确，分开就是错误</p>
</li>
<li><p>有’易’基本上都是正确的</p>
</li>
<li><p>出现上风处就是正确的，下风错</p>
</li>
<li><p>交警看着我们的就是对的，或者没有动作和三只手也是对的</p>
</li>
<li><p>跟车会车用近光</p>
</li>
<li><p>左进右出</p>
</li>
<li><p>进入环岛不用开启转向灯，出去的时候要开</p>
</li>
<li><p>黄昏开启示廓灯</p>
</li>
</ul>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>骂人</title>
    <url>/2021/10/25/ji-lu-ma-ren/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>长亭外，古道边，芳草天</p>
<p>你不去当厨子可惜了，甩锅甩得那么厉害。</p>
<p>把我气死，你当孤儿？</p>
<p>您一个阴间的东西，就别指望着能理解咱们阳间的话</p>
<p>我今天想骂人 所以不骂你</p>
<p>有空一起上厕所 我看你嘴很会喷shi</p>
<p>以前你叫斧码，现在你叫斤石</p>
<p>僵尸兴奋的打开了你的头盖骨，失望的走开了，旁边的屎壳郎眼前一亮</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2021/08/04/javascript-shou-xie-promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>举个简单例子：</p>
<p>你爸爸承诺下礼拜发工资了给你买个手机。你 [不知道] 你是否会得到手机直到下礼拜，此时进入等待态。你爸爸真的给你买一个手机(因为发工资有钱了)，也可以告诉你不买了(因为先给自己买了)。这是一个承诺。一个承诺有3个状态。分别是:</p>
<p>1.悬而未决：你 [不知道] 你是否会得到手机直到下礼拜（<strong style="color:#17a2b8;">等待态</strong>）。</p>
<p>2.解决：你老妈给你买了，因为发工资有钱了（<strong style="color:#17a2b8;">成功态</strong>）。</p>
<p>3.拒绝：你老妈拒绝给你买，因为钱不够（<strong style="color:#17a2b8;">失败态</strong>）。</p>
<p>总结：</p>
<ol>
<li>Promise 有三个状态 ：<ol>
<li>默认状态叫等待态 pending</li>
<li>resolve表示成功态 fulfilled</li>
<li>reject表示变成失败态 rejected</li>
</ol>
</li>
<li>成功有成功的原因，失败也有失败的原因</li>
<li>只有pending的状态的时候才能改变状态<ul>
<li>不能从成功变为失败</li>
<li>不能从失败变为成功</li>
</ul>
</li>
</ol>
<pre><code class="js">// 代码实现
const money = 9999
const bugPhone = new Promise((resolve, reject) =&gt; {
  if (money &gt; 10000) {
    resolve('有钱，买！')
  } else {
    reject('我先给我买手机了')
  }
})
// then方法中提供两个参数 1. 成功回调 2.失败的回调
bugPhone.then((value) =&gt; {
  console.log(value, 'success')
}, (reason) =&gt; {
  console.log(reason, 'fail')
})
</code></pre>
<ol>
<li>当既调用成功，又调用失败：只会变为第一次调用的状态</li>
</ol>
<pre><code class="js">// 此时只会执行resolve，因为状态一旦确定无法改变
const promise = new Promise((resolve, reject) =&gt; {
  resolve('ok')
  reject('error')
})
promise.then((value) =&gt; {
  console.log(value, 'success')
}, (reason) =&gt; {
  console.log(reason, 'fail')
})
</code></pre>
<ol start="2">
<li>失败状态的方法reject和throw new Error都可以变为失败态</li>
</ol>
<pre><code class="js">const promise2 = new Promise((resolve, reject) =&gt; {
  // reject('error')
  throw new Error('error')
})
promise2.then((value) =&gt; {
  console.log(value, 'success')
}, (reason) =&gt; {
  console.log(reason, 'fail')
})
</code></pre>
<ol start="3">
<li>在异步中，仍然可以正常使用</li>
</ol>
<pre><code class="js">let promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    // throw new Error('error')
    reject('error');
    resolve('ok')
    // return new Error('失败')
  }, 1000);
})

promise.then((value) =&gt; {
  console.log(value, 'success')
}, (reason) =&gt; {
  console.log(reason, 'fail')
})
</code></pre>
<ol start="4">
<li>支持<code>.then</code> 链式调用<ul>
<li>当<code>.then</code> 中返回的是一个Promise，可以继续<code>.then</code> 调用这个返回的promise，以下称原来的promise为promise，返回的promise为promise2<ul>
<li>当promise2结果是成功：链式调用<code>.then</code>直接进入<code>resolve</code></li>
<li>当promise2结果为失败或抛出异常：链式调用<code>.then</code>直接进入<code>reject</code></li>
</ul>
</li>
<li>当<code>.then</code> 中返回的的是一个非Promise，链式调用<code>.then</code>时，直接进入<code>resolve</code></li>
</ul>
</li>
</ol>
<pre><code class="js">const promise3 = new Promise((resolve, reject) =&gt; {
  resolve('ok')
}).then(data =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // 返回一个promise，并是成功态
    resolve('ok')
  })
}).then((data) =&gt; {
  console.log(data); // 进入成功
}, err =&gt; {
  console.log('err', err)
})

const promise4 = new Promise((resolve, reject) =&gt; {
  resolve('ok')
}).then(data =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // 返回一个promise，并是失败态，或异常
    // reject('err')
    throw new Error('error')
  })
}).then((data) =&gt; {
  console.log(data);
}, err =&gt; {
  console.log('err', err) // 进入失败
})

const promise5 = new Promise((resolve, reject) =&gt; {
  resolve('ok')
}).then(data =&gt; {
  // 返回一个非promise
  return 666
}).then((data) =&gt; {
  console.log(data); // 直接进入成功
}, err =&gt; {
  console.log('err', err)
})
</code></pre>
<ol start="5">
<li>链式调用中不允许循环引用<ul>
<li>new一个Promise，<code>.then</code>时，将这个Promise返回，链式<code>.then</code>再次调用就会出现循环引用</li>
<li>原理是：返回的promise始终在等待态，再调用依然是等待态。通俗说就是自己等自己</li>
</ul>
</li>
</ol>
<pre><code class="js">let promise6 = new Promise((resolve, reject) =&gt; {
  resolve('ok')
}).then(data =&gt; {
  return promise6;// prending resolve()/reject()
})
promise6.then((data) =&gt; {
  console.log(data);
}, err =&gt; {
  console.log('err', err) // err [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]
})
</code></pre>
<ol start="6">
<li>链式调用可选参数</li>
</ol>
<pre><code class="js">let promise7 = new Promise((resolve, reject) =&gt; {
  reject('err')
  // 当then里没有传任何值的时候，最后一个then用的依然是第一次传入的值
}).then().then().then((data) =&gt; {
  console.log(data);
}, err =&gt; {
  console.log('err', err)
})
</code></pre>
<h3 id="2-根据promiseaplus官网-的规则，手写自己的Promise"><a href="#2-根据promiseaplus官网-的规则，手写自己的Promise" class="headerlink" title="2.根据promiseaplus官网 的规则，手写自己的Promise"></a>2.根据<a href="https://promisesaplus.com/">promiseaplus官网</a> 的规则，手写自己的Promise</h3><h4 id="1-一个基本的promise，满足异步promise，但无法进行链式调用"><a href="#1-一个基本的promise，满足异步promise，但无法进行链式调用" class="headerlink" title="1.一个基本的promise，满足异步promise，但无法进行链式调用"></a>1.一个基本的promise，满足异步promise，但无法进行链式调用</h4><pre><code class="js">
const PENDING = 'PENDING'; // 默认等待态
const FULFILLED = 'FULFILLED'; // 成功态 
const REJECTED = 'REJECTED'; // 失败态
class Promise {
  constructor(executor) {
    // 默认状态改为PENDING
    this.status = PENDING;
    // 储存传入的成功值
    this.value = undefined;
    // 储存传入的失败
    this.reason = undefined;
    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    // 成功方法
    const resolve = (value) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.value = value
        // 将状态改为成功
        this.status = FULFILLED
        // 执行储存的成功回调
        this.onResolvedCallbacks.forEach(fn =&gt; fn())
      }
    }
    // 失败方法
    const reject = (reason) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.reason = reason
        // 将状态改为失败
        this.status = REJECTED
        // 执行储存的失败回调
        this.onRejectedCallbacks.forEach(fn =&gt; fn())
      }
    }
    try {
      // 默认new Promise中的函数会立即执行
      executor(resolve, reject);
    } catch (e) {
      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑
      reject(e)
    }
  }
  // then方法
  then(onFulfilled, onRejected) {
    switch (this.status) {
      case FULFILLED:
        // 成功时
        onFulfilled(this.value)
        break;
      case REJECTED:
        // 失败时
        onRejected(this.reason)
        break;
      default:
        // 等待时
        this.onResolvedCallbacks.push(() =&gt; {
          // 将成功函数push到成功回调队列
          onFulfilled(this.value)
        })
        this.onRejectedCallbacks.push(() =&gt; {
          // 将成功函数push到失败回调队列
          onRejected(this.reason);
        })
        break;
    }
  }
}
module.exports = Promise
</code></pre>
<h4 id="2-支持链式调用"><a href="#2-支持链式调用" class="headerlink" title="2.支持链式调用"></a>2.支持链式调用</h4><pre><code class="js">
const PENDING = 'PENDING'; // 默认等待态
const FULFILLED = 'FULFILLED'; // 成功态 
const REJECTED = 'REJECTED'; // 失败态

// 处理promise逻辑的函数
/**
 * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject
 * 2.x是一个非promise，统统调用resolve
 * 3.x是抛出异常，进入reject
 * 4.x和promise2不能一样，会出现循环引用
 * 5.resolve和reject都只能调用一次
 * @param {返回的promise} x 
 * @param {new的新} promise2 
 * @param {成功方法} resolve 
 * @param {失败方法} reject 
 * @returns 
 */
function resolvePromise(x, promise2, resolve, reject) {

  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常
  if (x === promise2) {
    return reject(new TypeError('循环引用'))
  }
  // 判断返回的x是否是一个promise(promsise需要有then方法)
  // 可能是一个名为promise的对象，或者是一个自定义的promise函数
  if ((typeof x === 'object' &amp;&amp; x !== null) || (typeof x == 'function')) {
    // 记录状态是否改变
    let called = false;
    try {
      // 获取返回的then方法
      let then = x.then;
      if (typeof then === 'function') {
        // 因为返回的有可能还是一个promise
        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值
        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug
        then.call(x, (y) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里说明返回的promise是成功状态
          resolvePromise(y, promise2, resolve, reject)
        }, (r) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里是失败，直接走失败
          reject(r);
        })
      } else {
        // 进到这里可能是{then:1}，非promise值直接进成功
        resolve(x);
      }
    } catch (error) {
      // 如果状态改变了，就不往下走
      if (called) return;
      // 执行到这里说明状态没有被改变，就标记为已改变
      called = true
      //  让promise2 变成失败态
      reject(error)
    }
  } else {
    // 进这里，说明x是一个非promise，直接调用resolve
    resolve(x);
  }
}

class Promise {
  constructor(executor) {
    // 默认状态改为PENDING
    this.status = PENDING;
    // 储存传入的成功值
    this.value = undefined;
    // 储存传入的失败
    this.reason = undefined;
    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    // 成功方法
    const resolve = (value) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.value = value
        // 将状态改为成功
        this.status = FULFILLED
        // 执行储存的成功回调
        this.onResolvedCallbacks.forEach(fn =&gt; fn())
      }
    }
    // 失败方法
    const reject = (reason) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.reason = reason
        // 将状态改为失败
        this.status = REJECTED
        // 执行储存的失败回调
        this.onRejectedCallbacks.forEach(fn =&gt; fn())
      }
    }
    try {
      // 默认new Promise中的函数会立即执行
      executor(resolve, reject);
    } catch (e) {
      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑
      reject(e)
    }
  }
  // then方法
  then(onFulfilled, onRejected) {
    // 这里是then()如果传空值，就使用上一个的值
    onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : v =&gt; v;
    onRejected = typeof onRejected == 'function' ? onRejected : e =&gt; { throw e };
    // 由于promise状态无法修改，所以不能使用同一个promise
    // 实现链式调用不能return this
    // 每次调用then方法 都必须返回一个全新的promise
    let promise2 = new Promise((resolve, reject) =&gt; {
      switch (this.status) {
        // 成功时
        case FULFILLED:
          // 因为需要promise2做参数，所以需要异步调用
          setTimeout(() =&gt; {
            try {
              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败
              let x = onFulfilled(this.value)
              // 处理函数
              resolvePromise(x, promise2, resolve, reject)
            } catch (e) {
              // 如果出错，直接就走失败
              reject(e)
            }
          }, 0)
          break;
        // 失败时
        case REJECTED:
          setTimeout(() =&gt; {
            try {
              let x = onRejected(this.reason);
              resolvePromise(x, promise2, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
          break;
        default:
          // 等待时
          this.onResolvedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到成功回调队列
                let x = onFulfilled(this.value);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          this.onRejectedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到失败回调队列
                let x = onRejected(this.reason);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          break;
      }
    })
    // 返回新的promise，供链式调用
    return promise2;
  }
}

module.exports = Promise
</code></pre>
<h4 id="3-运行官方测试"><a href="#3-运行官方测试" class="headerlink" title="3.运行官方测试"></a>3.运行官方测试</h4><ol>
<li><p><code>npm install promises-aplus-tests -g</code> 安装测试工具</p>
</li>
<li><p>在promise.js中写</p>
</li>
<li><pre><code class="js">// 官方提供的测试静态方法
Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) =&gt; {
    dfd.resolve = resolve;
    dfd.reject = reject;
  })
  return dfd
}
</code></pre>
</li>
<li><p><code>promises-aplus-tests promise.js</code> 根据promise的地址运行测试</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628130801594-1628130801589.png"></p>
<h3 id="4-Promise语法糖"><a href="#4-Promise语法糖" class="headerlink" title="4.Promise语法糖"></a>4.Promise语法糖</h3><h4 id="原生Promise"><a href="#原生Promise" class="headerlink" title="原生Promise"></a>原生Promise</h4><ol>
<li>Promise.resolve和Promise.reject<ul>
<li>Promise.resolve会等待异步任务执行完毕再进入resolve</li>
<li>Promise.reject会直接进入catch</li>
</ul>
</li>
</ol>
<pre><code class="js">
Promise.resolve('ok').then(data =&gt; {
  console.log(data); // ok
})
// Promise.reject会直接进入catch
Promise.reject('失败').catch(err =&gt; {
  console.log('err', err); // 失败
})

// 异步时
Promise.resolve(new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('hello', 'success');
  }, 2000);
})).then(data =&gt; {
  console.log(data); // hello
})
// Promise.reject会直接进入catch
Promise.reject(new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('hello'); 
  }, 1000);
})).catch(err =&gt; {
  console.log('err', err); // err Promise { &lt;pending&gt; }
})
</code></pre>
<ol start="2">
<li>Promise.all<ul>
<li>所有任务都成功，才会进入成功</li>
<li>只要有一个任务失败，就会进入失败</li>
<li>成功任务返回时，会按照书写顺序返回</li>
</ul>
</li>
</ol>
<pre><code class="js">Promise.all([fs.readFile('./promise-study/name.txt', 'utf8'), fs.readFile('./promise-study/age.txt', 'utf8'), 11]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err)
})
</code></pre>
<ol start="3">
<li>Promise.finally<ul>
<li>不管成功还是失败都会执行</li>
</ul>
</li>
</ol>
<pre><code class="js">// finally 不管成功还是失败都会执行
Promise.reject('err').finally((f) =&gt; {
  // 没有参数
  console.log('无论成功失败都执行', f)
  // return 一个普通值没有意义
  return 'finally'
}).then((data) =&gt; {
  console.log('成功', data)
}).catch(err =&gt; {
  console.log('失败', err)
});

Promise.resolve('ok').finally((f) =&gt; {
  console.log('无论成功失败都执行', f)
}).then((data) =&gt; {
  console.log('成功', data)
}).catch(err =&gt; {
  console.log('失败', err)
});
</code></pre>
<ul>
<li>当返回的是一个promise<ul>
<li>外层promise为reject时<ul>
<li>里层promise为reject，就会使用里层promise的原因走reject</li>
<li>里层的promsie为resolve，就会以外层的reject原因走reject</li>
</ul>
</li>
<li>外层promsie为resolve时<ul>
<li>里层的promise为resolve，就会以外层resolve的原因走resolve</li>
<li>里层的promise为reject，就会以里层reject的原因走reject</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">Promise.reject('ok').finally(() =&gt; {
  console.log('无论成功失败都执行')
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      reject('finally reject')
    }, 1000);
  });
}).then((data) =&gt; {
  console.log('成功', data)
}).catch(err =&gt; {
  console.log('失败', err)
});
</code></pre>
<h4 id="我的promise实现"><a href="#我的promise实现" class="headerlink" title="我的promise实现"></a>我的promise实现</h4><ol>
<li>Promise.resolve和Promise.reject</li>
</ol>
<pre><code class="diff">
const PENDING = 'PENDING'; // 默认等待态
const FULFILLED = 'FULFILLED'; // 成功态 
const REJECTED = 'REJECTED'; // 失败态

// 处理promise逻辑的函数
/**
 * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject
 * 2.x是一个非promise，统统调用resolve
 * 3.x是抛出异常，进入reject
 * 4.x和promise2不能一样，会出现循环引用
 * 5.resolve和reject都只能调用一次
 * @param {返回的promise} x 
 * @param {new的新} promise2 
 * @param {成功方法} resolve 
 * @param {失败方法} reject 
 * @returns 
 */
function resolvePromise(x, promise2, resolve, reject) {

  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常
  if (x === promise2) {
    return reject(new TypeError('循环引用'))
  }
  // 判断返回的x是否是一个promise(promsise需要有then方法)
  // 可能是一个名为promise的对象，或者是一个自定义的promise函数
  if ((typeof x === 'object' &amp;&amp; x !== null) || (typeof x == 'function')) {
    // 记录状态是否改变
    let called = false;
    try {
      // 获取返回的then方法
      let then = x.then;
      if (typeof then === 'function') {
        // 因为返回的有可能还是一个promise
        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值
        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug
        then.call(x, (y) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里说明返回的promise是成功状态
          resolvePromise(y, promise2, resolve, reject)
        }, (r) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里是失败，直接走失败
          reject(r);
        })
      } else {
        // 进到这里可能是{then:1}，非promise值直接进成功
        resolve(x);
      }
    } catch (error) {
      // 如果状态改变了，就不往下走
      if (called) return;
      // 执行到这里说明状态没有被改变，就标记为已改变
      called = true
      //  让promise2 变成失败态
      reject(error)
    }
  } else {
    // 进这里，说明x是一个非promise，直接调用resolve
    resolve(x);
  }
}

class Promise {
  constructor(executor) {
    // 默认状态改为PENDING
    this.status = PENDING;
    // 储存传入的成功值
    this.value = undefined;
    // 储存传入的失败
    this.reason = undefined;
    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    // 成功方法
+    const resolve = (value) =&gt; {
+      // 看resolve中是否是一个promise
+      if (value instanceof Promise) {
+        // 如果是，就手动掉用then方法。递归知道他不是一个promise
+        return value.then(resolve, reject);
+      }
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.value = value
        // 将状态改为成功
        this.status = FULFILLED
        // 执行储存的成功回调
        this.onResolvedCallbacks.forEach(fn =&gt; fn())
      }
    }
    // 失败方法
    const reject = (reason) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.reason = reason
        // 将状态改为失败
        this.status = REJECTED
        // 执行储存的失败回调
        this.onRejectedCallbacks.forEach(fn =&gt; fn())
      }
    }
    try {
      // 默认new Promise中的函数会立即执行
      executor(resolve, reject);
    } catch (e) {
      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑
      reject(e)
    }
  }
  // then方法
  then(onFulfilled, onRejected) {
    // 这里是then()如果传空值，就使用上一个的值
    onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : v =&gt; v;
    onRejected = typeof onRejected == 'function' ? onRejected : e =&gt; { throw e };
    // 由于promise状态无法修改，所以不能使用同一个promise
    // 实现链式调用不能return this
    // 每次调用then方法 都必须返回一个全新的promise
    let promise2 = new Promise((resolve, reject) =&gt; {
      switch (this.status) {
        // 成功时
        case FULFILLED:
          // 因为需要promise2做参数，所以需要异步调用
          setTimeout(() =&gt; {
            try {
              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败
              let x = onFulfilled(this.value)
              // 处理函数
              resolvePromise(x, promise2, resolve, reject)
            } catch (e) {
              // 如果出错，直接就走失败
              reject(e)
            }
          }, 0)
          break;
        // 失败时
        case REJECTED:
          setTimeout(() =&gt; {
            try {
              let x = onRejected(this.reason);
              resolvePromise(x, promise2, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
          break;
        default:
          // 等待时
          this.onResolvedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到成功回调队列
                let x = onFulfilled(this.value);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          this.onRejectedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到失败回调队列
                let x = onRejected(this.reason);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          break;
      }
    })
    // 返回新的promise，供链式调用
    return promise2;
  }
+  catch(errFn) {
+     return this.then(null, errFn);
+  }
+  // 静态方法resolve
+  static resolve(value) {
+    return new Promise((resolve, reject) =&gt; {
+      resolve(value);
+    })
+  }
+  // 静态方法reject
+  static reject(err) {
+    return new Promise((resolve, reject) =&gt; {
+      reject(err);
+    })
+  }
}


// 官方提供的测试静态方法
// npm install promises-aplus-tests -g;
Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) =&gt; {
    dfd.resolve = resolve;
    dfd.reject = reject;
  })
  return dfd
}
module.exports = Promise
</code></pre>
<ol start="2">
<li>Promise.all</li>
</ol>
<pre><code class="diff">const PENDING = 'PENDING'; // 默认等待态
const FULFILLED = 'FULFILLED'; // 成功态 
const REJECTED = 'REJECTED'; // 失败态

// 处理promise逻辑的函数
/**
 * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject
 * 2.x是一个非promise，统统调用resolve
 * 3.x是抛出异常，进入reject
 * 4.x和promise2不能一样，会出现循环引用
 * 5.resolve和reject都只能调用一次
 * @param {返回的promise} x 
 * @param {new的新} promise2 
 * @param {成功方法} resolve 
 * @param {失败方法} reject 
 * @returns 
 */
function resolvePromise(x, promise2, resolve, reject) {

  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常
  if (x === promise2) {
    return reject(new TypeError('循环引用'))
  }
  // 判断返回的x是否是一个promise(promsise需要有then方法)
  // 可能是一个名为promise的对象，或者是一个自定义的promise函数
  if ((typeof x === 'object' &amp;&amp; x !== null) || (typeof x == 'function')) {
    // 记录状态是否改变
    let called = false;
    try {
      // 获取返回的then方法
      let then = x.then;
      if (typeof then === 'function') {
        // 因为返回的有可能还是一个promise
        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值
        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug
        then.call(x, (y) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里说明返回的promise是成功状态
          resolvePromise(y, promise2, resolve, reject)
        }, (r) =&gt; {
          // 如果状态改变了，就不往下走
          if (called) return;
          // 执行到这里说明状态没有被改变，就标记为已改变
          called = true
          // 这里是失败，直接走失败
          reject(r);
        })
      } else {
        // 进到这里可能是{then:1}，非promise值直接进成功
        resolve(x);
      }
    } catch (error) {
      // 如果状态改变了，就不往下走
      if (called) return;
      // 执行到这里说明状态没有被改变，就标记为已改变
      called = true
      //  让promise2 变成失败态
      reject(error)
    }
  } else {
    // 进这里，说明x是一个非promise，直接调用resolve
    resolve(x);
  }
}

class Promise {
  constructor(executor) {
    // 默认状态改为PENDING
    this.status = PENDING;
    // 储存传入的成功值
    this.value = undefined;
    // 储存传入的失败
    this.reason = undefined;
    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    // 成功方法
    const resolve = (value) =&gt; {
      // 看resolve中是否是一个promise
      if (value instanceof Promise) {
        // 如果是，就手动掉用then方法。递归知道他不是一个promise
        return value.then(resolve, reject);
      }
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.value = value
        // 将状态改为成功
        this.status = FULFILLED
        // 执行储存的成功回调
        this.onResolvedCallbacks.forEach(fn =&gt; fn())
      }
    }
    // 失败方法
    const reject = (reason) =&gt; {
      // 只有等待态才能改变状态
      if (this.status === PENDING) {
        // 将传入的值赋给value
        this.reason = reason
        // 将状态改为失败
        this.status = REJECTED
        // 执行储存的失败回调
        this.onRejectedCallbacks.forEach(fn =&gt; fn())
      }
    }
    try {
      // 默认new Promise中的函数会立即执行
      executor(resolve, reject);
    } catch (e) {
      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑
      reject(e)
    }
  }
  // then方法
  then(onFulfilled, onRejected) {
    // 这里是then()如果传空值，就使用上一个的值
    onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : v =&gt; v;
    onRejected = typeof onRejected == 'function' ? onRejected : e =&gt; { throw e };
    // 由于promise状态无法修改，所以不能使用同一个promise
    // 实现链式调用不能return this
    // 每次调用then方法 都必须返回一个全新的promise
    let promise2 = new Promise((resolve, reject) =&gt; {
      switch (this.status) {
        // 成功时
        case FULFILLED:
          // 因为需要promise2做参数，所以需要异步调用
          setTimeout(() =&gt; {
            try {
              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败
              let x = onFulfilled(this.value)
              // 处理函数
              resolvePromise(x, promise2, resolve, reject)
            } catch (e) {
              // 如果出错，直接就走失败
              reject(e)
            }
          }, 0)
          break;
        // 失败时
        case REJECTED:
          setTimeout(() =&gt; {
            try {
              let x = onRejected(this.reason);
              resolvePromise(x, promise2, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
          break;
        default:
          // 等待时
          this.onResolvedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到成功回调队列
                let x = onFulfilled(this.value);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          this.onRejectedCallbacks.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                // 将成功函数push到失败回调队列
                let x = onRejected(this.reason);
                resolvePromise(x, promise2, resolve, reject);
              } catch (e) {
                reject(e);
              }
            }, 0);
          })
          break;
      }
    })
    // 返回新的promise，供链式调用
    return promise2;
  }
  catch(errFn) {
    return this.then(null, errFn);
  }
  // 静态方法resolve
  static resolve(value) {
    return new Promise((resolve, reject) =&gt; {
      resolve(value);
    })
  }
  // 静态方法reject
  static reject(err) {
    return new Promise((resolve, reject) =&gt; {
      reject(err);
    })
  }
+  static all(promises) {
+    return new Promise((resolve, reject) =&gt; {
+      // 将数组中的promise依次执行 
+      let result = [];
+      let index = 0;
+      // 处理函数
+      function process(v, k) {
+        // 将函数与索引映射
+        result[k] = v;
+        if (++index === promises.length) {
+          resolve(result)
+        }
+      }
+      for (let i = 0; i &lt; promises.length; i++) {
+        let p = promises[i];
+        // 判断p是否是promsie
+        if (p &amp;&amp; typeof p.then === 'function') {
+          p.then(data =&gt; {
+            process(data, i)
+          }, reject) // 只要有一个失败，就直接调reject
+        } else {
+          // 说明不是promise
+          process(p, i)
+        }
+      }
+    })
  }
}


// 官方提供的测试静态方法
// npm install promises-aplus-tests -g;
Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) =&gt; {
    dfd.resolve = resolve;
    dfd.reject = reject;
  })
  return dfd
}
module.exports = Promise
</code></pre>
<ol start="3">
<li>finally方法,直接写在原型上</li>
</ol>
<pre><code class="js">Promise.prototype.finally = function (cb) {
  return this.then((y) =&gt; {
    // 使用Promise.resolve是因为需要有等待功能
    // 成功就直接进then，但使用的原因是外层的原因
    return Promise.resolve(cb()).then((d) =&gt; y);
  }, (r) =&gt; {
    //cb执行一旦报错 就直接跳过后续的then的逻辑，直接将错误向下传递
    return Promise.resolve(cb()).then(() =&gt; { throw r })
  })
}
</code></pre>
<p>完结啦~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>专题</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
