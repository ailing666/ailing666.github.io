<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-Js数据类型</title>
    <url>/2021/08/03/01-Js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、为什么要区分不同的数据类型"><a href="#一、为什么要区分不同的数据类型" class="headerlink" title="一、为什么要区分不同的数据类型"></a>一、为什么要区分不同的数据类型</h1><p>在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。</p>
<h1 id="二、JS中一共有七种数据类型"><a href="#二、JS中一共有七种数据类型" class="headerlink" title="二、JS中一共有七种数据类型"></a>二、JS中一共有七种数据类型</h1><ul>
<li><strong>基本数据类型（值类型）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义、Symbol(ES6新增)。</li>
<li><strong>引用数据类型（引用类型）</strong>：Object 对象。</li>
</ul>
<p>注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那六种基本数据类型之外，其他的，都称之为 Object类型。</p>
<h3 id="1-查看数据类型的方式typeof"><a href="#1-查看数据类型的方式typeof" class="headerlink" title="1.查看数据类型的方式typeof()"></a>1.查看数据类型的方式typeof()</h3><ul>
<li>typeof()返回的是一个字符串类型</li>
<li>typeof()检测的特殊值<ul>
<li>基本数据类型null返回的是object —&gt;  js历史遗留的bug</li>
<li>复杂数据类型function返回的是functiong —&gt; 函数是js中的一等公民。有双重身份，即是obj又是function<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);<span class="comment">//number</span></span><br><span class="line"><span class="comment">//typeof 返回的是一个字符串类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">10</span>));<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;hello&#x27;</span>);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>);<span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);<span class="comment">//object</span></span><br><span class="line"><span class="comment">// typeof不仅可以检测单个值，加小括号可以检测表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="number">10</span> + <span class="string">&#x27;10&#x27;</span>));<span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof()"></a>2.instanceof()</h3></li>
</ul>
</li>
</ul>
<p><strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链<br>函数既是function又是object…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">String</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h1 id="三、String类型"><a href="#三、String类型" class="headerlink" title="三、String类型"></a>三、String类型</h1><h2 id="1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"><a href="#1-用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。" class="headerlink" title="1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。"></a>1.用引号包裹的就是String类型。————简单理解：String说：穿了我的衣服就是我的人了。</h2><h2 id="2-String中的转义字符"><a href="#2-String中的转义字符" class="headerlink" title="2.String中的转义字符"></a>2.String中的转义字符</h2><p>和css中的特殊字符类似</p>
<ul>
<li><code>\&quot;</code> 表示 <code>&quot;</code></li>
<li><code>\&#39;</code> 表示 <code>&#39;</code></li>
<li><code>\\</code> 表示<code>\</code></li>
<li><code>\r</code> 表示回车</li>
<li><code>\n</code> 表示换行。n 的意思是 newline。</li>
<li><code>\t</code> 表示缩进。t 的意思是 tab。</li>
<li><code>\b</code> 表示空格。b 的意思是 blank。</li>
</ul>
<h2 id="3-获取字符串的长度"><a href="#3-获取字符串的长度" class="headerlink" title="3.获取字符串的长度"></a>3.获取字符串的长度</h2><p>String.length</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var str1 = &#x27;1；23&#x27;;</span><br><span class="line">  var str2 = &#x27;小艾 同学&#x27;;</span><br><span class="line">  var str3 = &#x27;ab,cd&#x27;;</span><br><span class="line"></span><br><span class="line">  // 注意：</span><br><span class="line">  // 中文、英文字母、数字都占一个字符</span><br><span class="line">  // 中英文标点符号都占一个字符</span><br><span class="line">  // 空格也占一个字符</span><br><span class="line">  console.log(str1.length);//4</span><br><span class="line">  console.log(str2.length);//5</span><br><span class="line">  console.log(str3.length);//5</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4.字符串拼接"></a>4.字符串拼接</h2><p>当<code>+</code>号的连接的是一个字符串，就会变成连接符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串 + 任意数据类型 = 拼接之后的新字符串;</span><br></pre></td></tr></table></figure>
<p>字符串和任何数据类型拼接，都会将拼接内容隐式转为字符串，并输出一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span> + <span class="literal">null</span>);<span class="comment">//10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span> + <span class="literal">true</span>);<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当加号的左侧或右侧为一个字符串类型时，就会作为连接符</span></span><br><span class="line">  <span class="comment">//将任何数据类型都转为字符串，在返回拼接后的新字符串</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span> + <span class="literal">null</span>);<span class="comment">//10null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span>);<span class="comment">//true10</span></span><br><span class="line"><span class="comment">//复杂数据类型也会隐式转换为字符串哦</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学&#x27;</span> + &#123;&#125;);<span class="comment">//小艾同学[object Object]</span></span><br></pre></td></tr></table></figure>
<p>变量与字符串拼接为了不让转为字符串，通常采用引引加加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串与变量拼接</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 要想在字符串中插入一个变量，就不能让该变量暴露在引号中</span></span><br><span class="line"><span class="comment">//可以用引引加加口诀， &#x27;+a+&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学a分&#x27;</span>);<span class="comment">//小艾同学a分</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;小艾同学&#x27;</span> + a + <span class="string">&#x27;分&#x27;</span>);<span class="comment">//小艾同学100分</span></span><br></pre></td></tr></table></figure>
<p>凡是存在隐式转换的地方，都不应该广泛使用，所以字符串拼接是，尽量不用加号隐式转换，推荐使用<code>$&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`小<span class="subst">$&#123;a&#125;</span>艾同<span class="subst">$&#123;b&#125;</span>学`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-ES6字符串遍历"><a href="#5-ES6字符串遍历" class="headerlink" title="5.ES6字符串遍历"></a>5.ES6字符串遍历</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> str= <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> char <span class="keyword">of</span> str)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;字符：&quot;</span>+char);</span><br><span class="line"> <span class="comment">// 字符：1</span></span><br><span class="line"> <span class="comment">// 字符：2</span></span><br><span class="line"> <span class="comment">// 字符：3</span></span><br><span class="line"> <span class="comment">// 字符：4</span></span><br><span class="line"> <span class="comment">// 字符：5</span></span><br><span class="line"> <span class="comment">// 字符：6</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、Number类型"><a href="#四、Number类型" class="headerlink" title="四、Number类型"></a>四、Number类型</h1><h2 id="1-所有的数字都是Number类型"><a href="#1-所有的数字都是Number类型" class="headerlink" title="1.所有的数字都是Number类型"></a>1.所有的数字都是Number类型</h2><p>Js中不存在int,folat类型，正负数，整数，小数都是Number类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0x9</span>;<span class="comment">//前面加0x就是十六进制</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">07</span>;<span class="comment">//前面加0代表八进制</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">2e8</span>;<span class="comment">//e表示科学计数法次幂</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(num);<span class="comment">//9</span></span><br><span class="line">    <span class="built_in">console</span>.log(num1);<span class="comment">//7</span></span><br><span class="line">    <span class="built_in">console</span>.log(num2);<span class="comment">//1.7976931348623157e+308</span></span><br><span class="line">    <span class="comment">// Number最大范围</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);<span class="comment">//1.7976931348623157e+308</span></span><br><span class="line">    <span class="comment">// Number最小范围</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE);<span class="comment">//5e-324</span></span><br><span class="line">    <span class="comment">// 无穷大Infinity</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>);<span class="comment">//Infinity</span></span><br><span class="line">    <span class="comment">// 无穷小-Infinity</span></span><br><span class="line">    <span class="built_in">console</span>.log(-<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>);<span class="comment">//-Infinity</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>补充进制转换（以100为例）<br>几进制就是逢几进一→十进制逢十进一</p>
</blockquote>
<h4 id="各进制转十进制，就是-几进制的位数-1次幂…"><a href="#各进制转十进制，就是-几进制的位数-1次幂…" class="headerlink" title="各进制转十进制，就是*几进制的位数-1次幂…"></a>各进制转十进制，就是*几进制的位数-1次幂…</h4><ul>
<li>十进制转十进制</li>
</ul>
<p>100 = 1_10^2 + 0_10^1 + 0*10^0 = 100</p>
<ul>
<li>二进制转十进制</li>
</ul>
<p>100 = 1_2^2 + 0_2^1 + 0*2^0 = 4</p>
<ul>
<li>八进制转十进制(以0开头就是八进制)</li>
</ul>
<p>0100= 1_8^2 + 0_8^1 + 0*8^0 = 64</p>
<ul>
<li>十六进制转十进制(以0x开头就是十六进制)</li>
</ul>
<p>0x100 = 1_16^2 + 0_16^1 + 0*16^0 = 256</p>
<h4 id="十进制转各进制就是-该进制的余数倒过来…"><a href="#十进制转各进制就是-该进制的余数倒过来…" class="headerlink" title="十进制转各进制就是/该进制的余数倒过来…"></a>十进制转各进制就是/该进制的余数倒过来…</h4><ul>
<li>十进制转二进制</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661499-a409744a-df42-4062-9025-1bb38e04c68e.png#align=left&display=inline&height=667&margin=%5Bobject%20Object%5D&originHeight=667&originWidth=859&size=0&status=done&style=none&width=859"></p>
<ul>
<li>别的进制同理</li>
</ul>
<h2 id="2-Number类型的特殊值—NaN"><a href="#2-Number类型的特殊值—NaN" class="headerlink" title="2.Number类型的特殊值—NaN"></a>2.Number类型的特殊值—NaN</h2><p>Not a Numberde 的简写，是Number类型</p>
<p>特点：NaN不等于任何东西，包括他自己</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// NaN不等于任何</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">NaN</span> =-= <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line">  <span class="comment">// 返回NaN的情况</span></span><br><span class="line">  <span class="comment">// 1.字符串计算</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> - <span class="number">1</span>);<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.类型转换时开头有无法转换成数字的值</span></span><br><span class="line">  <span class="comment">// 不能转换的一定要在开头</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1a&#x27;</span>));<span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;a1&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>());<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;x&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;x&#x27;</span>));<span class="comment">//NaN</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-1-isNaN（）函数"><a href="#2-1-isNaN（）函数" class="headerlink" title="2.1 isNaN（）函数"></a>2.1 isNaN（）函数</h3><p>用来确定一个值是否为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isNaN()，判断传入的参数是否为NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有0/0会返回true，其他任何数值都是false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">1</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">1</span> / <span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">//false（ 10 是一个数值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能转为数字的别的类型也会返回false,无法转换的返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">//false（可以被转换成数值 10）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;a10&quot;</span>)); <span class="comment">//true（可以被转换成数值 10）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//true（不能转换成数值）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure>


<h2 id="3-0-1-0-2不等于0-3"><a href="#3-0-1-0-2不等于0-3" class="headerlink" title="3.0.1+0.2不等于0.3"></a>3.0.1+0.2不等于0.3</h2><p>失精<br>参考：<a href="https://juejin.im/post/5b90e00e6fb9a05cf9080dff">https://juejin.im/post/5b90e00e6fb9a05cf9080dff</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//0.30000000000000004</span></span><br></pre></td></tr></table></figure>


<h1 id="五、Boolean类型"><a href="#五、Boolean类型" class="headerlink" title="五、Boolean类型"></a>五、Boolean类型</h1><p>只有两个值：true和false<br>在输出Boolean类型时，不能加引号哦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>);<span class="comment">//false ---&gt; 布尔类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;false&#x27;</span>);<span class="comment">//false ---&gt; 字符串类型</span></span><br></pre></td></tr></table></figure>
<h1 id="六、Null"><a href="#六、Null" class="headerlink" title="六、Null"></a>六、Null</h1><p>null表示”空对象”，即该处不应该有值，用来表示空指针引用。<br>typeof Null 返回的是object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h1 id="七、undefined"><a href="#七、undefined" class="headerlink" title="七、undefined"></a>七、undefined</h1><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 变量声明了未赋值，返回的即使undefined</span><br><span class="line">  var a;</span><br><span class="line">  console.log(a);//undefined</span><br><span class="line">  </span><br><span class="line">  // 检测undefined类型</span><br><span class="line">  console.log(typeof undefined);//undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h1 id="八、比较Null和undefined"><a href="#八、比较Null和undefined" class="headerlink" title="八、比较Null和undefined"></a>八、比较Null和undefined</h1><p>简单理解，以糖葫芦为例，本来应该是一串糖葫芦，undefined相当于就剩一个竹签了，null就是连签都没有…<br>推荐文章<br><a href="https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// null与undefined</span><br><span class="line">console.log(null == undefined);//ture</span><br><span class="line">console.log(null === undefined);//false</span><br><span class="line"></span><br><span class="line">// 计算</span><br><span class="line">console.log(1 + null);//1</span><br><span class="line">console.log(1 + undefined);//NaN</span><br></pre></td></tr></table></figure>


<h1 id="九、基本数据类型和引用数据类型区别"><a href="#九、基本数据类型和引用数据类型区别" class="headerlink" title="九、基本数据类型和引用数据类型区别"></a>九、基本数据类型和引用数据类型区别</h1><h2 id="1-储存位置不同"><a href="#1-储存位置不同" class="headerlink" title="1.储存位置不同"></a>1.储存位置不同</h2><ul>
<li>基本数据类型存放在栈中，数据大小确定，内存空间大小可以分配，直接按值存放的，所以可以直接按值访问。</li>
<li>引用数据类型存放在堆内存中，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址)，这个指针指向堆内存。在栈内存中保存的是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</li>
</ul>
<blockquote>
<p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。<br>堆：先进先出<br>栈：先进后出<br>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661556-a22ecd2b-19b9-49fc-a03e-a3961bdc15a0.png#align=left&display=inline&height=954&margin=%5Bobject%20Object%5D&originHeight=954&originWidth=1713&size=0&status=done&style=none&width=1713"></p>
</blockquote>
<h2 id="2-复制操作"><a href="#2-复制操作" class="headerlink" title="2.复制操作"></a>2.复制操作</h2><ul>
<li>基本数据类型从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上，改变源数据不会影响到新的变量（互不干涉）</li>
<li>引用类型复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此改变其中的一个，将影响另一个；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = a;</span><br><span class="line">  b = 20;</span><br><span class="line"></span><br><span class="line">  var arr = [&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;];</span><br><span class="line">  var arr1 = arr;</span><br><span class="line">  arr1.push(&#x27;666&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 基本数据类型复制后，改变复制的变量，原值不受影响</span><br><span class="line">  console.log(a);//10</span><br><span class="line">  console.log(b );//20</span><br><span class="line"></span><br><span class="line">  // 引用类型复制后，改变复制的变量，原值也会跟着改变</span><br><span class="line">  console.log(arr);//[&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;,&#x27;666&#x27;]</span><br><span class="line">  console.log(arr1);//[&#x27;小&#x27;,&#x27;艾&#x27;,&#x27;同学&#x27;,&#x27;666&#x27;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1307005/1587290661598-aba71641-d1c0-4a7a-9606-cd5f1169e7ad.png#align=left&display=inline&height=1214&margin=%5Bobject%20Object%5D&originHeight=1214&originWidth=2880&size=0&status=done&style=none&width=2880"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>01-我的足迹</title>
    <url>/2021/08/03/01-%E6%88%91%E7%9A%84%E8%B6%B3%E8%BF%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我的足迹"><a href="#我的足迹" class="headerlink" title="我的足迹"></a>我的足迹</h2><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1627962230903-1627962230899-009ab009c185d053eb57474d868fce4.jpg"></p>
<h2 id="旅行经历"><a href="#旅行经历" class="headerlink" title="旅行经历"></a>旅行经历</h2><p>2021/4/26 - 2021/5/5 去了云南</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化</title>
    <url>/2021/08/16/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><h2 id="一、什么是模块化"><a href="#一、什么是模块化" class="headerlink" title="一、什么是模块化"></a>一、什么是模块化</h2><p>模块化开发最终的目的是将程序划分成一个个小的模块</p>
<ul>
<li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构； </li>
<li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li>
<li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li>
</ul>
<p>按照这种结构划分开发程序的过程，就是模块化开发的过程</p>
<h2 id="二、没有模块化带来的问题"><a href="#二、没有模块化带来的问题" class="headerlink" title="二、没有模块化带来的问题"></a>二、没有模块化带来的问题</h2><ol>
<li>污染全局作用域</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>文件只能按照script标签的书写顺序进行加载</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ol>
<p>开发项目时，aaa和bbb给变量命名的时候都命名为<code>flag</code>，在index引入时根据<code>flag</code>的值作相应逻辑，这时候会因为命名冲突产生报错，<code>flag</code>会因为引入文件的顺序而产生不确定性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">·</span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">let</span> flag = fals</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629107910242-1629107910236.png"></p>
<h2 id="三、模块化方案"><a href="#三、模块化方案" class="headerlink" title="三、模块化方案"></a>三、模块化方案</h2><h3 id="1-CommonJs"><a href="#1-CommonJs" class="headerlink" title="1.CommonJs"></a>1.CommonJs</h3><p>CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了<br>体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS</p>
<p>CommonJS规范的核心变量：exports、module.exports、require；</p>
<p>exports和module.exports可以负责对模块中的内容进行导出； </p>
<p>require函数负责导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="1-exports"><a href="#1-exports" class="headerlink" title="1.exports"></a>1.exports</h4><p>exports是一个对象，在这个对象中添加很多个属性，添加的属性会导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">id</span>:<span class="number">757</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载到对象可以使用别名</span></span><br><span class="line"><span class="built_in">exports</span>.ageAlias = age</span><br><span class="line"><span class="built_in">exports</span>.obj = obj</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo =  <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line">foo.ageAlias = <span class="number">99</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.ageAlias);</span><br><span class="line"><span class="built_in">console</span>.log(foo.obj);</span><br><span class="line">foo.sayHello(<span class="string">&#x27;loveZero&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="思考：exports导出在内存如何体现"><a href="#思考：exports导出在内存如何体现" class="headerlink" title="思考：exports导出在内存如何体现"></a>思考：exports导出在内存如何体现</h5><ol>
<li>1s后在foo.js中修改age值，2s后在bar里打印，值为修改后的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">exports</span>.age = <span class="number">23</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar---age&#x27;</span>, foo.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar---age&#x27;</span>, foo.age); <span class="comment">// 23</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>1s后再bar里修改age的值，2s后再foo里打印age为bar修改后的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo---age&#x27;</span>, <span class="built_in">exports</span>.age); <span class="comment">// 99</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  foo.age = <span class="number">99</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>结论</li>
</ol>
<p>exports导出的对象和require接受的对象指向统一引用地址</p>
<p>相当于一个浅拷贝，本质是引用赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629185027808-1629185027801.png"></p>
<h4 id="2-module-exports"><a href="#2-module-exports" class="headerlink" title="2.module.exports"></a>2.module.exports</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">id</span>: <span class="number">757</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">ageAlias</span>: age,</span><br><span class="line">  obj,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar---obj&#x27;</span>, foo.obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar---age&#x27;</span>, foo.ageAlias);</span><br><span class="line">foo.sayHello(<span class="string">&#x27;loveZero&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="思考：exports和module-exports区别"><a href="#思考：exports和module-exports区别" class="headerlink" title="思考：exports和module.exports区别"></a>思考：exports和module.exports区别</h5><p>先打印一下他们是否相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span> === <span class="built_in">module</span>.exports); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>两个对象<code>===</code>，说明他们指向统一引用地址，就是赋值关系</p>
<p>是exports赋值给module.exports还是module.exports赋值给exports呢？需要进一步验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.exports&#x27;</span>, <span class="built_in">module</span>.exports); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;exports&#x27;</span>, <span class="built_in">exports</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; age &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">name</span>: <span class="string">&#x27;loveZero&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.exports&#x27;</span>, <span class="built_in">module</span>.exports);  <span class="comment">// &#123; name: &#x27;loveZero&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;exports&#x27;</span>, <span class="built_in">exports</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>, foo) <span class="comment">// &#123; name: &#x27;loveZero&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过上述代码可以看出，module.exports和exports初始值都是空对象，通过module.exports导出age后，改变module.exports的值，之后打印exports的值仍为空对象，bar中引入的值是module.exports的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.exports&#x27;</span>, <span class="built_in">module</span>.exports); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;exports&#x27;</span>, <span class="built_in">exports</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;loveZero&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.exports&#x27;</span>, <span class="built_in">module</span>.exports);  <span class="comment">// &#123; age: 200 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;exports&#x27;</span>, <span class="built_in">exports</span>); <span class="comment">// &#123; name: &#x27;loveZero&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>, foo) <span class="comment">// &#123; age: 200 &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过上述验证可以看到，module.exports和exports初始值都是空对象，通过exports将age导出后，修改exports的值，此时module.exports的值为<code>&#123; age: 200 &#125;</code>，exports的值为<code>&#123; name: &#39;loveZero&#39; &#125;</code> ，bar中引用的值是module.exports的值</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol>
<li>module.exports 初始值为一个空对象 {}</li>
<li>exports 是指向的 module.exports 的引用</li>
<li>require导出的内容是module.exports的指向的内存块内容，并不是exports的。</li>
</ol>
<h4 id="3-require"><a href="#3-require" class="headerlink" title="3.require"></a>3.require</h4><p>require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;X&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="1-查找路径"><a href="#1-查找路径" class="headerlink" title="1. 查找路径"></a>1. 查找路径</h5><h6 id="1-X是一个核心模块"><a href="#1-X是一个核心模块" class="headerlink" title="1. X是一个核心模块"></a>1. X是一个核心模块</h6><p> 直接返回核心模块，并且停止查找</p>
<h6 id="2-X是一个以-或-或根目录开头的"><a href="#2-X是一个以-或-或根目录开头的" class="headerlink" title="2.X是一个以./或../或根目录开头的"></a>2.X是一个以./或../或根目录开头的</h6><p> 第一步：将X当做一个文件在对应的目录下查找；</p>
<ol>
<li><p>如果有后缀名，按照后缀名的格式查找对应的文件 </p>
</li>
<li><p>如果没有后缀名，会按照如下顺序： </p>
<ol>
<li>直接查找文件X </li>
<li>查找X.js文件 </li>
<li>查找X.json文件 </li>
<li>查找X.node文件</li>
</ol>
</li>
</ol>
<p>第二步：没有找到对应的文件，将X作为一个目录</p>
<p> 查找目录下面的index文件 </p>
<ol>
<li>查找X/index.js文件</li>
<li>查找X/index.json文件</li>
<li>查找X/index.node文件</li>
</ol>
<p>如果没有找到，那么报错：not found</p>
<h6 id="3-直接是一个X（没有路径），并且X不是一个核心模块"><a href="#3-直接是一个X（没有路径），并且X不是一个核心模块" class="headerlink" title="3.直接是一个X（没有路径），并且X不是一个核心模块"></a>3.直接是一个X（没有路径），并且X不是一个核心模块</h6><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629188758555-1629188758546.png"></p>
<p> 如果上面的路径中都没有找到，那么报错：not found</p>
<h5 id="2-模块的加载过程"><a href="#2-模块的加载过程" class="headerlink" title="2.模块的加载过程"></a>2.模块的加载过程</h5><h6 id="模块在被第一次引入时，模块中的js代码会被运行一次"><a href="#模块在被第一次引入时，模块中的js代码会被运行一次" class="headerlink" title="模块在被第一次引入时，模块中的js代码会被运行一次"></a>模块在被第一次引入时，模块中的js代码会被运行一次</h6><h6 id="模块被多次引入时，会缓存，最终只加载（运行）一次"><a href="#模块被多次引入时，会缓存，最终只加载（运行）一次" class="headerlink" title="模块被多次引入时，会缓存，最终只加载（运行）一次"></a>模块被多次引入时，会缓存，最终只加载（运行）一次</h6><p>当模块被引用后，module中的loaded属性会改为true，会缓存起来，该模块再次被引用时，将不再重新加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629190140490-1629190140472.png"></p>
<h6 id="如果有循环引入，使用深度优先算法"><a href="#如果有循环引入，使用深度优先算法" class="headerlink" title="如果有循环引入，使用深度优先算法"></a>如果有循环引入，使用深度优先算法</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./ccc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./ccc&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./eee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./ddd&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ddd.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ddd&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./eee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// eee.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;eee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// ccc</span></span><br><span class="line"><span class="comment">// ddd</span></span><br><span class="line"><span class="comment">// eee</span></span><br><span class="line"><span class="comment">// bbb</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629189768881-1629189768875.png"></p>
<h4 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h4><ol>
<li>CommonJS模块加载js文件的过程是运行时加载的，并且是同步的<ol>
<li>一个文件没有加载结束之前，后面的代码都不会执行</li>
</ol>
</li>
<li>导出的是一个对象<ol>
<li>导出的和引入的指向都是同一个对象，所以一个变量修改了对象的属性，所有的地方都会被修改</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">exports</span>.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;后面的代码&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="2-ES-Module"><a href="#2-ES-Module" class="headerlink" title="2.ES Module"></a>2.ES Module</h3><p>基本使用：</p>
<ol>
<li>普通script标签执行顺序与书写顺序有关，而加上<code>type=&quot;module&quot;</code>后，script将为异步引入，不会阻塞后面的标签</li>
<li>export 导出模块</li>
<li>import 导入模块</li>
</ol>
<h4 id="1-export"><a href="#1-export" class="headerlink" title="1.export"></a>1.export</h4><p>第一种导出方式：在语句声明的前面直接加上export关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./normal.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">sayHello(<span class="string">&#x27;hah&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;loveZero&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你好&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台结果为</span></span><br><span class="line">我是普通的script标签</span><br><span class="line">loveZero</span><br><span class="line"><span class="number">18</span></span><br><span class="line">你好hah</span><br></pre></td></tr></table></figure>

<p>第二种导出方式：将所有需要导出的标识符，放到export后面的 {}中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;loveZero&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你好&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  <span class="comment">// 可以给导出的变量起别名，使用时也需要使用别名</span></span><br><span class="line">  name <span class="keyword">as</span> nameAlias,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong style="color:red;">注意</strong>:这里的 {}不是表示对象</p>
<h4 id="2-import"><a href="#2-import" class="headerlink" title="2.import"></a>2.import</h4><p>第一种导出方式：import {标识符列表} from ‘模块’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过as 起别名</span></span><br><span class="line"><span class="keyword">import</span> &#123; nameAlias, age <span class="keyword">as</span> ageAlias, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/bar.js&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>第二种导出方式：通过 * 将模块功能放到一个模块功能对象（a module object）上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/bar.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line"><span class="built_in">console</span>.log(foo.nameAlias);</span><br><span class="line">foo.sayHello(<span class="string">&#x27;???&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-export和import混用"><a href="#3-export和import混用" class="headerlink" title="3.export和import混用"></a>3.export和import混用</h4><p>这里相当于是引入了bar里的age，同时导出了age</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中，这样方便指定统一的接口规范，也方便阅读</p>
<h4 id="4-default"><a href="#4-default" class="headerlink" title="4.default"></a>4.default</h4><p>默认导出:</p>
<ul>
<li><p>默认导出export时可以不需要指定名字；</p>
</li>
<li><p>在导入时不需要使用 {}，并且可以自己来指定名字</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">&#x27;./modules/fun.js&#x27;</span></span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>



<h4 id="5-import函数"><a href="#5-import函数" class="headerlink" title="5.import函数"></a>5.import函数</h4><p> 不可以在逻辑代码中使用import加载模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/bar.js&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629268467258-1629268467253.png"></p>
<p>因为ES Module在被JS引擎解析时，就必须知道它的依赖关系</p>
<p>可以通过import函数进行动态加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./modules/bar.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;在then中的打印&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(res.age);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-特点"><a href="#6-特点" class="headerlink" title="6.特点"></a>6.特点</h4><ol>
<li><p> ES Module加载js文件的过程是编译（解析）时加载的，并且是异步的</p>
</li>
<li><p>ES Module是静态解析的，而不是动态或者运行时解析的</p>
</li>
<li><p>ES Module通过export导出的是变量本身的引用</p>
<ol>
<li> export在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment  record）</li>
<li>模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的</li>
<li>在导入的地方，可以实时的获取到绑定的最新值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  age = <span class="number">999</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  age,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 999</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>



<ol start="4">
<li> 在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 18</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  age,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  age = <span class="number">999</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>无法修改且会报错</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629269598906-1629269598890.png"></p>
<p>内存里大概是这个样子</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629270422607-1629270422597.png"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/08/06/Node/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="1-Node概念"><a href="#1-Node概念" class="headerlink" title="1.Node概念"></a>1.Node概念</h2><p> Node.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。  </p>
<p> Node架构</p>
<ul>
<li><p>编写的JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中；</p>
</li>
<li><p>libuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库；</p>
</li>
<li><p>libuv提供了事件循环、文件系统读写、网络IO、线程池等等内容；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628666075562-1628666075553.png"></p>
<h2 id="2-Node基本用法"><a href="#2-Node基本用法" class="headerlink" title="2.Node基本用法"></a>2.Node基本用法</h2><h3 id="1-node中的属性"><a href="#1-node中的属性" class="headerlink" title="1.node中的属性"></a>1.node中的属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端全局变量原则是是global， 但是node在执行的时候为了实现模块化，会在执行代码时，外部包装一个函数，这个函数在执行的时候 会改变this指向</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">global</span>); <span class="comment">// 浏览器中是window  setImmediate 这个是node自己实现</span></span><br><span class="line"><span class="comment">// 可以直接访问这些变量</span></span><br><span class="line"><span class="comment">// process  __filename, __dirname, exports ,module  ,require (这5个变量都是函数的参数)</span></span><br><span class="line"><span class="built_in">console</span>.log(process);</span><br><span class="line"><span class="built_in">console</span>.log(__filename); <span class="comment">// 文件所在位置的绝对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname); <span class="comment">// 文件所在目录的绝对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-process"><a href="#1-process" class="headerlink" title="1.process"></a>1.process</h4><p>拿到process上的键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(process));</span><br></pre></td></tr></table></figure>

<h5 id="platform：识别电脑操作系统"><a href="#platform：识别电脑操作系统" class="headerlink" title="platform：识别电脑操作系统"></a>platform：识别电脑操作系统</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.platform);</span><br><span class="line"><span class="comment">// windows -&gt; win32   mac -&gt; darwin</span></span><br></pre></td></tr></table></figure>

<h5 id="cwd：当前的工作目录"><a href="#cwd：当前的工作目录" class="headerlink" title="cwd：当前的工作目录"></a>cwd：当前的工作目录</h5><p>在哪执行这个文件</p>
<p>webpack(查找配置文件，在当前执行命令的路径下查找)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo</span></span><br></pre></td></tr></table></figure>

<h5 id="env：环境变量"><a href="#env：环境变量" class="headerlink" title="env：环境变量"></a>env：环境变量</h5><p>默认执行的时候会读取电脑的环境变量</p>
<p>win下可以使用set命令来设置， mac下用export来设置 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env);</span><br></pre></td></tr></table></figure>

<h5 id="argv：参数"><a href="#argv：参数" class="headerlink" title="argv：参数"></a>argv：参数</h5><p>执行命令时所带的参数 1.代表的是可执行node.exe 2.执行的是哪个文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#x27;C:\\Program Files\\nodejs\\node.exe&#x27;,</span></span><br><span class="line"><span class="comment">//   &#x27;c:\\Users\\loveZero\\Desktop\\my\\study-demo\\基础\\node.js&#x27;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628495187393-1628495187389.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Node中的内置模块</title>
    <url>/2021/08/18/Node%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node中的内置模块"><a href="#Node中的内置模块" class="headerlink" title="Node中的内置模块"></a>Node中的内置模块</h1><h2 id="一、path"><a href="#一、path" class="headerlink" title="一、path"></a>一、path</h2><h3 id="从路径中获取信息"><a href="#从路径中获取信息" class="headerlink" title="从路径中获取信息"></a>从路径中获取信息</h3><ul>
<li>dirname：获取文件的父文件夹</li>
<li>basename：获取文件名</li>
<li>extname：获取文件扩展名</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 1.获取路径的信息</span></span><br><span class="line"><span class="keyword">const</span> filepath = <span class="string">&#x27;/User/loveZero/abc.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(filepath)); <span class="comment">// /User/loveZero</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(filepath)); <span class="comment">// abc.txt</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(filepath)); <span class="comment">// .txt</span></span><br></pre></td></tr></table></figure>

<h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>只是拼接各个path片段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> basepath = <span class="string">&#x27;../User/loveZero&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&#x27;./abc.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filepath1 = path.join(basepath, filename);</span><br><span class="line"><span class="built_in">console</span>.log(filepath1); <span class="comment">// ..\User\loveZero\abc.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p>会判断拼接的路径字符串中,是否有以/或./或../开头的路径</p>
<p>有的话就返回一个以相对于当前的工作目录（working directory）的绝对路径。</p>
<ol>
<li>参数从后向前，若字符以 / 开头，不会拼接到前面的路径；</li>
<li>若以 ../ 开头，拼接前面的路径，但是不含前面一节的最后一层路径；</li>
<li>若以 ./ 开头 或者没有符号 则拼接前面路径</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> basepath = <span class="string">&#x27;../User/loveZero&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&#x27;./abc.txt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filepath2 = path.resolve(basepath, filename);</span><br><span class="line"><span class="built_in">console</span>.log(filepath2); <span class="comment">// c:\Users\loveZero\Desktop\my\User\loveZero\abc.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li>join是把各个path片段连接在一起， resolve把‘／’当成根目录</li>
<li>resolve在传入的第一参数为非根路径时，会返回一个带当前目录路径的绝对路径。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(path.resolve()) <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;&#x27;</span>)) <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname)) <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo\基础\02-内置模块\path</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;/net&#x27;</span>))   <span class="comment">// c:\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;/net&#x27;</span>))    <span class="comment">// c:\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;./net&#x27;</span>))   <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo\img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;./net&#x27;</span>))   <span class="comment">// c:\img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;net&#x27;</span>))     <span class="comment">// c:\img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))         <span class="comment">// c:\img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))   <span class="comment">// c:\img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;./img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))   <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo\src\img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))     <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo\src\img\net</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(path.join())           <span class="comment">// .</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;&#x27;</span>))         <span class="comment">// .</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(__dirname))  <span class="comment">// c:\Users\loveZero\Desktop\my\study-demo\基础\02-内置模块\path</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;/net&#x27;</span>))   <span class="comment">// \img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;/net&#x27;</span>))    <span class="comment">// img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;./net&#x27;</span>))   <span class="comment">// img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;./net&#x27;</span>))   <span class="comment">// \img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;net&#x27;</span>))     <span class="comment">// \img\books\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))         <span class="comment">// \img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;/img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))   <span class="comment">// src\img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;./img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))   <span class="comment">// src\img\net</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;img/books&#x27;</span>, <span class="string">&#x27;../net&#x27;</span>))     <span class="comment">// src\img\net</span></span><br></pre></td></tr></table></figure>



<h2 id="二、fs"><a href="#二、fs" class="headerlink" title="二、fs"></a>二、fs</h2><p>fs是File System的缩写，表示文件系统</p>
<h3 id="1-获取文件状态"><a href="#1-获取文件状态" class="headerlink" title="1.获取文件状态"></a>1.获取文件状态</h3><h4 id="同步获取"><a href="#同步获取" class="headerlink" title="同步获取"></a>同步获取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> info = fs.statSync(<span class="string">&#x27;./abc.txt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;后续需要执行的代码&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Stats &#123;</span></span><br><span class="line"><span class="comment">  dev: 3728757869,</span></span><br><span class="line"><span class="comment">  mode: 33206,</span></span><br><span class="line"><span class="comment">  nlink: 1,</span></span><br><span class="line"><span class="comment">  uid: 0,</span></span><br><span class="line"><span class="comment">  gid: 0,</span></span><br><span class="line"><span class="comment">  rdev: 0,</span></span><br><span class="line"><span class="comment">  blksize: 4096,</span></span><br><span class="line"><span class="comment">  ino: 8725724278139394,</span></span><br><span class="line"><span class="comment">  size: 3,</span></span><br><span class="line"><span class="comment">  blocks: 0,</span></span><br><span class="line"><span class="comment">  atimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  mtimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  ctimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  birthtimeMs: 1629275160923.6409,</span></span><br><span class="line"><span class="comment">  atime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  mtime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  ctime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  birthtime: 2021-08-18T08:26:00.924Z</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">  后续需要执行的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.stat(<span class="string">&#x27;./abc.txt&#x27;</span>, <span class="function">(<span class="params">err, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(info);</span><br><span class="line">  <span class="comment">// 判断是否是文件</span></span><br><span class="line">  <span class="built_in">console</span>.log(info.isFile());</span><br><span class="line">  <span class="comment">// 判断是否是文件夹</span></span><br><span class="line">  <span class="built_in">console</span>.log(info.isDirectory());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;后续需要执行的代码&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后续需要执行的代码</span></span><br><span class="line"><span class="comment">Stats &#123;</span></span><br><span class="line"><span class="comment">  dev: 3728757869,</span></span><br><span class="line"><span class="comment">  mode: 33206,</span></span><br><span class="line"><span class="comment">  nlink: 1,</span></span><br><span class="line"><span class="comment">  uid: 0,</span></span><br><span class="line"><span class="comment">  gid: 0,</span></span><br><span class="line"><span class="comment">  rdev: 0,</span></span><br><span class="line"><span class="comment">  blksize: 4096,</span></span><br><span class="line"><span class="comment">  ino: 8725724278139394,</span></span><br><span class="line"><span class="comment">  size: 3,</span></span><br><span class="line"><span class="comment">  blocks: 0,</span></span><br><span class="line"><span class="comment">  atimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  mtimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  ctimeMs: 1629275163060.15,</span></span><br><span class="line"><span class="comment">  birthtimeMs: 1629275160923.6409,</span></span><br><span class="line"><span class="comment">  atime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  mtime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  ctime: 2021-08-18T08:26:03.060Z,</span></span><br><span class="line"><span class="comment">  birthtime: 2021-08-18T08:26:00.924Z</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="promise方式"><a href="#promise方式" class="headerlink" title="promise方式"></a>promise方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.promises.stat(<span class="string">&#x27;./abc.txt&#x27;</span>).then(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(info);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;后续需要执行的代码&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-文件描述符"><a href="#2-文件描述符" class="headerlink" title="2.文件描述符"></a>2.文件描述符</h3><p><strong>文件描述符</strong>（file descriptor）在形式上是一个非负整数。实际上，它是一个索引值，每一个文件描述符会与一个打开文件相对应。</p>
<p>每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。</p>
<p>在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">&quot;./abc.txt&quot;</span>, <span class="function">(<span class="params">err, fd</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(fd);</span><br><span class="line">  <span class="comment">//  fd就是文件描述符，一旦获得了文件描述符，就可以通过任何方式执行所需的所有操作</span></span><br><span class="line">  <span class="comment">// 通过描述符去获取文件的信息</span></span><br><span class="line">  fs.fstat(fd, <span class="function">(<span class="params">err, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3.文件读写"></a>3.文件读写</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629278489244-1629278489240.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./abc.txt&quot;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>如果不指定encoding格式，默认将以<buffer>格式返回</li>
<li>如果options是字符串格式，默认是encoding值</li>
</ol>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;一些内容&#x27;</span></span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./abc.txt&#x27;</span>, content, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;文件写入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将内容追加到文件末尾</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.appendFile(<span class="string">&#x27;./abc.txt&#x27;</span>, content, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;文件写入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h4><ul>
<li>w打开文件写入，默认值；</li>
<li>w+打开文件进行读写，如果不存在则创建文件；</li>
<li>r+打开文件进行读写，如果不存在那么抛出异常；</li>
<li>r打开文件读取，读取时的默认值；</li>
<li>a打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；</li>
<li>a+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;./abc.txt&#x27;</span>, content, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a+&#x27;</span> &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;文件写入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="4-文件夹操作"><a href="#4-文件夹操作" class="headerlink" title="4.文件夹操作"></a>4.文件夹操作</h3><h4 id="1-判断文件夹是否存在"><a href="#1-判断文件夹是否存在" class="headerlink" title="1.判断文件夹是否存在"></a>1.判断文件夹是否存在</h4><p>方式一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.existsSync(<span class="string">&#x27;./loveZero&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>方式二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dirname = <span class="string">&#x27;./loveZero&#x27;</span>;</span><br><span class="line"><span class="comment">// 检查文件是否存在于当前目录中。</span></span><br><span class="line">fs.access(dirname, fs.constants.F_OK, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dirname&#125;</span> <span class="subst">$&#123;err ? <span class="string">&#x27;不存在&#x27;</span> : <span class="string">&#x27;存在&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否可读。</span></span><br><span class="line">fs.access(dirname, fs.constants.R_OK, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dirname&#125;</span> <span class="subst">$&#123;err ? <span class="string">&#x27;不可读&#x27;</span> : <span class="string">&#x27;可读&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否可写。</span></span><br><span class="line">fs.access(dirname, fs.constants.W_OK, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dirname&#125;</span> <span class="subst">$&#123;err ? <span class="string">&#x27;不可写&#x27;</span> : <span class="string">&#x27;可写&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在于当前目录中、以及是否可写。</span></span><br><span class="line">fs.access(dirname, fs.constants.F_OK | fs.constants.W_OK, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;dirname&#125;</span> <span class="subst">$&#123;err.code === <span class="string">&#x27;ENOENT&#x27;</span> ? <span class="string">&#x27;不存在&#x27;</span> : <span class="string">&#x27;只可读&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dirname&#125;</span> 存在，且可写`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2.创建文件夹"></a>2.创建文件夹</h4><p>使用 <code>fs.mkdir()</code> 或 <code>fs.mkdirSync()</code> 可以创建新的文件夹。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fs.existsSync(dirname)) &#123;</span><br><span class="line">  fs.mkdir(dirname, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-读取目录内容"><a href="#3-读取目录内容" class="headerlink" title="3.读取目录内容"></a>3.读取目录内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> folderPath = <span class="string">&#x27;../fs&#x27;</span></span><br><span class="line">fs.readdir(folderPath, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(files);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#x27;01-获取文件状态.js&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;02-文件描述符.js&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;03-文件读取.js&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;04-文件写入.js&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;05-文件夹操作.js&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;abc.txt&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;loveZero&#x27;</span></span><br><span class="line"><span class="comment">]*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>递归遍历文件夹里的所有文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> dirname = <span class="string">&#x27;./loveZero&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles</span>(<span class="params">dirname</span>) </span>&#123;</span><br><span class="line">  fs.readdir(dirname, &#123; <span class="attr">withFileTypes</span>: <span class="literal">true</span> &#125;, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">const</span> filepath = path.resolve(dirname, file.name);</span><br><span class="line">        getFiles(filepath);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(file.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFiles(dirname);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aaa.txt</span></span><br><span class="line"><span class="comment">第二层aaa.txt</span></span><br><span class="line"><span class="comment">第三层aaa.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-文件夹重命名"><a href="#4-文件夹重命名" class="headerlink" title="4.文件夹重命名"></a>4.文件夹重命名</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.rename(<span class="string">&#x27;./oldName&#x27;</span>, <span class="string">&#x27;./newName&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-文件夹删除"><a href="#5-文件夹删除" class="headerlink" title="5.文件夹删除"></a>5.文件夹删除</h4><p>安装<code>npm install fs-extra</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folder = <span class="string">&#x27;./newName&#x27;</span></span><br><span class="line"></span><br><span class="line">fs.remove(folder, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>递归删除非空文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDir</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> files = fs.readdirSync(dir)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPath = path.join(dir, files[i]);</span><br><span class="line">    <span class="keyword">let</span> stat = fs.statSync(newPath)</span><br><span class="line">    <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">      <span class="comment">//如果是文件夹就递归下去</span></span><br><span class="line">      removeDir(newPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//删除文件</span></span><br><span class="line">      fs.unlinkSync(newPath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fs.rmdirSync(dir)<span class="comment">//如果文件夹是空的，就将自己删除掉</span></span><br><span class="line">&#125;</span><br><span class="line">removeDir(folder);</span><br></pre></td></tr></table></figure>



<h2 id="三、events"><a href="#三、events" class="headerlink" title="三、events"></a>三、events</h2><h3 id="1-监听和触发事件"><a href="#1-监听和触发事件" class="headerlink" title="1.监听和触发事件"></a>1.监听和触发事件</h3><p><code>emitter.on</code>和<code>emitter.addListener</code>监听事件</p>
<p><code>emitter.emit</code>触发事件</p>
<p>addListener是on的别名，没什么区别</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发射器</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听某一个事件</span></span><br><span class="line"><span class="comment">// addListener是on的alias简写</span></span><br><span class="line">emitter.on(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件on监听&quot;</span>, args);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件addListener监听&quot;</span>, args);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  emitter.emit(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;loveZero&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-移除监听"><a href="#2-移除监听" class="headerlink" title="2.移除监听"></a>2.移除监听</h3><p><code>emitter.off</code>跟上对应的函数可以移除监听，<code>on</code>和<code>addListener</code>一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发射器</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件on监听&quot;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">emitter.on(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addListenerClick</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件addListener监听&quot;</span>, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, addListenerClick)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  emitter.emit(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;loveZero&quot;</span>);</span><br><span class="line">  <span class="comment">// emitter.off(&quot;click&quot;, onClick);</span></span><br><span class="line">  <span class="comment">// emitter.off(&quot;click&quot;, addListenerClick);</span></span><br><span class="line">  emitter.emit(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;loveZero&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 移除所有对某一事件的监听</span></span><br><span class="line">  emitter.removeAllListeners(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">click事件on监听 loveZero</span></span><br><span class="line"><span class="comment">click事件addListener监听 loveZero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-获取事件信息"><a href="#3-获取事件信息" class="headerlink" title="3.获取事件信息"></a>3.获取事件信息</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发射器</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件on监听&quot;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">emitter.on(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addListenerClick</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click事件addListener监听&quot;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, addListenerClick)</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取监听事件名</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter.eventNames()); <span class="comment">// [ &#x27;click&#x27;, &#x27;input&#x27; ]</span></span><br><span class="line"><span class="comment">// 获取click事件监听的次数</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter.listenerCount(<span class="string">&quot;click&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 获取click事件监听函数</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter.listeners(<span class="string">&quot;click&quot;</span>)); <span class="comment">// [ [Function: onClick], [Function: addListenerClick] ]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/02/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>包管理工具</title>
    <url>/2021/08/19/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="一、Npm"><a href="#一、Npm" class="headerlink" title="一、Npm"></a>一、Npm</h2><p>Node Package Manager，就是Node包管理器</p>
<h3 id="1-npm管理的包存放在哪里"><a href="#1-npm管理的包存放在哪里" class="headerlink" title="1. npm管理的包存放在哪里"></a>1. npm管理的包存放在哪里</h3><p>发布包其实是发布到registry上面的；</p>
<p>当我们安装一个包时其实是从registry上面下载的包；</p>
<h3 id="2-项目配置文件-package-json"><a href="#2-项目配置文件-package-json" class="headerlink" title="2. 项目配置文件 package.json"></a>2. 项目配置文件 package.json</h3><p>所有用npm下载的包或者要上传至npm的模块都会有一个package.json文件，这个文件总是存在于模块(或者包)的根目录下。</p>
<p>package.json是对下载的包或模块的描述信息，如果你要上传包到npm服务器也要有对应的模块说明。说明包括项目名称、版本、作者等等。package.json必须是一个严格的json格式，也就是说每一个字段都要使用双引号，不论是key值还是value值。</p>
<h4 id="2-1-创建-package-json"><a href="#2-1-创建-package-json" class="headerlink" title="2.1 创建 package.json"></a>2.1 创建 package.json</h4><p>执行命令<code>npm init -y</code>会默认创建一个package.json文件</p>
<p>name默认值是当前文件夹的名称(不能有中文)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-属性说明"><a href="#2-2-属性说明" class="headerlink" title="2.2 属性说明"></a>2.2 属性说明</h4><ul>
<li><code>name</code> 设置了应用程序/软件包的名称。</li>
<li><code>version</code> 表明了当前的版本。</li>
<li><code>description</code> 是应用程序/软件包的简短描述。</li>
<li><code>main</code> 设置了应用程序的入口点。</li>
<li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外地发布到 <code>npm</code>。</li>
<li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li>
<li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>engines</code> 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>
<li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li>
</ul>
<p>其中必写属性是<code>name</code>和<code>version</code></p>
<h5 id="2-2-1-name"><a href="#2-2-1-name" class="headerlink" title="2.2.1 name"></a>2.2.1 name</h5><ul>
<li>名称不能超过214个字符</li>
<li>名称不能以点或者下划线开头</li>
<li>包的名称中不能包含大写字母</li>
<li>此名称将会成为URL的一部分，因此不能包含非URL的字符</li>
<li>若包名称中存在一些符号，将符号去除后不得与现有包名重复<ul>
<li>由于react-native已经存在，react.native、reactnative都不可以再创建。</li>
</ul>
</li>
</ul>
<p>查看包名是否被占用</p>
<p>使用<code>npm view</code></p>
<p>能查询到信息说明已被使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629362311235-1629362311218.png"></p>
<p>抛出404说明该包名未被使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629362347676-1629362347675.png"></p>
<h5 id="2-2-2-version"><a href="#2-2-2-version" class="headerlink" title="2.2.2 version"></a>2.2.2 version</h5><blockquote>
<p>使用遵循CommonJS规范的require(‘moduleName’)就会加载main字段指定的目录下的文件。这个字段的默认值是模块根目录下面的index.js，</p>
</blockquote>
<ul>
<li>版本号由主版本.此版本.补丁版本组成</li>
<li>版本必须要由<a href="https://link.segmentfault.com/?url=https://docs.npmjs.com/misc/semver.html">node-semver</a>解析，它与npm捆绑在一起作为依赖项。</li>
</ul>
<h5 id="2-2-3-description和keywords"><a href="#2-2-3-description和keywords" class="headerlink" title="2.2.3 description和keywords"></a>2.2.3 description和keywords</h5><p>description用于添加模块的的描述信息，方便别人了解你的模块。</p>
<p>keywords用于给你的模块添加关键字。</p>
<p>当使用 npm search 检索模块时，会到description 和 keywords 中进行匹配。写好 description 和 keywords 有利于你的模块获得更多更精准的曝光</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;说明信息&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;keywords&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="string">&quot;配置&quot;</span>,</span><br><span class="line">      <span class="string">&quot;json&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-4-main"><a href="#2-2-4-main" class="headerlink" title="2.2.4 main"></a>2.2.4 main</h5><p>字段指定了程序的主入口文件</p>
<p>使用遵循CommonJS规范的require(‘moduleName’)就会加载main字段指定的目录下的文件。这个字段的默认值是模块根目录下面的index.js，</p>
<h5 id="2-2-5-author-和-contributors"><a href="#2-2-5-author-和-contributors" class="headerlink" title="2.2.5 author 和 contributors"></a>2.2.5 author 和 contributors</h5><p>author 指包的主要作者，一个 author 对应一个人。 contributors 指贡献者信息，一个 contributors 对应多个贡献者，值为数组</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;作者 &lt;example@example.com&gt; (http://xxx.com)&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;contributors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;贡献者&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;example@example.com&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://xxx.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-6-homepage-和-repository"><a href="#2-2-6-homepage-和-repository" class="headerlink" title="2.2.6 homepage 和 repository"></a>2.2.6 homepage 和 repository</h5><p>homepage 用于指定该模块的主页，repository 用于指定模块的代码仓库。</p>
<h5 id="2-2-7-scripts"><a href="#2-2-7-scripts" class="headerlink" title="2.2.7 scripts"></a>2.2.7 scripts</h5><p>指定了运行脚本命令的npm命令行缩写，，以键值对的形式存在</p>
<p>比如start指定了运行<code>npm run start</code>时，所要执行的命令。</p>
<p>对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;npm run unit&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h5 id="2-2-8-engines"><a href="#2-2-8-engines" class="headerlink" title="2.2.8 engines"></a>2.2.8 engines</h5><p>用于指定Node和NPM的版本号；也可以指定所在的操作系统 “os” : [ “darwin”, “linux” ]</p>
<p>在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;&gt;= 6.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;npm&quot;</span>: <span class="string">&quot;&gt;= 3.0.0&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h5 id="2-2-9-dependencies和devDependencies"><a href="#2-2-9-dependencies和devDependencies" class="headerlink" title="2.2.9 dependencies和devDependencies"></a>2.2.9 dependencies和devDependencies</h5><p>dependencies是指定无论开发环境还是生成环境都需要依赖的包；通常是我们项目实际开发用到的一些库模块；</p>
<p>devDependencies是指一些包在生成环境是不需要的，比如webpack、babel等；</p>
<p>这个时候我们会通过 npm install webpack –save-dev，将它安装到devDependencies属性中；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h4 id="2-3-版本问题"><a href="#2-3-版本问题" class="headerlink" title="2.3 版本问题"></a>2.3 版本问题</h4><p>我们会发现安装的依赖版本出现：<code>^2.0.3</code>或<code>~2.0.3</code>，这是什么意思呢？</p>
<p>npm的包通常需要遵从semver版本规范：</p>
<ul>
<li>semver：<a href="https://link.zhihu.com/?target=https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li>
<li>npm semver：<a href="https://link.zhihu.com/?target=https://docs.npmjs.com/misc/semver">https://docs.npmjs.com/misc/semver</a></li>
</ul>
<p>semver版本规范是X.Y.Z：</p>
<ul>
<li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；</li>
<li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；</li>
<li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；</li>
</ul>
<p>我们这里解释一下 ^和~的区别：</p>
<ul>
<li><code>^x.y.z</code>：表示x是保持不变的，y和z永远安装最新的版本；</li>
<li><code>~x.y.z</code>：表示x和y保持不变的，z永远安装最新的版本；</li>
</ul>
<h3 id="3-npm工具解析"><a href="#3-npm工具解析" class="headerlink" title="3.npm工具解析"></a>3.npm工具解析</h3><h4 id="3-1-全局安装"><a href="#3-1-全局安装" class="headerlink" title="3.1 全局安装"></a>3.1 全局安装</h4><p>全局安装是直接将某个包安装到全局：</p>
<p>比如yarn的全局安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure>

<p>通常使用npm全局安装的包都是一些工具包：yarn、webpack等</p>
<h4 id="3-2-局部安装"><a href="#3-2-局部安装" class="headerlink" title="3.2 局部安装"></a>3.2 局部安装</h4><p>局部安装会在当前目录下生产一个 <code>node_modules</code> 文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装开发和生产依赖</span><br><span class="line">npm install axios --save</span><br><span class="line">npm install axios -S</span><br><span class="line">npm install axios</span><br><span class="line">npm i axios</span><br><span class="line"></span><br><span class="line"># 开发者</span><br><span class="line">npm install axios --save-dev</span><br><span class="line">npm install axios -D</span><br><span class="line">npm i axios -D</span><br></pre></td></tr></table></figure>

<h3 id="4-npm-install原理"><a href="#4-npm-install原理" class="headerlink" title="4. npm install原理"></a>4. npm install原理</h3><h4 id="4-1-package-lock-json文件"><a href="#4-1-package-lock-json文件" class="headerlink" title="4.1 package-lock.json文件"></a>4.1 package-lock.json文件</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lockfileVersion&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;requires&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;axios&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.20.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/axios/-/axios-0.20.0.tgz&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M/v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA==&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;requires&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;follow-redirects&quot;</span>: <span class="string">&quot;^1.10.0&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;follow-redirects&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.13.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.13.0.tgz&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd/TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA==&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>name：项目的名称；</p>
</li>
<li><p>version：项目的版本；</p>
</li>
<li><p>lockfileVersion：lock文件的版本；</p>
</li>
<li><p>requires：使用requires来跟着模块的依赖关系；</p>
</li>
<li><p>dependencies：项目的依赖</p>
</li>
<li><ul>
<li>version表示实际安装的axios的版本；</li>
<li>resolved用来记录下载的地址，registry仓库中的位置；</li>
<li>requires记录当前模块的依赖；</li>
<li>integrity用来从缓存中获取索引，再通过索引去获取压缩包文件；</li>
<li>当前项目依赖axios，但是axios依赖follow-redireacts；</li>
<li>axios中的属性如下</li>
</ul>
</li>
</ul>
<h4 id="4-2-原理图"><a href="#4-2-原理图" class="headerlink" title="4.2 原理图"></a>4.2 原理图</h4><p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629365279284-1629365279279.png"></p>
<h3 id="5-npm其他命令"><a href="#5-npm其他命令" class="headerlink" title="5. npm其他命令"></a>5. npm其他命令</h3><p>卸载某个依赖包： </p>
<ul>
<li>npm uninstall package </li>
<li>npm uninstall package –save-dev </li>
<li>npm uninstall package -D</li>
</ul>
<p>强制重新build</p>
<ul>
<li>npm rebuild</li>
</ul>
<p>清除缓存</p>
<ul>
<li>npm cache clean</li>
</ul>
<h2 id="二、Yarn工具"><a href="#二、Yarn工具" class="headerlink" title="二、Yarn工具"></a>二、Yarn工具</h2><p>另一个node包管理工具yarn：</p>
<ul>
<li>yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；</li>
<li>yarn 是为了弥补 npm 的一些缺陷而出现的；</li>
<li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；</li>
<li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；</li>
</ul>
<p>这里给出一张常用命令的对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1629365546307-1629365546304.png"></p>
<h2 id="三、cnpm"><a href="#三、cnpm" class="headerlink" title="三、cnpm"></a>三、cnpm</h2><p>由于一些特殊的原因，某些情况下我们没办法很好的从 <code>https://registry.npmjs.org</code>下载下来一些需要的包。</p>
<p>查看npm镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config get registry # npm config get registry</span><br></pre></td></tr></table></figure>

<p>我们可以直接设置npm的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>但是对于大多数人来说（比如我），并不希望将npm镜像修改了：</p>
<ul>
<li>第一，不太希望随意修改npm原本从官方下来包的渠道；</li>
<li>第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；</li>
</ul>
<p>这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm config get registry # https://r.npm.taobao.org/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器事件环EventLoop</title>
    <url>/2021/08/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E7%8E%AFEventLoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器事件环EventLoop"><a href="#浏览器事件环EventLoop" class="headerlink" title="浏览器事件环EventLoop"></a>浏览器事件环EventLoop</h1><h2 id="1-进程和“线程”"><a href="#1-进程和“线程”" class="headerlink" title="1.进程和“线程”"></a>1.进程和“线程”</h2><p> 进程：计算机分配任务的 和调度的任务最小单位， 浏览器是一个多进程模型， 每个页卡都是一个独立的进程 （更稳定）</p>
<p> 后端代码都是采用多进程</p>
<p>线程 ： 常见的线程有哪些 (JS是单线程的？主线程是单线程的)</p>
<ol>
<li><p>GUI渲染 页面渲染，绘图、绘制 3d动画</p>
</li>
<li><p>js渲染引擎： 执行js代码 当js执行时 渲染线程会挂起 -》 渲染时不能执行js</p>
</li>
<li><p>事件触发线程 EventLoop</p>
</li>
<li><p>webApi 也会创建线程 事件、定时器、ajax请求都会创造一个线程</p>
</li>
</ol>
<h2 id="2-宏任务和微任务"><a href="#2-宏任务和微任务" class="headerlink" title="2.宏任务和微任务"></a>2.宏任务和微任务</h2><ol>
<li>宏任务<ul>
<li> &lt;执行脚本 script&gt;</li>
<li>setTimeout </li>
<li>setInterval </li>
<li>setImmediate </li>
<li>事件</li>
<li>ajax </li>
<li> MessageChannel (I/O)</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>微任务</p>
<ul>
<li><p>promise</p>
</li>
<li><p>MutationObserer（监视DOM树的变化）</p>
</li>
<li><p>node中的process.nextTick</p>
</li>
</ul>
</li>
<li><p>渲染有关</p>
<ul>
<li>requestAnimationFrame (（大约）16.6ms 会渲染一次页面，也有可能不渲染) 渲染之前执行的</li>
<li> requestIDleCallback 空闲时间执行 </li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>总结</p>
<ol>
<li><p>先执行script脚本，将宏任务和微任务进行分类，如果调用的是浏览器api ，浏览器会开一个线程，等时间到了，会自动的放入到宏任务队列中,微任务是直接放到微任务队列中的</p>
</li>
<li><p>js执行完毕后，会清空所有的微任务，如果微任务在产生微任务，会放到当前微任务队列的尾部</p>
</li>
<li><p>微任务对列清空后，如果页面需要渲染，则会执行渲染流程</p>
</li>
<li><p>事件触发线程EventLoop会不停的扫描宏任务队列，如果宏任务队列中有对应的回调，会取出来执行一个，继续执行上述过程</p>
</li>
<li><p>宏任务每次调用一个，微任务是请空所有微任务队列</p>
</li>
<li><p>每次执行宏任务 都会创造一个新的队列，宏任务队列只有一个</p>
<p>​    </p>
</li>
</ol>
</li>
</ol>
<p>画图功底有限…</p>
<p><img src="https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628232140260-1628232140253.png"></p>
<h2 id="3-代码实操"><a href="#3-代码实操" class="headerlink" title="3.代码实操"></a>3.代码实操</h2><h3 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.style.background = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.style.background = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果是：1,3,2，黄变绿闪烁。原因是：微任务执行完才走渲染，red虽然是同步任务，添加到渲染线程里面了，但是微任务执行完yellow后，覆盖了，所以不会出现红色，但是宏任务green执行后，又将颜色改为了绿色，这段时间差就会出现闪烁。</p>
<h3 id="案例2："><a href="#案例2：" class="headerlink" title="案例2："></a>案例2：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task1&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task2&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码，点击按钮后，会依次打印：click1，micro task1，click2，micro task2</p>
<p>原因是js脚本运行后，会将两个点击事件放入浏览器api中，当点击了按钮，就将两个事件按先后顺序压入宏任务队列，然后执行click1，先执行同步任务console.log，在创建微任务队列执行promise，微任务执行完后，没有要渲染的页面，。就拿出第二个宏任务click2，执行同步任务，再创建微任务队列，执行promise。</p>
<h3 id="案例3："><a href="#案例3：" class="headerlink" title="案例3："></a>案例3：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task1&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;micro task2&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  btn.click()</span><br></pre></td></tr></table></figure>

<p>上述代码，打印顺序是：click1,click2,micro task1,micro task1</p>
<p>原因是：手动调用click事件，就不会产生宏任务，所以先执行同步任务console.log，在一次执行promise</p>
<h3 id="案例4："><a href="#案例4：" class="headerlink" title="案例4："></a>案例4：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码答应顺序依次是：Promise1，setTimeout1，Promise2，setTimeout2</p>
<p>手动模拟一下运行时候的场景(省略了浏览器api过程)</p>
<ol>
<li><p>第一轮先将栈里的任务分别放入</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏任务队列[setTimeout1]，微任务队列[Promise1]</p>
</li>
<li><p>清空微任务，此时执行promise1打印Promise1，将产生的宏任务压入宏任务队列，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong>： 宏[setTimeout1,setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout1执行，打印setTimeout1，创建微任务队列，将promise2压入队列，此时宏任务setTimeout1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[promise2]</p>
</li>
<li><p>宏任务执行完毕需要清空微任务队列，拿出promise2执行，打印promise2，页面无需渲染</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout2]，微[]</p>
</li>
<li><p>EventLoop监测到微任务队列为空，就从宏任务队列中拿到setTimeout2执行，打印setTimeout2，此时宏任务微任务队列都是空，本轮渲染结束</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[]，微[]</p>
</li>
</ol>
<h3 id="案例5："><a href="#案例5：" class="headerlink" title="案例5："></a>案例5：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果是：16238745</p>
<p>原因是：</p>
<ol>
<li><p>解释async…await</p>
<ol>
<li><p>async 执行后返回的是一个promise</p>
</li>
<li><p>await console.log(3); =&gt; return Promise.resolve(console.log(3)).then(()=&gt;console.log(4))</p>
<p>相当于让await后面的代码立即执行，将await下面的代码用then的形式添加到微任务队列</p>
</li>
</ol>
</li>
<li><p>首先肯定打印1，继续往下走async函数声明了未调用先不用管，setTime进入宏任务队列，promise进入微任务队列，then不用管，async函数调用，将返回函数作为promise2压入微任务队列，console暂时执行不到</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise1，promise2]</p>
</li>
<li><p>先执行promise1，打印6，resolve将7传入then中，把7then压入微任务队列，promise1执行完毕</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[promise2,7then]</p>
</li>
<li><p>执行promise2，打印2，打印3，将4then压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[7then,4then]</p>
</li>
<li><p>此时async函数执行完毕。console.log(8)执行打印8</p>
</li>
<li><p>继续执行微任务7then，打印7</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[4then]</p>
</li>
<li><p>继续执行微任务4then，打印4</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：宏[setTimeout]，微[]</p>
</li>
<li><p>此时微任务队列清空，开始执行宏任务，打印5</p>
</li>
<li><p>此时宏任务，微任务全部清空，程序结束</p>
</li>
</ol>
<h3 id="案例6："><a href="#案例6：" class="headerlink" title="案例6："></a>案例6：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述打印结果为0,1,2,3,4,5</p>
<p>原因是</p>
<ol>
<li><p>解释return一个promise，不会立刻处理，而是会将这个promise放入异步代码中</p>
</li>
<li><p>将then0和then1放入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then0，then1]</p>
</li>
<li><p>执行then0,打印02，返回一个Promise.resolve，会执行自己的then方法</p>
</li>
<li><p>执行then1打印，将then2压入栈中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then2]</p>
</li>
<li><p>由于return一个promise的特性，then会延迟执行</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then2，then]</p>
</li>
<li><p>执行then2打印then2，将then3压入微任务队列</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then，then3]</p>
</li>
<li><p>执行then，将4传入then中，将then4压入队列</p>
</li>
<li><p>执行then3，打印3，将then5压入队列中</p>
<p><strong style="color:#17a2b8;">此时任务栈情况是</strong> ：微[then4，then5]</p>
</li>
<li><p>依次执行，打印4,5，程序结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2021/08/04/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>举个简单例子：</p>
<p>你爸爸承诺下礼拜发工资了给你买个手机。你 [不知道] 你是否会得到手机直到下礼拜，此时进入等待态。你爸爸真的给你买一个手机(因为发工资有钱了)，也可以告诉你不买了(因为先给自己买了)。这是一个承诺。一个承诺有3个状态。分别是:</p>
<p>1.悬而未决：你 [不知道] 你是否会得到手机直到下礼拜（<strong style="color:#17a2b8;">等待态</strong>）。</p>
<p>2.解决：你老妈给你买了，因为发工资有钱了（<strong style="color:#17a2b8;">成功态</strong>）。</p>
<p>3.拒绝：你老妈拒绝给你买，因为钱不够（<strong style="color:#17a2b8;">失败态</strong>）。</p>
<p>总结：</p>
<ol>
<li>Promise 有三个状态 ：<ol>
<li> 默认状态叫等待态 pending</li>
<li>resolve表示成功态 fulfilled</li>
<li>reject表示变成失败态 rejected</li>
</ol>
</li>
<li>成功有成功的原因，失败也有失败的原因</li>
<li>只有pending的状态的时候才能改变状态<ul>
<li>不能从成功变为失败</li>
<li>不能从失败变为成功</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">const</span> money = <span class="number">9999</span></span><br><span class="line"><span class="keyword">const</span> bugPhone = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (money &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;有钱，买！&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;我先给我买手机了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// then方法中提供两个参数 1. 成功回调 2.失败的回调</span></span><br><span class="line">bugPhone.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>当既调用成功，又调用失败：只会变为第一次调用的状态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时只会执行resolve，因为状态一旦确定无法改变</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>失败状态的方法reject和throw new Error都可以变为失败态</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在异步中，仍然可以正常使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;error&#x27;)</span></span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="comment">// return new Error(&#x27;失败&#x27;)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>支持<code>.then</code> 链式调用<ul>
<li>当<code>.then</code> 中返回的是一个Promise，可以继续<code>.then</code> 调用这个返回的promise，以下称原来的promise为promise，返回的promise为promise2<ul>
<li>当promise2结果是成功：链式调用<code>.then</code>直接进入<code>resolve</code></li>
<li>当promise2结果为失败或抛出异常：链式调用<code>.then</code>直接进入<code>reject</code></li>
</ul>
</li>
<li>当<code>.then</code> 中返回的的是一个非Promise，链式调用<code>.then</code>时，直接进入<code>resolve</code></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个promise，并是成功态</span></span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 进入成功</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个promise，并是失败态，或异常</span></span><br><span class="line">    <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err) <span class="comment">// 进入失败</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个非promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 直接进入成功</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>链式调用中不允许循环引用<ul>
<li>new一个Promise，<code>.then</code>时，将这个Promise返回，链式<code>.then</code>再次调用就会出现循环引用</li>
<li>原理是：返回的promise始终在等待态，再调用依然是等待态。通俗说就是自己等自己</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise6 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise6;<span class="comment">// prending resolve()/reject()</span></span><br><span class="line">&#125;)</span><br><span class="line">promise6.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err) <span class="comment">// err [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>链式调用可选参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise7 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  <span class="comment">// 当then里没有传任何值的时候，最后一个then用的依然是第一次传入的值</span></span><br><span class="line">&#125;).then().then().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="2-根据promiseaplus官网-的规则，手写自己的Promise"><a href="#2-根据promiseaplus官网-的规则，手写自己的Promise" class="headerlink" title="2.根据promiseaplus官网  的规则，手写自己的Promise"></a>2.根据<a href="https://promisesaplus.com/">promiseaplus官网 </a> 的规则，手写自己的Promise</h3><h4 id="1-一个基本的promise，满足异步promise，但无法进行链式调用"><a href="#1-一个基本的promise，满足异步promise，但无法进行链式调用" class="headerlink" title="1.一个基本的promise，满足异步promise，但无法进行链式调用"></a>1.一个基本的promise，满足异步promise，但无法进行链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span>; <span class="comment">// 默认等待态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span>; <span class="comment">// 成功态 </span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span>; <span class="comment">// 失败态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认状态改为PENDING</span></span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="comment">// 储存传入的成功值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 储存传入的失败</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="comment">// 成功方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 将状态改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED</span><br><span class="line">        <span class="comment">// 执行储存的成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败方法</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 将状态改为失败</span></span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED</span><br><span class="line">        <span class="comment">// 执行储存的失败回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 默认new Promise中的函数会立即执行</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        <span class="comment">// 成功时</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        <span class="comment">// 失败时</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 等待时</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将成功函数push到成功回调队列</span></span><br><span class="line">          onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将成功函数push到失败回调队列</span></span><br><span class="line">          onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>

<h4 id="2-支持链式调用"><a href="#2-支持链式调用" class="headerlink" title="2.支持链式调用"></a>2.支持链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span>; <span class="comment">// 默认等待态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span>; <span class="comment">// 成功态 </span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span>; <span class="comment">// 失败态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理promise逻辑的函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span></span><br><span class="line"><span class="comment"> * 2.x是一个非promise，统统调用resolve</span></span><br><span class="line"><span class="comment"> * 3.x是抛出异常，进入reject</span></span><br><span class="line"><span class="comment"> * 4.x和promise2不能一样，会出现循环引用</span></span><br><span class="line"><span class="comment"> * 5.resolve和reject都只能调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;返回的promise&#125;</span> </span>x </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;new的新&#125;</span> </span>promise2 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;成功方法&#125;</span> </span>resolve </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;失败方法&#125;</span> </span>reject </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, promise2, resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;循环引用&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断返回的x是否是一个promise(promsise需要有then方法)</span></span><br><span class="line">  <span class="comment">// 可能是一个名为promise的对象，或者是一个自定义的promise函数</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x == <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 记录状态是否改变</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取返回的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为返回的有可能还是一个promise</span></span><br><span class="line">        <span class="comment">// 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span></span><br><span class="line">        <span class="comment">// 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span></span><br><span class="line">        then.call(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 这里说明返回的promise是成功状态</span></span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 这里是失败，直接走失败</span></span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 如果状态改变了，就不往下走</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 执行到这里说明状态没有被改变，就标记为已改变</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">//  让promise2 变成失败态</span></span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进这里，说明x是一个非promise，直接调用resolve</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认状态改为PENDING</span></span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="comment">// 储存传入的成功值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 储存传入的失败</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="comment">// 成功方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 将状态改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED</span><br><span class="line">        <span class="comment">// 执行储存的成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败方法</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有等待态才能改变状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将传入的值赋给value</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 将状态改为失败</span></span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED</span><br><span class="line">        <span class="comment">// 执行储存的失败回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 默认new Promise中的函数会立即执行</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是then()如果传空值，就使用上一个的值</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled == <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected == <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line">    <span class="comment">// 由于promise状态无法修改，所以不能使用同一个promise</span></span><br><span class="line">    <span class="comment">// 实现链式调用不能return this</span></span><br><span class="line">    <span class="comment">// 每次调用then方法 都必须返回一个全新的promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="comment">// 成功时</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          <span class="comment">// 因为需要promise2做参数，所以需要异步调用</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span></span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">              <span class="comment">// 处理函数</span></span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="comment">// 如果出错，直接就走失败</span></span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 失败时</span></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 等待时</span></span><br><span class="line">          <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将成功函数push到成功回调队列</span></span><br><span class="line">                <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将成功函数push到失败回调队列</span></span><br><span class="line">                <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回新的promise，供链式调用</span></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>

<h4 id="3-运行官方测试"><a href="#3-运行官方测试" class="headerlink" title="3.运行官方测试"></a>3.运行官方测试</h4><ol>
<li><p><code>npm install promises-aplus-tests -g</code> 安装测试工具</p>
</li>
<li><p>在promise.js中写 </p>
</li>
<li><p>```js<br>// 官方提供的测试静态方法<br>Promise.deferred = function () {<br>  let dfd = {};<br>  dfd.promise = new Promise((resolve, reject) =&gt; {</p>
<pre><code>dfd.resolve = resolve;
dfd.reject = reject;
</code></pre>
<p>  })<br>  return dfd<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. `promises-aplus-tests promise.js` 根据promise的地址运行测试</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/ailing666/images@master/2021/1628130801594-1628130801589.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.Promise语法糖</span><br><span class="line"></span><br><span class="line">#### 原生Promise</span><br><span class="line"></span><br><span class="line">1. Promise.resolve和Promise.reject</span><br><span class="line">   + Promise.resolve会等待异步任务执行完毕再进入resolve</span><br><span class="line">   + Promise.reject会直接进入catch</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"></span><br><span class="line">Promise.resolve(&#x27;ok&#x27;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data); // ok</span><br><span class="line">&#125;)</span><br><span class="line">// Promise.reject会直接进入catch</span><br><span class="line">Promise.reject(&#x27;失败&#x27;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&#x27;err&#x27;, err); // 失败</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 异步时</span><br><span class="line">Promise.resolve(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;hello&#x27;, &#x27;success&#x27;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;)).then(data =&gt; &#123;</span><br><span class="line">  console.log(data); // hello</span><br><span class="line">&#125;)</span><br><span class="line">// Promise.reject会直接进入catch</span><br><span class="line">Promise.reject(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;hello&#x27;); </span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&#x27;err&#x27;, err); // err Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>Promise.all</p>
<ul>
<li>所有任务都成功，才会进入成功</li>
<li>只要有一个任务失败，就会进入失败</li>
<li>成功任务返回时，会按照书写顺序返回</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fs.readFile(<span class="string">&#x27;./promise-study/name.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), fs.readFile(<span class="string">&#x27;./promise-study/age.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), <span class="number">11</span>]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Promise.finally<ul>
<li>不管成功还是失败都会执行</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally 不管成功还是失败都会执行</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">&#x27;err&#x27;</span>).finally(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 没有参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>, f)</span><br><span class="line">  <span class="comment">// return 一个普通值没有意义</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;finally&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;ok&#x27;</span>).finally(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>, f)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>当返回的是一个promise<ul>
<li>外层promise为reject时<ul>
<li>里层promise为reject，就会使用里层promise的原因走reject</li>
<li>里层的promsie为resolve，就会以外层的reject原因走reject</li>
</ul>
</li>
<li>外层promsie为resolve时<ul>
<li>里层的promise为resolve，就会以外层resolve的原因走resolve</li>
<li>里层的promise为reject，就会以里层reject的原因走reject</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">&#x27;ok&#x27;</span>).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;无论成功失败都执行&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&#x27;finally reject&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="我的promise实现"><a href="#我的promise实现" class="headerlink" title="我的promise实现"></a>我的promise实现</h4><ol>
<li>Promise.resolve和Promise.reject</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const PENDING = &#x27;PENDING&#x27;; // 默认等待态</span><br><span class="line">const FULFILLED = &#x27;FULFILLED&#x27;; // 成功态 </span><br><span class="line">const REJECTED = &#x27;REJECTED&#x27;; // 失败态</span><br><span class="line"></span><br><span class="line">// 处理promise逻辑的函数</span><br><span class="line">/**</span><br><span class="line"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span><br><span class="line"> * 2.x是一个非promise，统统调用resolve</span><br><span class="line"> * 3.x是抛出异常，进入reject</span><br><span class="line"> * 4.x和promise2不能一样，会出现循环引用</span><br><span class="line"> * 5.resolve和reject都只能调用一次</span><br><span class="line"> * @param &#123;返回的promise&#125; x </span><br><span class="line"> * @param &#123;new的新&#125; promise2 </span><br><span class="line"> * @param &#123;成功方法&#125; resolve </span><br><span class="line"> * @param &#123;失败方法&#125; reject </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function resolvePromise(x, promise2, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span><br><span class="line">  if (x <span class="comment">=== promise2) &#123;</span></span><br><span class="line">    return reject(new TypeError(&#x27;循环引用&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断返回的x是否是一个promise(promsise需要有then方法)</span><br><span class="line">  // 可能是一个名为promise的对象，或者是一个自定义的promise函数</span><br><span class="line">  if ((typeof x <span class="comment">=== &#x27;object&#x27; &amp;&amp; x !== null) || (typeof x == &#x27;function&#x27;)) &#123;</span></span><br><span class="line">    // 记录状态是否改变</span><br><span class="line">    let called = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 获取返回的then方法</span><br><span class="line">      let then = x.then;</span><br><span class="line">      if (typeof then <span class="comment">=== &#x27;function&#x27;) &#123;</span></span><br><span class="line">        // 因为返回的有可能还是一个promise</span><br><span class="line">        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span><br><span class="line">        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span><br><span class="line">        then.call(x, (y) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里说明返回的promise是成功状态</span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, (r) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里是失败，直接走失败</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      // 如果状态改变了，就不往下走</span><br><span class="line">      if (called) return;</span><br><span class="line">      // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">      called = true</span><br><span class="line">      //  让promise2 变成失败态</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 进这里，说明x是一个非promise，直接调用resolve</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态改为PENDING</span><br><span class="line">    this.status = PENDING;</span><br><span class="line">    // 储存传入的成功值</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    // 储存传入的失败</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">    this.onRejectedCallbacks = [];</span><br><span class="line">    // 成功方法</span><br><span class="line"><span class="addition">+    const resolve = (value) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      // 看resolve中是否是一个promise</span></span><br><span class="line"><span class="addition">+      if (value instanceof Promise) &#123;</span></span><br><span class="line"><span class="addition">+        // 如果是，就手动掉用then方法。递归知道他不是一个promise</span></span><br><span class="line"><span class="addition">+        return value.then(resolve, reject);</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.value = value</span><br><span class="line">        // 将状态改为成功</span><br><span class="line">        this.status = FULFILLED</span><br><span class="line">        // 执行储存的成功回调</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 失败方法</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.reason = reason</span><br><span class="line">        // 将状态改为失败</span><br><span class="line">        this.status = REJECTED</span><br><span class="line">        // 执行储存的失败回调</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 默认new Promise中的函数会立即执行</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then方法</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    // 这里是then()如果传空值，就使用上一个的值</span><br><span class="line">    onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : v =&gt; v;</span><br><span class="line">    onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : e =&gt; &#123; throw e &#125;;</span><br><span class="line">    // 由于promise状态无法修改，所以不能使用同一个promise</span><br><span class="line">    // 实现链式调用不能return this</span><br><span class="line">    // 每次调用then方法 都必须返回一个全新的promise</span><br><span class="line">    let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      switch (this.status) &#123;</span><br><span class="line">        // 成功时</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          // 因为需要promise2做参数，所以需要异步调用</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span><br><span class="line">              let x = onFulfilled(this.value)</span><br><span class="line">              // 处理函数</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              // 如果出错，直接就走失败</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line">          break;</span><br><span class="line">        // 失败时</span><br><span class="line">        case REJECTED:</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = onRejected(this.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          // 等待时</span><br><span class="line">          this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到成功回调队列</span><br><span class="line">                let x = onFulfilled(this.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到失败回调队列</span><br><span class="line">                let x = onRejected(this.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 返回新的promise，供链式调用</span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  catch(errFn) &#123;</span></span><br><span class="line"><span class="addition">+     return this.then(null, errFn);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  // 静态方法resolve</span></span><br><span class="line"><span class="addition">+  static resolve(value) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      resolve(value);</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  // 静态方法reject</span></span><br><span class="line"><span class="addition">+  static reject(err) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      reject(err);</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 官方提供的测试静态方法</span><br><span class="line">// npm install promises-aplus-tests -g;</span><br><span class="line">Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  return dfd</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.all</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const PENDING = &#x27;PENDING&#x27;; // 默认等待态</span><br><span class="line">const FULFILLED = &#x27;FULFILLED&#x27;; // 成功态 </span><br><span class="line">const REJECTED = &#x27;REJECTED&#x27;; // 失败态</span><br><span class="line"></span><br><span class="line">// 处理promise逻辑的函数</span><br><span class="line">/**</span><br><span class="line"> * 1.x是一个promise，会根据promise的成功或失败来调用 resolve还是reject</span><br><span class="line"> * 2.x是一个非promise，统统调用resolve</span><br><span class="line"> * 3.x是抛出异常，进入reject</span><br><span class="line"> * 4.x和promise2不能一样，会出现循环引用</span><br><span class="line"> * 5.resolve和reject都只能调用一次</span><br><span class="line"> * @param &#123;返回的promise&#125; x </span><br><span class="line"> * @param &#123;new的新&#125; promise2 </span><br><span class="line"> * @param &#123;成功方法&#125; resolve </span><br><span class="line"> * @param &#123;失败方法&#125; reject </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function resolvePromise(x, promise2, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">  // 如果返回的x和上一个promise2是同一个promise，就产生循环引用抛出异常</span><br><span class="line">  if (x <span class="comment">=== promise2) &#123;</span></span><br><span class="line">    return reject(new TypeError(&#x27;循环引用&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断返回的x是否是一个promise(promsise需要有then方法)</span><br><span class="line">  // 可能是一个名为promise的对象，或者是一个自定义的promise函数</span><br><span class="line">  if ((typeof x <span class="comment">=== &#x27;object&#x27; &amp;&amp; x !== null) || (typeof x == &#x27;function&#x27;)) &#123;</span></span><br><span class="line">    // 记录状态是否改变</span><br><span class="line">    let called = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 获取返回的then方法</span><br><span class="line">      let then = x.then;</span><br><span class="line">      if (typeof then <span class="comment">=== &#x27;function&#x27;) &#123;</span></span><br><span class="line">        // 因为返回的有可能还是一个promise</span><br><span class="line">        // 所以需要递归调用resolvePromise，处理返回的值，知道这个值是普通值</span><br><span class="line">        // 使用then.call(x)而不是x.then是因为x.then会在获取一次then方法，触发了get，出现不必要的bug</span><br><span class="line">        then.call(x, (y) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里说明返回的promise是成功状态</span><br><span class="line">          resolvePromise(y, promise2, resolve, reject)</span><br><span class="line">        &#125;, (r) =&gt; &#123;</span><br><span class="line">          // 如果状态改变了，就不往下走</span><br><span class="line">          if (called) return;</span><br><span class="line">          // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">          called = true</span><br><span class="line">          // 这里是失败，直接走失败</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 进到这里可能是&#123;then:1&#125;，非promise值直接进成功</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      // 如果状态改变了，就不往下走</span><br><span class="line">      if (called) return;</span><br><span class="line">      // 执行到这里说明状态没有被改变，就标记为已改变</span><br><span class="line">      called = true</span><br><span class="line">      //  让promise2 变成失败态</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 进这里，说明x是一个非promise，直接调用resolve</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态改为PENDING</span><br><span class="line">    this.status = PENDING;</span><br><span class="line">    // 储存传入的成功值</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    // 储存传入的失败</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 用户调用resolve和reject,可以将对应的结果暴露在当前的promise实例上，存起来</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">    this.onRejectedCallbacks = [];</span><br><span class="line">    // 成功方法</span><br><span class="line">    const resolve = (value) =&gt; &#123;</span><br><span class="line">      // 看resolve中是否是一个promise</span><br><span class="line">      if (value instanceof Promise) &#123;</span><br><span class="line">        // 如果是，就手动掉用then方法。递归知道他不是一个promise</span><br><span class="line">        return value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.value = value</span><br><span class="line">        // 将状态改为成功</span><br><span class="line">        this.status = FULFILLED</span><br><span class="line">        // 执行储存的成功回调</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 失败方法</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      // 只有等待态才能改变状态</span><br><span class="line">      if (this.status <span class="comment">=== PENDING) &#123;</span></span><br><span class="line">        // 将传入的值赋给value</span><br><span class="line">        this.reason = reason</span><br><span class="line">        // 将状态改为失败</span><br><span class="line">        this.status = REJECTED</span><br><span class="line">        // 执行储存的失败回调</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 默认new Promise中的函数会立即执行</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // 如果执行时出错,将错误传递到reject中,执行到了失败的逻辑</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then方法</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    // 这里是then()如果传空值，就使用上一个的值</span><br><span class="line">    onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : v =&gt; v;</span><br><span class="line">    onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : e =&gt; &#123; throw e &#125;;</span><br><span class="line">    // 由于promise状态无法修改，所以不能使用同一个promise</span><br><span class="line">    // 实现链式调用不能return this</span><br><span class="line">    // 每次调用then方法 都必须返回一个全新的promise</span><br><span class="line">    let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      switch (this.status) &#123;</span><br><span class="line">        // 成功时</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          // 因为需要promise2做参数，所以需要异步调用</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              // x 就是上一个then成功或者失败的返回值，这个x决定proomise2 走成功还是走失败</span><br><span class="line">              let x = onFulfilled(this.value)</span><br><span class="line">              // 处理函数</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              // 如果出错，直接就走失败</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line">          break;</span><br><span class="line">        // 失败时</span><br><span class="line">        case REJECTED:</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let x = onRejected(this.reason);</span><br><span class="line">              resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, 0);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          // 等待时</span><br><span class="line">          this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到成功回调队列</span><br><span class="line">                let x = onFulfilled(this.value);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                // 将成功函数push到失败回调队列</span><br><span class="line">                let x = onRejected(this.reason);</span><br><span class="line">                resolvePromise(x, promise2, resolve, reject);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, 0);</span><br><span class="line">          &#125;)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 返回新的promise，供链式调用</span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(errFn) &#123;</span><br><span class="line">    return this.then(null, errFn);</span><br><span class="line">  &#125;</span><br><span class="line">  // 静态方法resolve</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 静态方法reject</span><br><span class="line">  static reject(err) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  static all(promises) &#123;</span></span><br><span class="line"><span class="addition">+    return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+      // 将数组中的promise依次执行 </span></span><br><span class="line"><span class="addition">+      let result = [];</span></span><br><span class="line"><span class="addition">+      let index = 0;</span></span><br><span class="line"><span class="addition">+      // 处理函数</span></span><br><span class="line"><span class="addition">+      function process(v, k) &#123;</span></span><br><span class="line"><span class="addition">+        // 将函数与索引映射</span></span><br><span class="line"><span class="addition">+        result[k] = v;</span></span><br><span class="line"><span class="addition">+        if (++index === promises.length) &#123;</span></span><br><span class="line"><span class="addition">+          resolve(result)</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      for (let i = 0; i &lt; promises.length; i++) &#123;</span></span><br><span class="line"><span class="addition">+        let p = promises[i];</span></span><br><span class="line"><span class="addition">+        // 判断p是否是promsie</span></span><br><span class="line"><span class="addition">+        if (p &amp;&amp; typeof p.then === &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="addition">+          p.then(data =&gt; &#123;</span></span><br><span class="line"><span class="addition">+            process(data, i)</span></span><br><span class="line"><span class="addition">+          &#125;, reject) // 只要有一个失败，就直接调reject</span></span><br><span class="line"><span class="addition">+        &#125; else &#123;</span></span><br><span class="line"><span class="addition">+          // 说明不是promise</span></span><br><span class="line"><span class="addition">+          process(p, i)</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 官方提供的测试静态方法</span><br><span class="line">// npm install promises-aplus-tests -g;</span><br><span class="line">Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  return dfd</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>finally方法,直接写在原型上</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Promise.resolve是因为需要有等待功能</span></span><br><span class="line">    <span class="comment">// 成功就直接进then，但使用的原因是外层的原因</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function">(<span class="params">d</span>) =&gt;</span> y);</span><br><span class="line">  &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//cb执行一旦报错 就直接跳过后续的then的逻辑，直接将错误向下传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完结啦~</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>专题</tag>
      </tags>
  </entry>
</search>
